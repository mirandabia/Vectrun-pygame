{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to VectRun Reference GridGame Bases: Entity Represents the grid game. This class inherits from Entity and represents the grid game. It is responsible for handling the game's main events, such as quitting the game, pressing the escape key, and clicking the mouse button. If a click occurs, it validates the click and performs the player's movement and collision testing. Attributes image_path : str The path to the image file. x_y : tuple The x and y coordinates of the game object. scale_size : float The scale size of the game object. bot_number : int The number of bots in the game. next_menu : str The next menu to be displayed. _game_turn : int The current turn of the game. _mov_stage : int The current stage of the player's movement. _clicked : bool True if the player has clicked, False otherwise. _deck : Deck The deck of cards. _player : Player The player object. _bots : Group The group of bots. _all_riders : Group The group of all riders. Methods init (self, image_path, x_y, scale_size, bot_number) Initializes the Game object. update(self) Update the game state. draw(self, screen) Draw the game elements on the screen. choice_preview(self, screen) Preview the selected card and its path on the screen. __preview_selected_card(card, screen) Draw the outline of the selected card. __preview_selected_path(card, screen) Preview the selected path on the screen. __validate_click(self) Verifies if the player clicked on a card and prepares the player's movement. __card_clicked(self) Verifies if a card has been clicked by the player. move_player(self, rider) Move the player's rider. __end_turn(self) Reverses the game state and advances the turn. __next_player_movement(self, card=None) Perform the movement of the next player in the game. __first_turn_collision(self) Verifies if any rider has collided during the first turn. check_collision(self, rider) Check for collisions between the rider and the game elements. __kill_rider(self, rider) Kills the specified rider and advances the turn. Source code in src/game.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 class GridGame ( Entity ): \"\"\" Represents the grid game. This class inherits from Entity and represents the grid game. It is responsible for handling the game's main events, such as quitting the game, pressing the escape key, and clicking the mouse button. If a click occurs, it validates the click and performs the player's movement and collision testing. Attributes ---------- image_path : str The path to the image file. x_y : tuple The x and y coordinates of the game object. scale_size : float The scale size of the game object. bot_number : int The number of bots in the game. next_menu : str The next menu to be displayed. _game_turn : int The current turn of the game. _mov_stage : int The current stage of the player's movement. _clicked : bool True if the player has clicked, False otherwise. _deck : Deck The deck of cards. _player : Player The player object. _bots : Group The group of bots. _all_riders : Group The group of all riders. Methods ------- __init__(self, image_path, x_y, scale_size, bot_number) Initializes the Game object. update(self) Update the game state. draw(self, screen) Draw the game elements on the screen. choice_preview(self, screen) Preview the selected card and its path on the screen. __preview_selected_card(card, screen) Draw the outline of the selected card. __preview_selected_path(card, screen) Preview the selected path on the screen. __validate_click(self) Verifies if the player clicked on a card and prepares the player's movement. __card_clicked(self) Verifies if a card has been clicked by the player. move_player(self, rider) Move the player's rider. __end_turn(self) Reverses the game state and advances the turn. __next_player_movement(self, card=None) Perform the movement of the next player in the game. __first_turn_collision(self) Verifies if any rider has collided during the first turn. check_collision(self, rider) Check for collisions between the rider and the game elements. __kill_rider(self, rider) Kills the specified rider and advances the turn. \"\"\" def __init__ ( self , image_path , x_y , scale_size , bot_number ): \"\"\" Initializes the Game object. Parameters ---------- image_path : str The path to the image file. x_y : tuple The x and y coordinates of the game object. scale_size : float The scale size of the game object. bot_number : int The number of bots in the game. Returns ------- None \"\"\" super () . __init__ ( image_path , x_y , scale_size ) # Atributos para o estado do jogo self . next_menu = \"none\" self . _game_turn = 0 self . _mov_stage = - 1 self . _clicked = False # Cria o deck self . _deck = Deck ( TEXTURE_PATH + \"cards/\" , ( CARD_X , CARD_Y )) # Cria o jogador self . _player = Player ( 1 , ( GRID_X / 2 - 1 , GRID_Y / 2 - 2 ), ( RIDER_X , RIDER_Y ), self . _deck ) # Cria os bots __bot_list = [] for bot in range ( bot_number ): __bot_list . append ( Bot ( bot + 2 , ( GRID_X / 2 - 1 , GRID_Y / 2 - 2 ), ( RIDER_X , RIDER_Y ), self . _deck )) self . _bots = pygame . sprite . OrderedUpdates ( __bot_list [:: - 1 ]) # Grupo com todos personagens animados (bots e player) self . _all_riders = pygame . sprite . Group (( self . _player . sprite ()), self . _bots . sprites ()[:: - 1 ]) def update ( self ): \"\"\" Update the game state. This method handles the main events of the menu, such as quitting the game, pressing the escape key, and clicking the mouse button. If a click occurs, it validates the click and performs the player's movement and collision testing. Returns ------- bool False. \"\"\" # Eventos principais deste menu for event in pygame . event . get (): if event . type == pygame . QUIT : pygame . quit () sys . exit () if event . type == pygame . KEYDOWN : if event . key == pygame . K_ESCAPE : pygame . quit () sys . exit () if event . type == pygame . MOUSEBUTTONDOWN : if event . button == 1 and not self . _clicked and self . _player : self . __validate_click () # Se tiver clicado, roda o movimento do jogador ou dos bots e testa colis\u00e3o if self . _clicked and self . _all_riders : self . move_player ( self . _all_riders . sprites ()[ self . _mov_stage ]) self . check_collision ( self . _all_riders . sprites ()[ self . _mov_stage ]) return False def draw ( self , screen ): \"\"\" Draw the game elements on the screen. Parameters ---------- screen : pygame.Surface The surface to draw the game elements on. Returns ------- None \"\"\" # Desenha o tabuleiro no layer mais baixo screen . blit ( self . image , self . rect ) # Desenha as linhas dos riders for rider in self . _all_riders . sprites (): pygame . draw . lines ( screen , rider . _color , False , rider . _path + [ rider . rect . center ], width = 6 ) # Desenha o contorno e as cartas if self . _player : self . choice_preview ( screen ) self . _player . _hand . draw ( screen ) # Faz blit no jogador e nos bots self . _bots . draw ( screen ) self . _player . draw ( screen ) def choice_preview ( self , screen ): \"\"\" Preview the selected card and its path on the screen. Parameters ---------- screen : pygame.Surface The screen surface to draw on. Returns ------- None \"\"\" # Verifica se o mouse est\u00e1 em cima da carta for card in self . _player . _hand . sprites (): if card . update (): # Desenha o contorno self . __preview_selected_card ( card , screen ) # Se n\u00e3o houver clicado antes, mostra a trajet\u00f3ria da carta if not self . _clicked : self . __preview_selected_path ( card , screen ) @staticmethod def __preview_selected_card ( card , screen ): \"\"\" Draw the outline of the selected card. Parameters ---------- card : Card The selected card object. screen : pygame.Surface The screen surface to draw on. Returns ------- None \"\"\" # Desenha o contorno da carta selecionada rect_pos = ( card . rect . left - CARD_SELECTED_WIDTH , card . rect . top - CARD_SELECTED_WIDTH ) rect_size = ( card . rect . width + 2 * CARD_SELECTED_WIDTH , card . rect . height + 2 * CARD_SELECTED_WIDTH ) rectangle = pygame . Rect ( rect_pos , rect_size ) pygame . draw . rect ( screen , \"#258dc2\" , rectangle , width = 2 * CARD_SELECTED_WIDTH ) def __preview_selected_path ( self , card , screen ): \"\"\" Preview the selected path on the screen. Parameters ---------- card : Card The selected card. screen : pygame.Surface The screen surface to draw on. Returns ------- None \"\"\" # Pega o ponto inicial e final da reta start = pygame . Vector2 ( self . _player . _path [ - 1 ]) # Converte para Vector2 card_value = pygame . Vector2 ( card . value [ 0 ], - card . value [ 1 ]) size_segments = 12 # Defina a dist\u00e2ncia desejada entre os segmentos da linha tracejada num_segments = int ( start . distance_to ( start + card_value * DISTANCE ) / size_segments ) # Desenha a linha tracejada for i in range ( 0 , num_segments , 2 ): segment_start = start + card_value * i * DISTANCE / num_segments segment_end = start + card_value * ( i + 1 ) * DISTANCE / num_segments pygame . draw . line ( screen , self . _player . _color , segment_start , segment_end , width = 5 ) def __validate_click ( self ): \"\"\" Verifies if the player clicked on a card and prepares the player's movement. Returns ------- None \"\"\" # Verifica em qual carta clicou player_card = self . __card_clicked () # Se tiver clicado, prepara o movimento do player if player_card : self . _clicked = True self . __next_player_movement ( player_card ) def __card_clicked ( self ): \"\"\" Verifies if a card has been clicked by the player. Returns ------- Card or None: The clicked card if found, None otherwise. \"\"\" # Se o jogador clicar na carta, _clicked = True for card in self . _player . _hand . sprites (): if card . update (): return card return None def move_player ( self , rider ): \"\"\" Move the player's rider. Parameters ---------- rider : Rider The rider object to be moved. Returns ------- None Notes ----- If the rider is able to update its position on the deck, nothing happens. If the rider is unable to update its position, the next player movement is reset. \"\"\" # Move o rider if rider . update ( self . _deck ): pass # Se ficou parado, reseta o movimento else : self . __next_player_movement () def __end_turn ( self ): \"\"\" Reverses the game state and advances the turn. Returns ------- None \"\"\" # S\u00f3 reverte o estado do jogo e adiciona um turno self . _game_turn += 1 self . _clicked = False self . _mov_stage = - 1 # Quando o jogador estiver morto pula sua vez if not self . _player : self . _mov_stage += 1 self . _clicked = True def __next_player_movement ( self , card = None ): \"\"\" Perform the movement of the next player in the game. Parameters ---------- card : Card, optional The card chosen by the player. Defaults to None. Returns ------- None Notes ----- This method is responsible for advancing the game to the next player's movement. If all players have completed their movements, the turn ends. In the rare case of a collision on the first turn, a special action is triggered. If the player is not alive, the bots will play among themselves. If all players are dead, the method returns without further actions. \"\"\" self . _mov_stage += 1 # Se todos jogadores tiverem se movimentado, acaba o turno if self . _mov_stage == len ( self . _all_riders ): self . __end_turn () # No raro caso de colidirem no primeiro turno if self . _game_turn == 1 : self . __first_turn_collision () # Quando o jogador n\u00e3o estiver vivo os bots jogar\u00e3o entre si if self . _player : return # Se todos morrerem tamb\u00e9m retorna if not self . _all_riders : return # Caso contr\u00e1rio, prepara o jogo para rodar mais uma anima\u00e7\u00e3o next_player = self . _all_riders . sprites ()[ self . _mov_stage ] # Se n\u00e3o tiver passado uma carta, faz o rider escolher (em geral um bot) if not card : card = next_player . choose_card ( self . _all_riders ) # Atualiza o estado do pr\u00f3ximo jogador next_player . select_card ( card ) def __first_turn_collision ( self ): \"\"\" Verifies if any rider has collided during the first turn. This method checks if any rider has collided with the border or with other riders during the first turn of the game. If a collision is detected, the corresponding rider is removed from the game. Returns ------- None \"\"\" for rider in self . _all_riders . sprites ()[:: - 1 ]: if utilities . check_border_collision ( rider . rect . center ): rider . kill () continue if utilities . check_line_collision ( self . _all_riders , rider ) and self . _game_turn : rider . kill () continue def check_collision ( self , rider ): \"\"\" Check for collisions between the rider and the game elements. Parameters ---------- rider (Rider): The rider object to check for collisions. Returns ------- None \"\"\" # Testa colis\u00e3o com a fronteira if utilities . check_border_collision ( rider . rect . center ): self . __kill_rider ( rider ) return # Testa colis\u00e3o com as linhas if utilities . check_line_collision ( self . _all_riders , rider ) and self . _game_turn : self . __kill_rider ( rider ) return # Verifica se colidiram entre si #utilities.check_riders_collision(self._player, self._bots) def __kill_rider ( self , rider ): \"\"\" Kills the specified rider and advances the turn. Parameters ---------- rider (Rider): The rider to be killed. Returns ------- None \"\"\" # Mata o rider rider . kill () # Avan\u00e7a o turno self . _mov_stage -= 1 self . __next_player_movement () __card_clicked () Verifies if a card has been clicked by the player. Returns Card or None: The clicked card if found, None otherwise. Source code in src/game.py 278 279 280 281 282 283 284 285 286 287 288 289 290 291 def __card_clicked ( self ): \"\"\" Verifies if a card has been clicked by the player. Returns ------- Card or None: The clicked card if found, None otherwise. \"\"\" # Se o jogador clicar na carta, _clicked = True for card in self . _player . _hand . sprites (): if card . update (): return card return None __end_turn () Reverses the game state and advances the turn. Returns None Source code in src/game.py 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 def __end_turn ( self ): \"\"\" Reverses the game state and advances the turn. Returns ------- None \"\"\" # S\u00f3 reverte o estado do jogo e adiciona um turno self . _game_turn += 1 self . _clicked = False self . _mov_stage = - 1 # Quando o jogador estiver morto pula sua vez if not self . _player : self . _mov_stage += 1 self . _clicked = True __first_turn_collision () Verifies if any rider has collided during the first turn. This method checks if any rider has collided with the border or with other riders during the first turn of the game. If a collision is detected, the corresponding rider is removed from the game. Returns None Source code in src/game.py 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 def __first_turn_collision ( self ): \"\"\" Verifies if any rider has collided during the first turn. This method checks if any rider has collided with the border or with other riders during the first turn of the game. If a collision is detected, the corresponding rider is removed from the game. Returns ------- None \"\"\" for rider in self . _all_riders . sprites ()[:: - 1 ]: if utilities . check_border_collision ( rider . rect . center ): rider . kill () continue if utilities . check_line_collision ( self . _all_riders , rider ) and self . _game_turn : rider . kill () continue __init__ ( image_path , x_y , scale_size , bot_number ) Initializes the Game object. Parameters image_path : str The path to the image file. x_y : tuple The x and y coordinates of the game object. scale_size : float The scale size of the game object. bot_number : int The number of bots in the game. Returns None Source code in src/game.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 def __init__ ( self , image_path , x_y , scale_size , bot_number ): \"\"\" Initializes the Game object. Parameters ---------- image_path : str The path to the image file. x_y : tuple The x and y coordinates of the game object. scale_size : float The scale size of the game object. bot_number : int The number of bots in the game. Returns ------- None \"\"\" super () . __init__ ( image_path , x_y , scale_size ) # Atributos para o estado do jogo self . next_menu = \"none\" self . _game_turn = 0 self . _mov_stage = - 1 self . _clicked = False # Cria o deck self . _deck = Deck ( TEXTURE_PATH + \"cards/\" , ( CARD_X , CARD_Y )) # Cria o jogador self . _player = Player ( 1 , ( GRID_X / 2 - 1 , GRID_Y / 2 - 2 ), ( RIDER_X , RIDER_Y ), self . _deck ) # Cria os bots __bot_list = [] for bot in range ( bot_number ): __bot_list . append ( Bot ( bot + 2 , ( GRID_X / 2 - 1 , GRID_Y / 2 - 2 ), ( RIDER_X , RIDER_Y ), self . _deck )) self . _bots = pygame . sprite . OrderedUpdates ( __bot_list [:: - 1 ]) # Grupo com todos personagens animados (bots e player) self . _all_riders = pygame . sprite . Group (( self . _player . sprite ()), self . _bots . sprites ()[:: - 1 ]) __kill_rider ( rider ) Kills the specified rider and advances the turn. Parameters rider (Rider): The rider to be killed. Returns None Source code in src/game.py 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 def __kill_rider ( self , rider ): \"\"\" Kills the specified rider and advances the turn. Parameters ---------- rider (Rider): The rider to be killed. Returns ------- None \"\"\" # Mata o rider rider . kill () # Avan\u00e7a o turno self . _mov_stage -= 1 self . __next_player_movement () __next_player_movement ( card = None ) Perform the movement of the next player in the game. Parameters card : Card, optional The card chosen by the player. Defaults to None. Returns None Notes This method is responsible for advancing the game to the next player's movement. If all players have completed their movements, the turn ends. In the rare case of a collision on the first turn, a special action is triggered. If the player is not alive, the bots will play among themselves. If all players are dead, the method returns without further actions. Source code in src/game.py 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 def __next_player_movement ( self , card = None ): \"\"\" Perform the movement of the next player in the game. Parameters ---------- card : Card, optional The card chosen by the player. Defaults to None. Returns ------- None Notes ----- This method is responsible for advancing the game to the next player's movement. If all players have completed their movements, the turn ends. In the rare case of a collision on the first turn, a special action is triggered. If the player is not alive, the bots will play among themselves. If all players are dead, the method returns without further actions. \"\"\" self . _mov_stage += 1 # Se todos jogadores tiverem se movimentado, acaba o turno if self . _mov_stage == len ( self . _all_riders ): self . __end_turn () # No raro caso de colidirem no primeiro turno if self . _game_turn == 1 : self . __first_turn_collision () # Quando o jogador n\u00e3o estiver vivo os bots jogar\u00e3o entre si if self . _player : return # Se todos morrerem tamb\u00e9m retorna if not self . _all_riders : return # Caso contr\u00e1rio, prepara o jogo para rodar mais uma anima\u00e7\u00e3o next_player = self . _all_riders . sprites ()[ self . _mov_stage ] # Se n\u00e3o tiver passado uma carta, faz o rider escolher (em geral um bot) if not card : card = next_player . choose_card ( self . _all_riders ) # Atualiza o estado do pr\u00f3ximo jogador next_player . select_card ( card ) __preview_selected_card ( card , screen ) staticmethod Draw the outline of the selected card. Parameters card : Card The selected card object. screen : pygame.Surface The screen surface to draw on. Returns None Source code in src/game.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 @staticmethod def __preview_selected_card ( card , screen ): \"\"\" Draw the outline of the selected card. Parameters ---------- card : Card The selected card object. screen : pygame.Surface The screen surface to draw on. Returns ------- None \"\"\" # Desenha o contorno da carta selecionada rect_pos = ( card . rect . left - CARD_SELECTED_WIDTH , card . rect . top - CARD_SELECTED_WIDTH ) rect_size = ( card . rect . width + 2 * CARD_SELECTED_WIDTH , card . rect . height + 2 * CARD_SELECTED_WIDTH ) rectangle = pygame . Rect ( rect_pos , rect_size ) pygame . draw . rect ( screen , \"#258dc2\" , rectangle , width = 2 * CARD_SELECTED_WIDTH ) __preview_selected_path ( card , screen ) Preview the selected path on the screen. Parameters card : Card The selected card. screen : pygame.Surface The screen surface to draw on. Returns None Source code in src/game.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 def __preview_selected_path ( self , card , screen ): \"\"\" Preview the selected path on the screen. Parameters ---------- card : Card The selected card. screen : pygame.Surface The screen surface to draw on. Returns ------- None \"\"\" # Pega o ponto inicial e final da reta start = pygame . Vector2 ( self . _player . _path [ - 1 ]) # Converte para Vector2 card_value = pygame . Vector2 ( card . value [ 0 ], - card . value [ 1 ]) size_segments = 12 # Defina a dist\u00e2ncia desejada entre os segmentos da linha tracejada num_segments = int ( start . distance_to ( start + card_value * DISTANCE ) / size_segments ) # Desenha a linha tracejada for i in range ( 0 , num_segments , 2 ): segment_start = start + card_value * i * DISTANCE / num_segments segment_end = start + card_value * ( i + 1 ) * DISTANCE / num_segments pygame . draw . line ( screen , self . _player . _color , segment_start , segment_end , width = 5 ) __validate_click () Verifies if the player clicked on a card and prepares the player's movement. Returns None Source code in src/game.py 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 def __validate_click ( self ): \"\"\" Verifies if the player clicked on a card and prepares the player's movement. Returns ------- None \"\"\" # Verifica em qual carta clicou player_card = self . __card_clicked () # Se tiver clicado, prepara o movimento do player if player_card : self . _clicked = True self . __next_player_movement ( player_card ) check_collision ( rider ) Check for collisions between the rider and the game elements. Parameters rider (Rider): The rider object to check for collisions. Returns None Source code in src/game.py 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 def check_collision ( self , rider ): \"\"\" Check for collisions between the rider and the game elements. Parameters ---------- rider (Rider): The rider object to check for collisions. Returns ------- None \"\"\" # Testa colis\u00e3o com a fronteira if utilities . check_border_collision ( rider . rect . center ): self . __kill_rider ( rider ) return # Testa colis\u00e3o com as linhas if utilities . check_line_collision ( self . _all_riders , rider ) and self . _game_turn : self . __kill_rider ( rider ) return choice_preview ( screen ) Preview the selected card and its path on the screen. Parameters screen : pygame.Surface The screen surface to draw on. Returns None Source code in src/game.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 def choice_preview ( self , screen ): \"\"\" Preview the selected card and its path on the screen. Parameters ---------- screen : pygame.Surface The screen surface to draw on. Returns ------- None \"\"\" # Verifica se o mouse est\u00e1 em cima da carta for card in self . _player . _hand . sprites (): if card . update (): # Desenha o contorno self . __preview_selected_card ( card , screen ) # Se n\u00e3o houver clicado antes, mostra a trajet\u00f3ria da carta if not self . _clicked : self . __preview_selected_path ( card , screen ) draw ( screen ) Draw the game elements on the screen. Parameters screen : pygame.Surface The surface to draw the game elements on. Returns None Source code in src/game.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 def draw ( self , screen ): \"\"\" Draw the game elements on the screen. Parameters ---------- screen : pygame.Surface The surface to draw the game elements on. Returns ------- None \"\"\" # Desenha o tabuleiro no layer mais baixo screen . blit ( self . image , self . rect ) # Desenha as linhas dos riders for rider in self . _all_riders . sprites (): pygame . draw . lines ( screen , rider . _color , False , rider . _path + [ rider . rect . center ], width = 6 ) # Desenha o contorno e as cartas if self . _player : self . choice_preview ( screen ) self . _player . _hand . draw ( screen ) # Faz blit no jogador e nos bots self . _bots . draw ( screen ) self . _player . draw ( screen ) move_player ( rider ) Move the player's rider. Parameters rider : Rider The rider object to be moved. Returns None Notes If the rider is able to update its position on the deck, nothing happens. If the rider is unable to update its position, the next player movement is reset. Source code in src/game.py 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 def move_player ( self , rider ): \"\"\" Move the player's rider. Parameters ---------- rider : Rider The rider object to be moved. Returns ------- None Notes ----- If the rider is able to update its position on the deck, nothing happens. If the rider is unable to update its position, the next player movement is reset. \"\"\" # Move o rider if rider . update ( self . _deck ): pass # Se ficou parado, reseta o movimento else : self . __next_player_movement () update () Update the game state. This method handles the main events of the menu, such as quitting the game, pressing the escape key, and clicking the mouse button. If a click occurs, it validates the click and performs the player's movement and collision testing. Returns bool False. Source code in src/game.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def update ( self ): \"\"\" Update the game state. This method handles the main events of the menu, such as quitting the game, pressing the escape key, and clicking the mouse button. If a click occurs, it validates the click and performs the player's movement and collision testing. Returns ------- bool False. \"\"\" # Eventos principais deste menu for event in pygame . event . get (): if event . type == pygame . QUIT : pygame . quit () sys . exit () if event . type == pygame . KEYDOWN : if event . key == pygame . K_ESCAPE : pygame . quit () sys . exit () if event . type == pygame . MOUSEBUTTONDOWN : if event . button == 1 and not self . _clicked and self . _player : self . __validate_click () # Se tiver clicado, roda o movimento do jogador ou dos bots e testa colis\u00e3o if self . _clicked and self . _all_riders : self . move_player ( self . _all_riders . sprites ()[ self . _mov_stage ]) self . check_collision ( self . _all_riders . sprites ()[ self . _mov_stage ]) return False Card Bases: Entity Represents a card object. Attributes image_path : str The path to the image file for the card. x_y : tuple The x and y coordinates of the card's position. scale_size : float The scale size of the card. value : int The value of the card. Methods init (self, image_path, x_y, scale_size, value) Initialize a Card object. getitem (self, key) Get the value of the card at the specified index. update(self) Update the card's state. Source code in src/deck.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 class Card ( Entity ): \"\"\" Represents a card object. Attributes ---------- image_path : str The path to the image file for the card. x_y : tuple The x and y coordinates of the card's position. scale_size : float The scale size of the card. value : int The value of the card. Methods ------- __init__(self, image_path, x_y, scale_size, value) Initialize a Card object. __getitem__(self, key) Get the value of the card at the specified index. update(self) Update the card's state. \"\"\" def __init__ ( self , image_path , x_y , scale_size , value ): \"\"\" Initialize a Card object. Parameters ---------- image_path : str The path to the image file for the card. x_y : tuple The x and y coordinates of the card's position. scale_size : float The scale size of the card. value : int The value of the card. Returns ------- None \"\"\" super () . __init__ ( image_path , x_y , scale_size ) # Dire\u00e7\u00e3o do vetor self . value = value def __getitem__ ( self , key ): \"\"\" Get the value of the card at the specified index. Parameters ---------- key : int The index of the value to retrieve. Returns ------- int The value of the card at the specified index. \"\"\" return self . value [ key ] def update ( self ): \"\"\" Update the card's state. Returns ------- bool True if the card collides with the mouse position, False otherwise. \"\"\" # Testa se houve colis\u00e3o com o mouse mouse_pos = pygame . mouse . get_pos () # Se houver, retorna True if self . rect . collidepoint ( mouse_pos ): return True else : return False __getitem__ ( key ) Get the value of the card at the specified index. Parameters key : int The index of the value to retrieve. Returns int The value of the card at the specified index. Source code in src/deck.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def __getitem__ ( self , key ): \"\"\" Get the value of the card at the specified index. Parameters ---------- key : int The index of the value to retrieve. Returns ------- int The value of the card at the specified index. \"\"\" return self . value [ key ] __init__ ( image_path , x_y , scale_size , value ) Initialize a Card object. Parameters image_path : str The path to the image file for the card. x_y : tuple The x and y coordinates of the card's position. scale_size : float The scale size of the card. value : int The value of the card. Returns None Source code in src/deck.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def __init__ ( self , image_path , x_y , scale_size , value ): \"\"\" Initialize a Card object. Parameters ---------- image_path : str The path to the image file for the card. x_y : tuple The x and y coordinates of the card's position. scale_size : float The scale size of the card. value : int The value of the card. Returns ------- None \"\"\" super () . __init__ ( image_path , x_y , scale_size ) # Dire\u00e7\u00e3o do vetor self . value = value update () Update the card's state. Returns bool True if the card collides with the mouse position, False otherwise. Source code in src/deck.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def update ( self ): \"\"\" Update the card's state. Returns ------- bool True if the card collides with the mouse position, False otherwise. \"\"\" # Testa se houve colis\u00e3o com o mouse mouse_pos = pygame . mouse . get_pos () # Se houver, retorna True if self . rect . collidepoint ( mouse_pos ): return True else : return False Deck Bases: Entity Represents a deck of cards. Attributes cards : list A list of Card objects representing the cards in the deck. drawn_cards : list A list of Card objects representing the cards that have been drawn from the deck and are in play. Methods init (self, card_path, scale_size) Initializes a Deck object. shuffle_deck(self) Shuffles the deck of cards. draw_card(self) Draws a card from the deck. Source code in src/deck.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 class Deck ( Entity ): \"\"\" Represents a deck of cards. Attributes ---------- cards : list A list of Card objects representing the cards in the deck. drawn_cards : list A list of Card objects representing the cards that have been drawn from the deck and are in play. Methods ------- __init__(self, card_path, scale_size) Initializes a Deck object. shuffle_deck(self) Shuffles the deck of cards. draw_card(self) Draws a card from the deck. \"\"\" def __init__ ( self , card_path , scale_size ): \"\"\" Initializes a Deck object. Parameters ---------- card_path : str The path to the directory containing the card images. scale_size : tuple A tuple representing the scale size of the cards. Returns ------- None \"\"\" super () . __init__ ( card_path + \"card_back.png\" , ( 0 , 0 ), ( 0 , 0 )) self . cards = [] self . drawn_cards = [] # Cartas que foram tiradas do deck e est\u00e3o em jogo # Carrega todas as cartas pra mem\u00f3ria __card_count = 1 for y in range ( - 4 , 5 ): for x in range ( - 4 , 5 ): # Se for a origem, pula (esta carta-vetor n\u00e3o existe) if ( x , y ) == ( 0 , 0 ): continue # Nome do arquivo da carta card_name = \"card_\" + str ( __card_count ) + \".png\" # Cria a carta em si card = Card ( card_path + card_name , ( 0 , 0 ), scale_size , value = ( x , y )) self . cards . append ( card ) __card_count += 1 # Embaralha as cartas self . shuffle_deck () def shuffle_deck ( self ): \"\"\" Shuffles the deck of cards. If the deck is empty, the drawn cards are shuffled and added back to the deck. Otherwise, the deck itself is shuffled. Returns ------- None \"\"\" if not self . cards : random . shuffle ( self . drawn_cards ) self . cards = self . drawn_cards . copy () self . drawn_cards . clear () else : random . shuffle ( self . cards ) def draw_card ( self ): \"\"\" Draws a card from the deck. If the deck is empty, it is shuffled again before drawing a card. Returns: Card: The card that was drawn from the deck. \"\"\" if not self . cards : self . shuffle_deck () card = self . cards . pop ( 0 ) self . drawn_cards . append ( card ) return card __init__ ( card_path , scale_size ) Initializes a Deck object. Parameters card_path : str The path to the directory containing the card images. scale_size : tuple A tuple representing the scale size of the cards. Returns None Source code in src/deck.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def __init__ ( self , card_path , scale_size ): \"\"\" Initializes a Deck object. Parameters ---------- card_path : str The path to the directory containing the card images. scale_size : tuple A tuple representing the scale size of the cards. Returns ------- None \"\"\" super () . __init__ ( card_path + \"card_back.png\" , ( 0 , 0 ), ( 0 , 0 )) self . cards = [] self . drawn_cards = [] # Cartas que foram tiradas do deck e est\u00e3o em jogo # Carrega todas as cartas pra mem\u00f3ria __card_count = 1 for y in range ( - 4 , 5 ): for x in range ( - 4 , 5 ): # Se for a origem, pula (esta carta-vetor n\u00e3o existe) if ( x , y ) == ( 0 , 0 ): continue # Nome do arquivo da carta card_name = \"card_\" + str ( __card_count ) + \".png\" # Cria a carta em si card = Card ( card_path + card_name , ( 0 , 0 ), scale_size , value = ( x , y )) self . cards . append ( card ) __card_count += 1 # Embaralha as cartas self . shuffle_deck () draw_card () Draws a card from the deck. If the deck is empty, it is shuffled again before drawing a card. Returns: Card \u2013 The card that was drawn from the deck. Source code in src/deck.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 def draw_card ( self ): \"\"\" Draws a card from the deck. If the deck is empty, it is shuffled again before drawing a card. Returns: Card: The card that was drawn from the deck. \"\"\" if not self . cards : self . shuffle_deck () card = self . cards . pop ( 0 ) self . drawn_cards . append ( card ) return card shuffle_deck () Shuffles the deck of cards. If the deck is empty, the drawn cards are shuffled and added back to the deck. Otherwise, the deck itself is shuffled. Returns None Source code in src/deck.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def shuffle_deck ( self ): \"\"\" Shuffles the deck of cards. If the deck is empty, the drawn cards are shuffled and added back to the deck. Otherwise, the deck itself is shuffled. Returns ------- None \"\"\" if not self . cards : random . shuffle ( self . drawn_cards ) self . cards = self . drawn_cards . copy () self . drawn_cards . clear () else : random . shuffle ( self . cards ) Entity Bases: Sprite Base class for game entities. This class inherits from pygame.sprite.Sprite and serves as a base class for all game entities. It provides common functionality such as loading and scaling images, as well as updating the entity's state. Attributes image : pygame.Surface The image of the entity. rect : pygame.Rect The rectangular area occupied by the entity on the screen. Methods init (self, image_path, x_y, scale_size) Initialize the Entity object. update(self) Update the entity's state. Source code in src/entity.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class Entity ( pygame . sprite . Sprite , metaclass = ABCMeta ): \"\"\" Base class for game entities. This class inherits from pygame.sprite.Sprite and serves as a base class for all game entities. It provides common functionality such as loading and scaling images, as well as updating the entity's state. Attributes ---------- image : pygame.Surface The image of the entity. rect : pygame.Rect The rectangular area occupied by the entity on the screen. Methods ------- __init__(self, image_path, x_y, scale_size) Initialize the Entity object. update(self) Update the entity's state. \"\"\" def __init__ ( self , image_path , x_y , scale_size ): \"\"\" Initialize the Entity object. Parameters ---------- image_path : str The path to the image file. x_y : tuple The x and y coordinates of the entity's top-left corner. scale_size : tuple The width and height to scale the image. Returns ------- None \"\"\" super () . __init__ () self . image = pygame . image . load ( image_path ) . convert_alpha () self . image = pygame . transform . smoothscale ( self . image , scale_size ) self . rect = self . image . get_rect ( topleft = x_y ) def update ( self ): \"\"\" Update the entity's state. Returns ------- None This method does not return anything. \"\"\" pass __init__ ( image_path , x_y , scale_size ) Initialize the Entity object. Parameters image_path : str The path to the image file. x_y : tuple The x and y coordinates of the entity's top-left corner. scale_size : tuple The width and height to scale the image. Returns None Source code in src/entity.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def __init__ ( self , image_path , x_y , scale_size ): \"\"\" Initialize the Entity object. Parameters ---------- image_path : str The path to the image file. x_y : tuple The x and y coordinates of the entity's top-left corner. scale_size : tuple The width and height to scale the image. Returns ------- None \"\"\" super () . __init__ () self . image = pygame . image . load ( image_path ) . convert_alpha () self . image = pygame . transform . smoothscale ( self . image , scale_size ) self . rect = self . image . get_rect ( topleft = x_y ) update () Update the entity's state. Returns None This method does not return anything. Source code in src/entity.py 50 51 52 53 54 55 56 57 58 59 def update ( self ): \"\"\" Update the entity's state. Returns ------- None This method does not return anything. \"\"\" pass GridGame Bases: Entity Represents the grid game. This class inherits from Entity and represents the grid game. It is responsible for handling the game's main events, such as quitting the game, pressing the escape key, and clicking the mouse button. If a click occurs, it validates the click and performs the player's movement and collision testing. Attributes image_path : str The path to the image file. x_y : tuple The x and y coordinates of the game object. scale_size : float The scale size of the game object. bot_number : int The number of bots in the game. next_menu : str The next menu to be displayed. _game_turn : int The current turn of the game. _mov_stage : int The current stage of the player's movement. _clicked : bool True if the player has clicked, False otherwise. _deck : Deck The deck of cards. _player : Player The player object. _bots : Group The group of bots. _all_riders : Group The group of all riders. Methods init (self, image_path, x_y, scale_size, bot_number) Initializes the Game object. update(self) Update the game state. draw(self, screen) Draw the game elements on the screen. choice_preview(self, screen) Preview the selected card and its path on the screen. __preview_selected_card(card, screen) Draw the outline of the selected card. __preview_selected_path(card, screen) Preview the selected path on the screen. __validate_click(self) Verifies if the player clicked on a card and prepares the player's movement. __card_clicked(self) Verifies if a card has been clicked by the player. move_player(self, rider) Move the player's rider. __end_turn(self) Reverses the game state and advances the turn. __next_player_movement(self, card=None) Perform the movement of the next player in the game. __first_turn_collision(self) Verifies if any rider has collided during the first turn. check_collision(self, rider) Check for collisions between the rider and the game elements. __kill_rider(self, rider) Kills the specified rider and advances the turn. Source code in src/game.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 class GridGame ( Entity ): \"\"\" Represents the grid game. This class inherits from Entity and represents the grid game. It is responsible for handling the game's main events, such as quitting the game, pressing the escape key, and clicking the mouse button. If a click occurs, it validates the click and performs the player's movement and collision testing. Attributes ---------- image_path : str The path to the image file. x_y : tuple The x and y coordinates of the game object. scale_size : float The scale size of the game object. bot_number : int The number of bots in the game. next_menu : str The next menu to be displayed. _game_turn : int The current turn of the game. _mov_stage : int The current stage of the player's movement. _clicked : bool True if the player has clicked, False otherwise. _deck : Deck The deck of cards. _player : Player The player object. _bots : Group The group of bots. _all_riders : Group The group of all riders. Methods ------- __init__(self, image_path, x_y, scale_size, bot_number) Initializes the Game object. update(self) Update the game state. draw(self, screen) Draw the game elements on the screen. choice_preview(self, screen) Preview the selected card and its path on the screen. __preview_selected_card(card, screen) Draw the outline of the selected card. __preview_selected_path(card, screen) Preview the selected path on the screen. __validate_click(self) Verifies if the player clicked on a card and prepares the player's movement. __card_clicked(self) Verifies if a card has been clicked by the player. move_player(self, rider) Move the player's rider. __end_turn(self) Reverses the game state and advances the turn. __next_player_movement(self, card=None) Perform the movement of the next player in the game. __first_turn_collision(self) Verifies if any rider has collided during the first turn. check_collision(self, rider) Check for collisions between the rider and the game elements. __kill_rider(self, rider) Kills the specified rider and advances the turn. \"\"\" def __init__ ( self , image_path , x_y , scale_size , bot_number ): \"\"\" Initializes the Game object. Parameters ---------- image_path : str The path to the image file. x_y : tuple The x and y coordinates of the game object. scale_size : float The scale size of the game object. bot_number : int The number of bots in the game. Returns ------- None \"\"\" super () . __init__ ( image_path , x_y , scale_size ) # Atributos para o estado do jogo self . next_menu = \"none\" self . _game_turn = 0 self . _mov_stage = - 1 self . _clicked = False # Cria o deck self . _deck = Deck ( TEXTURE_PATH + \"cards/\" , ( CARD_X , CARD_Y )) # Cria o jogador self . _player = Player ( 1 , ( GRID_X / 2 - 1 , GRID_Y / 2 - 2 ), ( RIDER_X , RIDER_Y ), self . _deck ) # Cria os bots __bot_list = [] for bot in range ( bot_number ): __bot_list . append ( Bot ( bot + 2 , ( GRID_X / 2 - 1 , GRID_Y / 2 - 2 ), ( RIDER_X , RIDER_Y ), self . _deck )) self . _bots = pygame . sprite . OrderedUpdates ( __bot_list [:: - 1 ]) # Grupo com todos personagens animados (bots e player) self . _all_riders = pygame . sprite . Group (( self . _player . sprite ()), self . _bots . sprites ()[:: - 1 ]) def update ( self ): \"\"\" Update the game state. This method handles the main events of the menu, such as quitting the game, pressing the escape key, and clicking the mouse button. If a click occurs, it validates the click and performs the player's movement and collision testing. Returns ------- bool False. \"\"\" # Eventos principais deste menu for event in pygame . event . get (): if event . type == pygame . QUIT : pygame . quit () sys . exit () if event . type == pygame . KEYDOWN : if event . key == pygame . K_ESCAPE : pygame . quit () sys . exit () if event . type == pygame . MOUSEBUTTONDOWN : if event . button == 1 and not self . _clicked and self . _player : self . __validate_click () # Se tiver clicado, roda o movimento do jogador ou dos bots e testa colis\u00e3o if self . _clicked and self . _all_riders : self . move_player ( self . _all_riders . sprites ()[ self . _mov_stage ]) self . check_collision ( self . _all_riders . sprites ()[ self . _mov_stage ]) return False def draw ( self , screen ): \"\"\" Draw the game elements on the screen. Parameters ---------- screen : pygame.Surface The surface to draw the game elements on. Returns ------- None \"\"\" # Desenha o tabuleiro no layer mais baixo screen . blit ( self . image , self . rect ) # Desenha as linhas dos riders for rider in self . _all_riders . sprites (): pygame . draw . lines ( screen , rider . _color , False , rider . _path + [ rider . rect . center ], width = 6 ) # Desenha o contorno e as cartas if self . _player : self . choice_preview ( screen ) self . _player . _hand . draw ( screen ) # Faz blit no jogador e nos bots self . _bots . draw ( screen ) self . _player . draw ( screen ) def choice_preview ( self , screen ): \"\"\" Preview the selected card and its path on the screen. Parameters ---------- screen : pygame.Surface The screen surface to draw on. Returns ------- None \"\"\" # Verifica se o mouse est\u00e1 em cima da carta for card in self . _player . _hand . sprites (): if card . update (): # Desenha o contorno self . __preview_selected_card ( card , screen ) # Se n\u00e3o houver clicado antes, mostra a trajet\u00f3ria da carta if not self . _clicked : self . __preview_selected_path ( card , screen ) @staticmethod def __preview_selected_card ( card , screen ): \"\"\" Draw the outline of the selected card. Parameters ---------- card : Card The selected card object. screen : pygame.Surface The screen surface to draw on. Returns ------- None \"\"\" # Desenha o contorno da carta selecionada rect_pos = ( card . rect . left - CARD_SELECTED_WIDTH , card . rect . top - CARD_SELECTED_WIDTH ) rect_size = ( card . rect . width + 2 * CARD_SELECTED_WIDTH , card . rect . height + 2 * CARD_SELECTED_WIDTH ) rectangle = pygame . Rect ( rect_pos , rect_size ) pygame . draw . rect ( screen , \"#258dc2\" , rectangle , width = 2 * CARD_SELECTED_WIDTH ) def __preview_selected_path ( self , card , screen ): \"\"\" Preview the selected path on the screen. Parameters ---------- card : Card The selected card. screen : pygame.Surface The screen surface to draw on. Returns ------- None \"\"\" # Pega o ponto inicial e final da reta start = pygame . Vector2 ( self . _player . _path [ - 1 ]) # Converte para Vector2 card_value = pygame . Vector2 ( card . value [ 0 ], - card . value [ 1 ]) size_segments = 12 # Defina a dist\u00e2ncia desejada entre os segmentos da linha tracejada num_segments = int ( start . distance_to ( start + card_value * DISTANCE ) / size_segments ) # Desenha a linha tracejada for i in range ( 0 , num_segments , 2 ): segment_start = start + card_value * i * DISTANCE / num_segments segment_end = start + card_value * ( i + 1 ) * DISTANCE / num_segments pygame . draw . line ( screen , self . _player . _color , segment_start , segment_end , width = 5 ) def __validate_click ( self ): \"\"\" Verifies if the player clicked on a card and prepares the player's movement. Returns ------- None \"\"\" # Verifica em qual carta clicou player_card = self . __card_clicked () # Se tiver clicado, prepara o movimento do player if player_card : self . _clicked = True self . __next_player_movement ( player_card ) def __card_clicked ( self ): \"\"\" Verifies if a card has been clicked by the player. Returns ------- Card or None: The clicked card if found, None otherwise. \"\"\" # Se o jogador clicar na carta, _clicked = True for card in self . _player . _hand . sprites (): if card . update (): return card return None def move_player ( self , rider ): \"\"\" Move the player's rider. Parameters ---------- rider : Rider The rider object to be moved. Returns ------- None Notes ----- If the rider is able to update its position on the deck, nothing happens. If the rider is unable to update its position, the next player movement is reset. \"\"\" # Move o rider if rider . update ( self . _deck ): pass # Se ficou parado, reseta o movimento else : self . __next_player_movement () def __end_turn ( self ): \"\"\" Reverses the game state and advances the turn. Returns ------- None \"\"\" # S\u00f3 reverte o estado do jogo e adiciona um turno self . _game_turn += 1 self . _clicked = False self . _mov_stage = - 1 # Quando o jogador estiver morto pula sua vez if not self . _player : self . _mov_stage += 1 self . _clicked = True def __next_player_movement ( self , card = None ): \"\"\" Perform the movement of the next player in the game. Parameters ---------- card : Card, optional The card chosen by the player. Defaults to None. Returns ------- None Notes ----- This method is responsible for advancing the game to the next player's movement. If all players have completed their movements, the turn ends. In the rare case of a collision on the first turn, a special action is triggered. If the player is not alive, the bots will play among themselves. If all players are dead, the method returns without further actions. \"\"\" self . _mov_stage += 1 # Se todos jogadores tiverem se movimentado, acaba o turno if self . _mov_stage == len ( self . _all_riders ): self . __end_turn () # No raro caso de colidirem no primeiro turno if self . _game_turn == 1 : self . __first_turn_collision () # Quando o jogador n\u00e3o estiver vivo os bots jogar\u00e3o entre si if self . _player : return # Se todos morrerem tamb\u00e9m retorna if not self . _all_riders : return # Caso contr\u00e1rio, prepara o jogo para rodar mais uma anima\u00e7\u00e3o next_player = self . _all_riders . sprites ()[ self . _mov_stage ] # Se n\u00e3o tiver passado uma carta, faz o rider escolher (em geral um bot) if not card : card = next_player . choose_card ( self . _all_riders ) # Atualiza o estado do pr\u00f3ximo jogador next_player . select_card ( card ) def __first_turn_collision ( self ): \"\"\" Verifies if any rider has collided during the first turn. This method checks if any rider has collided with the border or with other riders during the first turn of the game. If a collision is detected, the corresponding rider is removed from the game. Returns ------- None \"\"\" for rider in self . _all_riders . sprites ()[:: - 1 ]: if utilities . check_border_collision ( rider . rect . center ): rider . kill () continue if utilities . check_line_collision ( self . _all_riders , rider ) and self . _game_turn : rider . kill () continue def check_collision ( self , rider ): \"\"\" Check for collisions between the rider and the game elements. Parameters ---------- rider (Rider): The rider object to check for collisions. Returns ------- None \"\"\" # Testa colis\u00e3o com a fronteira if utilities . check_border_collision ( rider . rect . center ): self . __kill_rider ( rider ) return # Testa colis\u00e3o com as linhas if utilities . check_line_collision ( self . _all_riders , rider ) and self . _game_turn : self . __kill_rider ( rider ) return # Verifica se colidiram entre si #utilities.check_riders_collision(self._player, self._bots) def __kill_rider ( self , rider ): \"\"\" Kills the specified rider and advances the turn. Parameters ---------- rider (Rider): The rider to be killed. Returns ------- None \"\"\" # Mata o rider rider . kill () # Avan\u00e7a o turno self . _mov_stage -= 1 self . __next_player_movement () __card_clicked () Verifies if a card has been clicked by the player. Returns Card or None: The clicked card if found, None otherwise. Source code in src/game.py 278 279 280 281 282 283 284 285 286 287 288 289 290 291 def __card_clicked ( self ): \"\"\" Verifies if a card has been clicked by the player. Returns ------- Card or None: The clicked card if found, None otherwise. \"\"\" # Se o jogador clicar na carta, _clicked = True for card in self . _player . _hand . sprites (): if card . update (): return card return None __end_turn () Reverses the game state and advances the turn. Returns None Source code in src/game.py 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 def __end_turn ( self ): \"\"\" Reverses the game state and advances the turn. Returns ------- None \"\"\" # S\u00f3 reverte o estado do jogo e adiciona um turno self . _game_turn += 1 self . _clicked = False self . _mov_stage = - 1 # Quando o jogador estiver morto pula sua vez if not self . _player : self . _mov_stage += 1 self . _clicked = True __first_turn_collision () Verifies if any rider has collided during the first turn. This method checks if any rider has collided with the border or with other riders during the first turn of the game. If a collision is detected, the corresponding rider is removed from the game. Returns None Source code in src/game.py 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 def __first_turn_collision ( self ): \"\"\" Verifies if any rider has collided during the first turn. This method checks if any rider has collided with the border or with other riders during the first turn of the game. If a collision is detected, the corresponding rider is removed from the game. Returns ------- None \"\"\" for rider in self . _all_riders . sprites ()[:: - 1 ]: if utilities . check_border_collision ( rider . rect . center ): rider . kill () continue if utilities . check_line_collision ( self . _all_riders , rider ) and self . _game_turn : rider . kill () continue __init__ ( image_path , x_y , scale_size , bot_number ) Initializes the Game object. Parameters image_path : str The path to the image file. x_y : tuple The x and y coordinates of the game object. scale_size : float The scale size of the game object. bot_number : int The number of bots in the game. Returns None Source code in src/game.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 def __init__ ( self , image_path , x_y , scale_size , bot_number ): \"\"\" Initializes the Game object. Parameters ---------- image_path : str The path to the image file. x_y : tuple The x and y coordinates of the game object. scale_size : float The scale size of the game object. bot_number : int The number of bots in the game. Returns ------- None \"\"\" super () . __init__ ( image_path , x_y , scale_size ) # Atributos para o estado do jogo self . next_menu = \"none\" self . _game_turn = 0 self . _mov_stage = - 1 self . _clicked = False # Cria o deck self . _deck = Deck ( TEXTURE_PATH + \"cards/\" , ( CARD_X , CARD_Y )) # Cria o jogador self . _player = Player ( 1 , ( GRID_X / 2 - 1 , GRID_Y / 2 - 2 ), ( RIDER_X , RIDER_Y ), self . _deck ) # Cria os bots __bot_list = [] for bot in range ( bot_number ): __bot_list . append ( Bot ( bot + 2 , ( GRID_X / 2 - 1 , GRID_Y / 2 - 2 ), ( RIDER_X , RIDER_Y ), self . _deck )) self . _bots = pygame . sprite . OrderedUpdates ( __bot_list [:: - 1 ]) # Grupo com todos personagens animados (bots e player) self . _all_riders = pygame . sprite . Group (( self . _player . sprite ()), self . _bots . sprites ()[:: - 1 ]) __kill_rider ( rider ) Kills the specified rider and advances the turn. Parameters rider (Rider): The rider to be killed. Returns None Source code in src/game.py 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 def __kill_rider ( self , rider ): \"\"\" Kills the specified rider and advances the turn. Parameters ---------- rider (Rider): The rider to be killed. Returns ------- None \"\"\" # Mata o rider rider . kill () # Avan\u00e7a o turno self . _mov_stage -= 1 self . __next_player_movement () __next_player_movement ( card = None ) Perform the movement of the next player in the game. Parameters card : Card, optional The card chosen by the player. Defaults to None. Returns None Notes This method is responsible for advancing the game to the next player's movement. If all players have completed their movements, the turn ends. In the rare case of a collision on the first turn, a special action is triggered. If the player is not alive, the bots will play among themselves. If all players are dead, the method returns without further actions. Source code in src/game.py 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 def __next_player_movement ( self , card = None ): \"\"\" Perform the movement of the next player in the game. Parameters ---------- card : Card, optional The card chosen by the player. Defaults to None. Returns ------- None Notes ----- This method is responsible for advancing the game to the next player's movement. If all players have completed their movements, the turn ends. In the rare case of a collision on the first turn, a special action is triggered. If the player is not alive, the bots will play among themselves. If all players are dead, the method returns without further actions. \"\"\" self . _mov_stage += 1 # Se todos jogadores tiverem se movimentado, acaba o turno if self . _mov_stage == len ( self . _all_riders ): self . __end_turn () # No raro caso de colidirem no primeiro turno if self . _game_turn == 1 : self . __first_turn_collision () # Quando o jogador n\u00e3o estiver vivo os bots jogar\u00e3o entre si if self . _player : return # Se todos morrerem tamb\u00e9m retorna if not self . _all_riders : return # Caso contr\u00e1rio, prepara o jogo para rodar mais uma anima\u00e7\u00e3o next_player = self . _all_riders . sprites ()[ self . _mov_stage ] # Se n\u00e3o tiver passado uma carta, faz o rider escolher (em geral um bot) if not card : card = next_player . choose_card ( self . _all_riders ) # Atualiza o estado do pr\u00f3ximo jogador next_player . select_card ( card ) __preview_selected_card ( card , screen ) staticmethod Draw the outline of the selected card. Parameters card : Card The selected card object. screen : pygame.Surface The screen surface to draw on. Returns None Source code in src/game.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 @staticmethod def __preview_selected_card ( card , screen ): \"\"\" Draw the outline of the selected card. Parameters ---------- card : Card The selected card object. screen : pygame.Surface The screen surface to draw on. Returns ------- None \"\"\" # Desenha o contorno da carta selecionada rect_pos = ( card . rect . left - CARD_SELECTED_WIDTH , card . rect . top - CARD_SELECTED_WIDTH ) rect_size = ( card . rect . width + 2 * CARD_SELECTED_WIDTH , card . rect . height + 2 * CARD_SELECTED_WIDTH ) rectangle = pygame . Rect ( rect_pos , rect_size ) pygame . draw . rect ( screen , \"#258dc2\" , rectangle , width = 2 * CARD_SELECTED_WIDTH ) __preview_selected_path ( card , screen ) Preview the selected path on the screen. Parameters card : Card The selected card. screen : pygame.Surface The screen surface to draw on. Returns None Source code in src/game.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 def __preview_selected_path ( self , card , screen ): \"\"\" Preview the selected path on the screen. Parameters ---------- card : Card The selected card. screen : pygame.Surface The screen surface to draw on. Returns ------- None \"\"\" # Pega o ponto inicial e final da reta start = pygame . Vector2 ( self . _player . _path [ - 1 ]) # Converte para Vector2 card_value = pygame . Vector2 ( card . value [ 0 ], - card . value [ 1 ]) size_segments = 12 # Defina a dist\u00e2ncia desejada entre os segmentos da linha tracejada num_segments = int ( start . distance_to ( start + card_value * DISTANCE ) / size_segments ) # Desenha a linha tracejada for i in range ( 0 , num_segments , 2 ): segment_start = start + card_value * i * DISTANCE / num_segments segment_end = start + card_value * ( i + 1 ) * DISTANCE / num_segments pygame . draw . line ( screen , self . _player . _color , segment_start , segment_end , width = 5 ) __validate_click () Verifies if the player clicked on a card and prepares the player's movement. Returns None Source code in src/game.py 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 def __validate_click ( self ): \"\"\" Verifies if the player clicked on a card and prepares the player's movement. Returns ------- None \"\"\" # Verifica em qual carta clicou player_card = self . __card_clicked () # Se tiver clicado, prepara o movimento do player if player_card : self . _clicked = True self . __next_player_movement ( player_card ) check_collision ( rider ) Check for collisions between the rider and the game elements. Parameters rider (Rider): The rider object to check for collisions. Returns None Source code in src/game.py 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 def check_collision ( self , rider ): \"\"\" Check for collisions between the rider and the game elements. Parameters ---------- rider (Rider): The rider object to check for collisions. Returns ------- None \"\"\" # Testa colis\u00e3o com a fronteira if utilities . check_border_collision ( rider . rect . center ): self . __kill_rider ( rider ) return # Testa colis\u00e3o com as linhas if utilities . check_line_collision ( self . _all_riders , rider ) and self . _game_turn : self . __kill_rider ( rider ) return choice_preview ( screen ) Preview the selected card and its path on the screen. Parameters screen : pygame.Surface The screen surface to draw on. Returns None Source code in src/game.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 def choice_preview ( self , screen ): \"\"\" Preview the selected card and its path on the screen. Parameters ---------- screen : pygame.Surface The screen surface to draw on. Returns ------- None \"\"\" # Verifica se o mouse est\u00e1 em cima da carta for card in self . _player . _hand . sprites (): if card . update (): # Desenha o contorno self . __preview_selected_card ( card , screen ) # Se n\u00e3o houver clicado antes, mostra a trajet\u00f3ria da carta if not self . _clicked : self . __preview_selected_path ( card , screen ) draw ( screen ) Draw the game elements on the screen. Parameters screen : pygame.Surface The surface to draw the game elements on. Returns None Source code in src/game.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 def draw ( self , screen ): \"\"\" Draw the game elements on the screen. Parameters ---------- screen : pygame.Surface The surface to draw the game elements on. Returns ------- None \"\"\" # Desenha o tabuleiro no layer mais baixo screen . blit ( self . image , self . rect ) # Desenha as linhas dos riders for rider in self . _all_riders . sprites (): pygame . draw . lines ( screen , rider . _color , False , rider . _path + [ rider . rect . center ], width = 6 ) # Desenha o contorno e as cartas if self . _player : self . choice_preview ( screen ) self . _player . _hand . draw ( screen ) # Faz blit no jogador e nos bots self . _bots . draw ( screen ) self . _player . draw ( screen ) move_player ( rider ) Move the player's rider. Parameters rider : Rider The rider object to be moved. Returns None Notes If the rider is able to update its position on the deck, nothing happens. If the rider is unable to update its position, the next player movement is reset. Source code in src/game.py 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 def move_player ( self , rider ): \"\"\" Move the player's rider. Parameters ---------- rider : Rider The rider object to be moved. Returns ------- None Notes ----- If the rider is able to update its position on the deck, nothing happens. If the rider is unable to update its position, the next player movement is reset. \"\"\" # Move o rider if rider . update ( self . _deck ): pass # Se ficou parado, reseta o movimento else : self . __next_player_movement () update () Update the game state. This method handles the main events of the menu, such as quitting the game, pressing the escape key, and clicking the mouse button. If a click occurs, it validates the click and performs the player's movement and collision testing. Returns bool False. Source code in src/game.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def update ( self ): \"\"\" Update the game state. This method handles the main events of the menu, such as quitting the game, pressing the escape key, and clicking the mouse button. If a click occurs, it validates the click and performs the player's movement and collision testing. Returns ------- bool False. \"\"\" # Eventos principais deste menu for event in pygame . event . get (): if event . type == pygame . QUIT : pygame . quit () sys . exit () if event . type == pygame . KEYDOWN : if event . key == pygame . K_ESCAPE : pygame . quit () sys . exit () if event . type == pygame . MOUSEBUTTONDOWN : if event . button == 1 and not self . _clicked and self . _player : self . __validate_click () # Se tiver clicado, roda o movimento do jogador ou dos bots e testa colis\u00e3o if self . _clicked and self . _all_riders : self . move_player ( self . _all_riders . sprites ()[ self . _mov_stage ]) self . check_collision ( self . _all_riders . sprites ()[ self . _mov_stage ]) return False Button Bases: Entity Represents a menu button. Attributes label : str The label for the menu. rect : Rect The rectangle that represents the menu's position and size. selected : bool Indicates whether the menu is selected or not. Methods init (self, image_path, x_y, scale_size, label) Initializes a Menu object. update(self) Update the state of the menu. Source code in src/menu.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class Button ( Entity ): \"\"\" Represents a menu button. Attributes ---------- label : str The label for the menu. rect : Rect The rectangle that represents the menu's position and size. selected : bool Indicates whether the menu is selected or not. Methods ------- __init__(self, image_path, x_y, scale_size, label) Initializes a Menu object. update(self) Update the state of the menu. \"\"\" def __init__ ( self , image_path , x_y , scale_size , label ): \"\"\" Initializes a Menu object. Parameters ---------- image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu. label : str The label for the menu. Returns ------- None \"\"\" super () . __init__ ( image_path , x_y , scale_size ) self . label = label self . rect = self . image . get_rect ( center = x_y ) self . selected = False def update ( self ): \"\"\" Update the state of the menu. Check for collision with the mouse and return True if there is a collision, otherwise return False. Returns ------- bool True if there is a collision with the mouse, False otherwise. \"\"\" mouse_pos = pygame . mouse . get_pos () is_over = self . rect . collidepoint ( mouse_pos ) if is_over : return True else : return False __init__ ( image_path , x_y , scale_size , label ) Initializes a Menu object. Parameters image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu. label : str The label for the menu. Returns None Source code in src/menu.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def __init__ ( self , image_path , x_y , scale_size , label ): \"\"\" Initializes a Menu object. Parameters ---------- image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu. label : str The label for the menu. Returns ------- None \"\"\" super () . __init__ ( image_path , x_y , scale_size ) self . label = label self . rect = self . image . get_rect ( center = x_y ) self . selected = False update () Update the state of the menu. Check for collision with the mouse and return True if there is a collision, otherwise return False. Returns bool True if there is a collision with the mouse, False otherwise. Source code in src/menu.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def update ( self ): \"\"\" Update the state of the menu. Check for collision with the mouse and return True if there is a collision, otherwise return False. Returns ------- bool True if there is a collision with the mouse, False otherwise. \"\"\" mouse_pos = pygame . mouse . get_pos () is_over = self . rect . collidepoint ( mouse_pos ) if is_over : return True else : return False CreditsMenu Bases: Menu Represents the credits menu. Attributes next_state : str The next state to transition to. font_size : list The font sizes for the menu. space_size : list The space sizes for the menu. txt_x : int The x coordinate of the text. txt_y : int The y coordinate of the text. background_image : Surface The background image for the menu. btn_back : Button The button to transition to the main menu. buttons_group : Group The group of buttons for the menu. Methods init (self, game, image_path, x_y, scale_size) Initializes a CreditsMenu object. display_menu(self) Display the credits menu. check_input(self) Check the input for the menu. Source code in src/menu.py 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 class CreditsMenu ( Menu ): \"\"\" Represents the credits menu. Attributes ---------- next_state : str The next state to transition to. font_size : list The font sizes for the menu. space_size : list The space sizes for the menu. txt_x : int The x coordinate of the text. txt_y : int The y coordinate of the text. background_image : Surface The background image for the menu. btn_back : Button The button to transition to the main menu. buttons_group : Group The group of buttons for the menu. Methods ------- __init__(self, game, image_path, x_y, scale_size) Initializes a CreditsMenu object. display_menu(self) Display the credits menu. check_input(self) Check the input for the menu. \"\"\" def __init__ ( self , game , image_path , x_y , scale_size ): \"\"\" Initializes a CreditsMenu object. Parameters ---------- game : Game The game object that controls the menu. image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu. Returns ------- None \"\"\" super () . __init__ ( game , image_path , x_y , scale_size ) self . next_state = \"main_menu\" # Define vari\u00e1veis com valores recorrentes no menu self . font_size = [ 25 , 30 , 40 ] self . space_size = [ 40 , 27 ] self . txt_x = WIDTH / 2 self . txt_y = HEIGHT / 4 + self . space_size [ 1 ] # Carrega a imagem da tela de fundo self . background_image = pygame . image . load ( TEXTURE_PATH + \"background_credits.png\" ) . convert () # Define os bot\u00f5es dessa tela self . btn_back = Button ( TEXTURE_PATH + \"back_button.png\" , ( WIDTH / 2 , ( HEIGHT - 100 )), ( BUTTON_X , BUTTON_Y ), \"main_menu\" ) # Adiciona os bot\u00f5es a um grupo self . buttons_group . add ( self . btn_back ) def display_menu ( self ): \"\"\" Display the credits menu. Returns ------- None \"\"\" self . run_display = True while self . run_display : # Exibe o plano de fundo da tela self . state_control . screen . blit ( self . background_image , ( 0 , 0 )) #Verifica as entradas e intera\u00e7\u00e3o com os bot\u00f5es self . verify () # Exibe a imagem \"credits\" self . state_control . screen . blit ( self . image , self . rect ) # Insere os bot\u00f5es na tela: self . buttons_group . draw ( self . state_control . screen ) # Desenha os textos na tela self . draw_text ( \"A2 - LP - 2023\" , self . font_size [ 2 ], self . txt_x , self . txt_y ) self . draw_text ( \"- Code by:\" , self . font_size [ 1 ], self . txt_x , ( self . txt_y + 2 * self . space_size [ 0 ])) self . draw_text ( \"Beatriz Miranda Bezerra\" , self . font_size [ 0 ], self . txt_x , ( self . txt_y + 3 * self . space_size [ 0 ])) self . draw_text ( \"Gustavo Murilo Cavalcante Carvalho\" , self . font_size [ 0 ], self . txt_x , ( self . txt_y + 4 * self . space_size [ 0 ])) self . draw_text ( \"Henzo Felipe Carvalho de Mattos\" , self . font_size [ 0 ], self . txt_x , ( self . txt_y + 5 * self . space_size [ 0 ])) self . draw_text ( \"- Art and Concept granted by:\" , self . font_size [ 1 ], self . txt_x , ( self . txt_y + 7 * self . space_size [ 0 ])) self . draw_text ( \"Tulio Kone\u00e7ny\" , self . font_size [ 0 ], self . txt_x , ( self . txt_y + 8 * self . space_size [ 0 ])) self . update () def check_input ( self ): \"\"\" Check the input for the menu. Returns ------- None \"\"\" if self . state_control . ESC_KEY : self . state_control . curr_menu = self . state_control . main_menu self . run_display = False if self . state_control . BACK_KEY : self . state_control . curr_menu = self . state_control . main_menu self . run_display = False if self . state_control . START_KEY or self . state_control . BUTTON_CLICKED : if self . next_state == \"main_menu\" : self . state_control . curr_menu = self . state_control . main_menu self . run_display = False __init__ ( game , image_path , x_y , scale_size ) Initializes a CreditsMenu object. Parameters game : Game The game object that controls the menu. image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu. Returns None Source code in src/menu.py 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 def __init__ ( self , game , image_path , x_y , scale_size ): \"\"\" Initializes a CreditsMenu object. Parameters ---------- game : Game The game object that controls the menu. image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu. Returns ------- None \"\"\" super () . __init__ ( game , image_path , x_y , scale_size ) self . next_state = \"main_menu\" # Define vari\u00e1veis com valores recorrentes no menu self . font_size = [ 25 , 30 , 40 ] self . space_size = [ 40 , 27 ] self . txt_x = WIDTH / 2 self . txt_y = HEIGHT / 4 + self . space_size [ 1 ] # Carrega a imagem da tela de fundo self . background_image = pygame . image . load ( TEXTURE_PATH + \"background_credits.png\" ) . convert () # Define os bot\u00f5es dessa tela self . btn_back = Button ( TEXTURE_PATH + \"back_button.png\" , ( WIDTH / 2 , ( HEIGHT - 100 )), ( BUTTON_X , BUTTON_Y ), \"main_menu\" ) # Adiciona os bot\u00f5es a um grupo self . buttons_group . add ( self . btn_back ) check_input () Check the input for the menu. Returns None Source code in src/menu.py 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 def check_input ( self ): \"\"\" Check the input for the menu. Returns ------- None \"\"\" if self . state_control . ESC_KEY : self . state_control . curr_menu = self . state_control . main_menu self . run_display = False if self . state_control . BACK_KEY : self . state_control . curr_menu = self . state_control . main_menu self . run_display = False if self . state_control . START_KEY or self . state_control . BUTTON_CLICKED : if self . next_state == \"main_menu\" : self . state_control . curr_menu = self . state_control . main_menu self . run_display = False display_menu () Display the credits menu. Returns None Source code in src/menu.py 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 def display_menu ( self ): \"\"\" Display the credits menu. Returns ------- None \"\"\" self . run_display = True while self . run_display : # Exibe o plano de fundo da tela self . state_control . screen . blit ( self . background_image , ( 0 , 0 )) #Verifica as entradas e intera\u00e7\u00e3o com os bot\u00f5es self . verify () # Exibe a imagem \"credits\" self . state_control . screen . blit ( self . image , self . rect ) # Insere os bot\u00f5es na tela: self . buttons_group . draw ( self . state_control . screen ) # Desenha os textos na tela self . draw_text ( \"A2 - LP - 2023\" , self . font_size [ 2 ], self . txt_x , self . txt_y ) self . draw_text ( \"- Code by:\" , self . font_size [ 1 ], self . txt_x , ( self . txt_y + 2 * self . space_size [ 0 ])) self . draw_text ( \"Beatriz Miranda Bezerra\" , self . font_size [ 0 ], self . txt_x , ( self . txt_y + 3 * self . space_size [ 0 ])) self . draw_text ( \"Gustavo Murilo Cavalcante Carvalho\" , self . font_size [ 0 ], self . txt_x , ( self . txt_y + 4 * self . space_size [ 0 ])) self . draw_text ( \"Henzo Felipe Carvalho de Mattos\" , self . font_size [ 0 ], self . txt_x , ( self . txt_y + 5 * self . space_size [ 0 ])) self . draw_text ( \"- Art and Concept granted by:\" , self . font_size [ 1 ], self . txt_x , ( self . txt_y + 7 * self . space_size [ 0 ])) self . draw_text ( \"Tulio Kone\u00e7ny\" , self . font_size [ 0 ], self . txt_x , ( self . txt_y + 8 * self . space_size [ 0 ])) self . update () MainMenu Bases: Menu Represents the main menu. Attributes next_state : str The next state to transition to. start_x : int The x coordinate of the start button. start_y : int The y coordinate of the start button. options_x : int The x coordinate of the options button. options_y : int The y coordinate of the options button. credits_x : int The x coordinate of the credits button. credits_y : int The y coordinate of the credits button. btn_the_grid : Button The button to transition to the grid. btn_options : Button The button to transition to the options menu. btn_credits : Button The button to transition to the credits menu. buttons_group : Group The group of buttons for the menu. Methods init (self, game, image_path, x_y, scale_size) Initializes a MainMenu object. display_menu(self) Display the main menu. check_input(self) Check the input for the menu. Source code in src/menu.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 class MainMenu ( Menu ): \"\"\" Represents the main menu. Attributes ---------- next_state : str The next state to transition to. start_x : int The x coordinate of the start button. start_y : int The y coordinate of the start button. options_x : int The x coordinate of the options button. options_y : int The y coordinate of the options button. credits_x : int The x coordinate of the credits button. credits_y : int The y coordinate of the credits button. btn_the_grid : Button The button to transition to the grid. btn_options : Button The button to transition to the options menu. btn_credits : Button The button to transition to the credits menu. buttons_group : Group The group of buttons for the menu. Methods ------- __init__(self, game, image_path, x_y, scale_size) Initializes a MainMenu object. display_menu(self) Display the main menu. check_input(self) Check the input for the menu. \"\"\" def __init__ ( self , game , image_path , x_y , scale_size ): \"\"\" Initializes a MainMenu object. Parameters ---------- game : Game The game object that controls the menu. image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu. Returns ------- None \"\"\" super () . __init__ ( game , image_path , x_y , scale_size ) self . next_state = \"the_grid\" # Posi\u00e7\u00f5es para os elementos na tela self . start_x , self . start_y = ( WIDTH / 2 ), ( HEIGHT / 2 ) self . options_x , self . options_y = ( WIDTH / 2 ), ( HEIGHT / 2 + 100 ) self . credits_x , self . credits_y = ( WIDTH / 2 ), ( HEIGHT / 2 + 200 ) # Define os bot\u00f5es dessa tela self . btn_the_grid = Button ( TEXTURE_PATH + \"grid_logo.png\" , ( self . start_x , self . start_y ), ( BUTTON_X , BUTTON_Y ), \"the_grid\" ) self . btn_options = Button ( TEXTURE_PATH + \"options_button.png\" , ( self . options_x , self . options_y ), ( BUTTON_X , BUTTON_Y ), \"options_menu\" ) self . btn_credits = Button ( TEXTURE_PATH + \"credits_button.png\" , ( self . credits_x , self . credits_y ), ( BUTTON_X , BUTTON_Y ), \"credits_menu\" ) # Adiciona os bot\u00f5es a um grupo self . buttons_group = pygame . sprite . Group ( self . btn_the_grid , self . btn_options , self . btn_credits ) def display_menu ( self ): \"\"\" Display the main menu. Returns ------- None \"\"\" self . run_display = True while self . run_display : # Preenche o fundo self . state_control . screen . fill ( BLACK ) #Verifica as entradas e intera\u00e7\u00e3o com os bot\u00f5es self . verify () # Exibie o logo do jogo self . state_control . screen . blit ( self . image , self . rect ) # Insere os bot\u00f5es na tela: self . buttons_group . draw ( self . state_control . screen ) self . update () def check_input ( self ): \"\"\" Check the input for the menu. Returns ------- None \"\"\" if self . state_control . ESC_KEY : self . state_control . running = False self . state_control . curr_menu . run_display = False # Checa os cliques em bot\u00f5es if self . state_control . START_KEY or self . state_control . BUTTON_CLICKED : if self . next_state == \"the_grid\" : self . state_control . playing = True elif self . next_state == \"options_menu\" : self . state_control . curr_menu = self . state_control . options_menu elif self . next_state == \"credits_menu\" : self . state_control . curr_menu = self . state_control . credits_menu self . run_display = False __init__ ( game , image_path , x_y , scale_size ) Initializes a MainMenu object. Parameters game : Game The game object that controls the menu. image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu. Returns None Source code in src/menu.py 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 def __init__ ( self , game , image_path , x_y , scale_size ): \"\"\" Initializes a MainMenu object. Parameters ---------- game : Game The game object that controls the menu. image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu. Returns ------- None \"\"\" super () . __init__ ( game , image_path , x_y , scale_size ) self . next_state = \"the_grid\" # Posi\u00e7\u00f5es para os elementos na tela self . start_x , self . start_y = ( WIDTH / 2 ), ( HEIGHT / 2 ) self . options_x , self . options_y = ( WIDTH / 2 ), ( HEIGHT / 2 + 100 ) self . credits_x , self . credits_y = ( WIDTH / 2 ), ( HEIGHT / 2 + 200 ) # Define os bot\u00f5es dessa tela self . btn_the_grid = Button ( TEXTURE_PATH + \"grid_logo.png\" , ( self . start_x , self . start_y ), ( BUTTON_X , BUTTON_Y ), \"the_grid\" ) self . btn_options = Button ( TEXTURE_PATH + \"options_button.png\" , ( self . options_x , self . options_y ), ( BUTTON_X , BUTTON_Y ), \"options_menu\" ) self . btn_credits = Button ( TEXTURE_PATH + \"credits_button.png\" , ( self . credits_x , self . credits_y ), ( BUTTON_X , BUTTON_Y ), \"credits_menu\" ) # Adiciona os bot\u00f5es a um grupo self . buttons_group = pygame . sprite . Group ( self . btn_the_grid , self . btn_options , self . btn_credits ) check_input () Check the input for the menu. Returns None Source code in src/menu.py 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 def check_input ( self ): \"\"\" Check the input for the menu. Returns ------- None \"\"\" if self . state_control . ESC_KEY : self . state_control . running = False self . state_control . curr_menu . run_display = False # Checa os cliques em bot\u00f5es if self . state_control . START_KEY or self . state_control . BUTTON_CLICKED : if self . next_state == \"the_grid\" : self . state_control . playing = True elif self . next_state == \"options_menu\" : self . state_control . curr_menu = self . state_control . options_menu elif self . next_state == \"credits_menu\" : self . state_control . curr_menu = self . state_control . credits_menu self . run_display = False display_menu () Display the main menu. Returns None Source code in src/menu.py 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 def display_menu ( self ): \"\"\" Display the main menu. Returns ------- None \"\"\" self . run_display = True while self . run_display : # Preenche o fundo self . state_control . screen . fill ( BLACK ) #Verifica as entradas e intera\u00e7\u00e3o com os bot\u00f5es self . verify () # Exibie o logo do jogo self . state_control . screen . blit ( self . image , self . rect ) # Insere os bot\u00f5es na tela: self . buttons_group . draw ( self . state_control . screen ) self . update () Menu Bases: Entity Represents a menu. Attributes state_control : Game The game object that controls the menu. rect : Rect The rectangle that represents the menu's position and size. run_display : bool Indicates whether the menu is running or not. button_clicked : bool Indicates whether a button was clicked or not. selected_button : Button The button that was selected. buttons_group : Group The group of buttons for the menu. Methods init (self, game, image_path, x_y, scale_size) Initializes a Menu object. draw_text(self, text, size, x, y) Draw text on the screen. update(self) Update the state of the menu. verify(self) Verify the state of the menu. choice_preview(self, screen) Preview the selected choice. __preview_selected_button(self, button, screen) Preview the selected button. check_input(self) Check the input for the menu. Source code in src/menu.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 class Menu ( Entity ): \"\"\" Represents a menu. Attributes ---------- state_control : Game The game object that controls the menu. rect : Rect The rectangle that represents the menu's position and size. run_display : bool Indicates whether the menu is running or not. button_clicked : bool Indicates whether a button was clicked or not. selected_button : Button The button that was selected. buttons_group : Group The group of buttons for the menu. Methods ------- __init__(self, game, image_path, x_y, scale_size) Initializes a Menu object. draw_text(self, text, size, x, y) Draw text on the screen. update(self) Update the state of the menu. verify(self) Verify the state of the menu. choice_preview(self, screen) Preview the selected choice. __preview_selected_button(self, button, screen) Preview the selected button. check_input(self) Check the input for the menu. \"\"\" def __init__ ( self , game , image_path , x_y , scale_size ): \"\"\" Initializes a Menu object. Parameters ---------- game : Game The game object that controls the menu. image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu. Returns ------- None \"\"\" super () . __init__ ( image_path , x_y , scale_size ) self . state_control = game self . rect = self . image . get_rect ( center = x_y ) # Define vari\u00e1veis de controle self . run_display = True self . button_clicked = False self . selected_button = None # Cria um grupo para os sprites self . buttons_group = pygame . sprite . Group () def draw_text ( self , text , size , x , y ): \"\"\" Draw text on the screen. Parameters ---------- text : str The text to draw. size : int The size of the text. x : int The x coordinate of the text. y : int The y coordinate of the text. Returns ------- None \"\"\" self . font_name = pygame . font . get_default_font () font = pygame . font . Font ( self . font_name , size ) text_surface = font . render ( text , True , WHITE ) text_rect = text_surface . get_rect () text_rect . center = ( x , y ) self . state_control . screen . blit ( text_surface , text_rect ) def update ( self ): \"\"\" Update the state of the menu. Returns ------- None \"\"\" pygame . display . update () self . state_control . reset_keys () def verify ( self ): \"\"\" Verify the state of the menu. Returns ------- None \"\"\" self . state_control . check_events () self . choice_preview ( self . state_control . screen ) self . check_input () def choice_preview ( self , screen ): \"\"\" Preview the selected choice. Parameters ---------- screen : Surface The screen to preview the selected choice. Returns ------- None \"\"\" # Verifica se o mouse est\u00e1 em cima da carta for button in self . buttons_group : if button . update (): # Seleciona a tela equivalente ao bot\u00e3o self . next_state = button . label # Desenha o contorno self . __preview_selected_button ( button , screen ) # Verifica se o bot\u00e3o esquerdo do mouse \u00e9 pressionado mouse_clicked = pygame . mouse . get_pressed ()[ 0 ] if mouse_clicked or self . state_control . START_KEY : self . state_control . BUTTON_CLICKED = True # Delay para evitar cliques indesejados pygame . time . delay ( 170 ) return None @staticmethod def __preview_selected_button ( button , screen ): \"\"\" Preview the selected button. Parameters ---------- button : Button The button to preview. screen : Surface The screen to preview the button. Returns ------- None \"\"\" # Desenha o contorno do bot\u00e3o selecionado rect_pos = ( button . rect . left - BUTTON_SELECTED_WIDTH , button . rect . top - BUTTON_SELECTED_WIDTH ) rect_size = ( button . rect . width + 2 * BUTTON_SELECTED_WIDTH , button . rect . height + 2 * BUTTON_SELECTED_WIDTH ) rectangle = pygame . Rect ( rect_pos , rect_size ) pygame . draw . rect ( screen , RED , rectangle , width = 2 * BUTTON_SELECTED_WIDTH ) def check_input ( self ): \"\"\" Check the input for the menu. Returns ------- None \"\"\" pass __init__ ( game , image_path , x_y , scale_size ) Initializes a Menu object. Parameters game : Game The game object that controls the menu. image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu. Returns None Source code in src/menu.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 def __init__ ( self , game , image_path , x_y , scale_size ): \"\"\" Initializes a Menu object. Parameters ---------- game : Game The game object that controls the menu. image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu. Returns ------- None \"\"\" super () . __init__ ( image_path , x_y , scale_size ) self . state_control = game self . rect = self . image . get_rect ( center = x_y ) # Define vari\u00e1veis de controle self . run_display = True self . button_clicked = False self . selected_button = None # Cria um grupo para os sprites self . buttons_group = pygame . sprite . Group () __preview_selected_button ( button , screen ) staticmethod Preview the selected button. Parameters button : Button The button to preview. screen : Surface The screen to preview the button. Returns None Source code in src/menu.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 @staticmethod def __preview_selected_button ( button , screen ): \"\"\" Preview the selected button. Parameters ---------- button : Button The button to preview. screen : Surface The screen to preview the button. Returns ------- None \"\"\" # Desenha o contorno do bot\u00e3o selecionado rect_pos = ( button . rect . left - BUTTON_SELECTED_WIDTH , button . rect . top - BUTTON_SELECTED_WIDTH ) rect_size = ( button . rect . width + 2 * BUTTON_SELECTED_WIDTH , button . rect . height + 2 * BUTTON_SELECTED_WIDTH ) rectangle = pygame . Rect ( rect_pos , rect_size ) pygame . draw . rect ( screen , RED , rectangle , width = 2 * BUTTON_SELECTED_WIDTH ) check_input () Check the input for the menu. Returns None Source code in src/menu.py 242 243 244 245 246 247 248 249 250 def check_input ( self ): \"\"\" Check the input for the menu. Returns ------- None \"\"\" pass choice_preview ( screen ) Preview the selected choice. Parameters screen : Surface The screen to preview the selected choice. Returns None Source code in src/menu.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 def choice_preview ( self , screen ): \"\"\" Preview the selected choice. Parameters ---------- screen : Surface The screen to preview the selected choice. Returns ------- None \"\"\" # Verifica se o mouse est\u00e1 em cima da carta for button in self . buttons_group : if button . update (): # Seleciona a tela equivalente ao bot\u00e3o self . next_state = button . label # Desenha o contorno self . __preview_selected_button ( button , screen ) # Verifica se o bot\u00e3o esquerdo do mouse \u00e9 pressionado mouse_clicked = pygame . mouse . get_pressed ()[ 0 ] if mouse_clicked or self . state_control . START_KEY : self . state_control . BUTTON_CLICKED = True # Delay para evitar cliques indesejados pygame . time . delay ( 170 ) return None draw_text ( text , size , x , y ) Draw text on the screen. Parameters text : str The text to draw. size : int The size of the text. x : int The x coordinate of the text. y : int The y coordinate of the text. Returns None Source code in src/menu.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 def draw_text ( self , text , size , x , y ): \"\"\" Draw text on the screen. Parameters ---------- text : str The text to draw. size : int The size of the text. x : int The x coordinate of the text. y : int The y coordinate of the text. Returns ------- None \"\"\" self . font_name = pygame . font . get_default_font () font = pygame . font . Font ( self . font_name , size ) text_surface = font . render ( text , True , WHITE ) text_rect = text_surface . get_rect () text_rect . center = ( x , y ) self . state_control . screen . blit ( text_surface , text_rect ) update () Update the state of the menu. Returns None Source code in src/menu.py 164 165 166 167 168 169 170 171 172 173 def update ( self ): \"\"\" Update the state of the menu. Returns ------- None \"\"\" pygame . display . update () self . state_control . reset_keys () verify () Verify the state of the menu. Returns None Source code in src/menu.py 175 176 177 178 179 180 181 182 183 184 185 def verify ( self ): \"\"\" Verify the state of the menu. Returns ------- None \"\"\" self . state_control . check_events () self . choice_preview ( self . state_control . screen ) self . check_input () OptionsMenu Bases: Menu Represents the options menu. Attributes next_state : str The next state to transition to. btn_back : Button The button to transition to the main menu. buttons_group : Group The group of buttons for the menu. Methods init (self, game, image_path, x_y, scale_size) Initializes a OptionsMenu object. display_menu(self) Display the options menu. check_input(self) Check the input for the menu. Source code in src/menu.py 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 class OptionsMenu ( Menu ): \"\"\" Represents the options menu. Attributes ---------- next_state : str The next state to transition to. btn_back : Button The button to transition to the main menu. buttons_group : Group The group of buttons for the menu. Methods ------- __init__(self, game, image_path, x_y, scale_size) Initializes a OptionsMenu object. display_menu(self) Display the options menu. check_input(self) Check the input for the menu. \"\"\" def __init__ ( self , game , image_path , x_y , scale_size ): \"\"\" Initializes a OptionsMenu object. Parameters ---------- game : Game The game object that controls the menu. image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu. Returns ------- None \"\"\" super () . __init__ ( game , image_path , x_y , scale_size ) self . next_state = \"main_menu\" # Define os bot\u00f5es dessa tela self . btn_back = Button ( TEXTURE_PATH + \"back_button.png\" , ( WIDTH / 2 , ( HEIGHT - 100 )), ( BUTTON_X , BUTTON_Y ), \"main_menu\" ) # Adiciona os bot\u00f5es a um grupo self . buttons_group . add ( self . btn_back ) def display_menu ( self ): \"\"\" Display the options menu. Returns ------- None \"\"\" self . run_display = True while self . run_display : self . state_control . screen . fill ( BLACK ) # Verifica as entradas e intera\u00e7\u00e3o com os bot\u00f5es self . verify () # Exibe a imagem \"Options\" self . state_control . screen . blit ( self . image , self . rect ) # Insere os bot\u00f5es na tela: self . buttons_group . draw ( self . state_control . screen ) self . update () def check_input ( self ): \"\"\" Check the input for the menu. Returns ------- None \"\"\" if self . state_control . ESC_KEY : self . state_control . curr_menu = self . state_control . main_menu self . run_display = False if self . state_control . BACK_KEY : self . state_control . curr_menu = self . state_control . main_menu self . run_display = False if self . state_control . START_KEY or self . state_control . BUTTON_CLICKED : if self . next_state == \"main_menu\" : self . state_control . curr_menu = self . state_control . main_menu self . run_display = False __init__ ( game , image_path , x_y , scale_size ) Initializes a OptionsMenu object. Parameters game : Game The game object that controls the menu. image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu. Returns None Source code in src/menu.py 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 def __init__ ( self , game , image_path , x_y , scale_size ): \"\"\" Initializes a OptionsMenu object. Parameters ---------- game : Game The game object that controls the menu. image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu. Returns ------- None \"\"\" super () . __init__ ( game , image_path , x_y , scale_size ) self . next_state = \"main_menu\" # Define os bot\u00f5es dessa tela self . btn_back = Button ( TEXTURE_PATH + \"back_button.png\" , ( WIDTH / 2 , ( HEIGHT - 100 )), ( BUTTON_X , BUTTON_Y ), \"main_menu\" ) # Adiciona os bot\u00f5es a um grupo self . buttons_group . add ( self . btn_back ) check_input () Check the input for the menu. Returns None Source code in src/menu.py 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 def check_input ( self ): \"\"\" Check the input for the menu. Returns ------- None \"\"\" if self . state_control . ESC_KEY : self . state_control . curr_menu = self . state_control . main_menu self . run_display = False if self . state_control . BACK_KEY : self . state_control . curr_menu = self . state_control . main_menu self . run_display = False if self . state_control . START_KEY or self . state_control . BUTTON_CLICKED : if self . next_state == \"main_menu\" : self . state_control . curr_menu = self . state_control . main_menu self . run_display = False display_menu () Display the options menu. Returns None Source code in src/menu.py 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 def display_menu ( self ): \"\"\" Display the options menu. Returns ------- None \"\"\" self . run_display = True while self . run_display : self . state_control . screen . fill ( BLACK ) # Verifica as entradas e intera\u00e7\u00e3o com os bot\u00f5es self . verify () # Exibe a imagem \"Options\" self . state_control . screen . blit ( self . image , self . rect ) # Insere os bot\u00f5es na tela: self . buttons_group . draw ( self . state_control . screen ) self . update () ResultScreen Bases: Menu Represents the result screen. Attributes next_state : str The next state to transition to. Methods init (self, game, image_path, x_y, scale_size) Initializes a ResultScreen object. display_menu(self) Display the result screen. check_input(self) Check the input for the menu. Source code in src/menu.py 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 class ResultScreen ( Menu ): \"\"\" Represents the result screen. Attributes ---------- next_state : str The next state to transition to. Methods ------- __init__(self, game, image_path, x_y, scale_size) Initializes a ResultScreen object. display_menu(self) Display the result screen. check_input(self) Check the input for the menu. \"\"\" def __init__ ( self , game , image_path , x_y , scale_size ): \"\"\" Initializes a ResultScreen object. Parameters ---------- game : Game The game object that controls the menu. image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu. Returns ------- None \"\"\" super () . __init__ ( game , image_path , x_y , scale_size ) self . next_state = \"main_menu\" def display_menu ( self ): \"\"\" Display the result screen. Returns ------- None \"\"\" self . run_display = True while self . run_display : self . state_control . screen . fill ( BLACK ) # Verifica as entradas e intera\u00e7\u00e3o com os bot\u00f5es self . verify () # CODE TO FINISH --> # Exibe a imagem \"You Died\" ou \"You Win\" self . state_control . screen . blit ( self . image , self . rect ) # <-- CODE TO FINISH # Insere os bot\u00f5es na tela: self . buttons_group . draw ( self . state_control . screen ) self . update () def check_input ( self ): \"\"\" Check the input for the menu. Returns ------- None \"\"\" if self . state_control . ESC_KEY : self . state_control . curr_menu = self . state_control . main_menu self . run_display = False if self . state_control . BACK_KEY : self . state_control . curr_menu = self . state_control . main_menu self . run_display = False if self . state_control . START_KEY or self . state_control . BUTTON_CLICKED : if self . next_state == \"main_menu\" : self . state_control . curr_menu = self . state_control . main_menu self . run_display = False __init__ ( game , image_path , x_y , scale_size ) Initializes a ResultScreen object. Parameters game : Game The game object that controls the menu. image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu. Returns None Source code in src/menu.py 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 def __init__ ( self , game , image_path , x_y , scale_size ): \"\"\" Initializes a ResultScreen object. Parameters ---------- game : Game The game object that controls the menu. image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu. Returns ------- None \"\"\" super () . __init__ ( game , image_path , x_y , scale_size ) self . next_state = \"main_menu\" check_input () Check the input for the menu. Returns None Source code in src/menu.py 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 def check_input ( self ): \"\"\" Check the input for the menu. Returns ------- None \"\"\" if self . state_control . ESC_KEY : self . state_control . curr_menu = self . state_control . main_menu self . run_display = False if self . state_control . BACK_KEY : self . state_control . curr_menu = self . state_control . main_menu self . run_display = False if self . state_control . START_KEY or self . state_control . BUTTON_CLICKED : if self . next_state == \"main_menu\" : self . state_control . curr_menu = self . state_control . main_menu self . run_display = False display_menu () Display the result screen. Returns None Source code in src/menu.py 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 def display_menu ( self ): \"\"\" Display the result screen. Returns ------- None \"\"\" self . run_display = True while self . run_display : self . state_control . screen . fill ( BLACK ) # Verifica as entradas e intera\u00e7\u00e3o com os bot\u00f5es self . verify () # CODE TO FINISH --> # Exibe a imagem \"You Died\" ou \"You Win\" self . state_control . screen . blit ( self . image , self . rect ) # <-- CODE TO FINISH # Insere os bot\u00f5es na tela: self . buttons_group . draw ( self . state_control . screen ) self . update () TutorialScreen Bases: Menu Represents the tutorial screen. Attributes next_state : str The next state to transition to. Methods init (self, game, image_path, x_y, scale_size) Initializes a TutorialScreen object. display_menu(self) Display the tutorial screen. check_input(self) Check the input for the menu. Source code in src/menu.py 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 class TutorialScreen ( Menu ): \"\"\" Represents the tutorial screen. Attributes ---------- next_state : str The next state to transition to. Methods ------- __init__(self, game, image_path, x_y, scale_size) Initializes a TutorialScreen object. display_menu(self) Display the tutorial screen. check_input(self) Check the input for the menu. \"\"\" def __init__ ( self , game , image_path , x_y , scale_size ): \"\"\" Initializes a TutorialScreen object. Parameters ---------- game : Game The game object that controls the menu. image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu. Returns ------- None \"\"\" super () . __init__ ( game , image_path , x_y , scale_size ) self . next_state = \"\" def display_menu ( self ): \"\"\" Display the tutorial screen. Returns ------- None \"\"\" self . run_display = True while self . run_display : self . state_control . screen . fill ( BLACK ) # Verifica as entradas e intera\u00e7\u00e3o com os bot\u00f5es self . verify () # CODE TO FINISH --> # <-- CODE TO FINISH self . update () def check_input ( self ): \"\"\" Check the input for the menu. Returns ------- None \"\"\" pass __init__ ( game , image_path , x_y , scale_size ) Initializes a TutorialScreen object. Parameters game : Game The game object that controls the menu. image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu. Returns None Source code in src/menu.py 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 def __init__ ( self , game , image_path , x_y , scale_size ): \"\"\" Initializes a TutorialScreen object. Parameters ---------- game : Game The game object that controls the menu. image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu. Returns ------- None \"\"\" super () . __init__ ( game , image_path , x_y , scale_size ) self . next_state = \"\" check_input () Check the input for the menu. Returns None Source code in src/menu.py 739 740 741 742 743 744 745 746 747 def check_input ( self ): \"\"\" Check the input for the menu. Returns ------- None \"\"\" pass display_menu () Display the tutorial screen. Returns None Source code in src/menu.py 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 def display_menu ( self ): \"\"\" Display the tutorial screen. Returns ------- None \"\"\" self . run_display = True while self . run_display : self . state_control . screen . fill ( BLACK ) # Verifica as entradas e intera\u00e7\u00e3o com os bot\u00f5es self . verify () # CODE TO FINISH --> # <-- CODE TO FINISH self . update () Bot Bases: Rider Represents a bot object. Attributes _number : int The number of the player. _path : list A list of the rider's positions. _velocity : float The velocity of the rider. _hand : pygame.sprite.Group The rider's hand. _color : str The color of the rider. __timer : int The timer of the rider. state_alive : bool The state of the rider. clicked_card : tuple The card that the rider clicked. _last_card : tuple The last card that the rider clicked. mask : pygame.rect.Rect The mask of the rider. line_mask : pygame.mask.Mask The line mask of the rider. _last_line_mask : pygame.mask.Mask The last line mask of the rider. Methods update(self, deck) Update the rider's state based on the given deck. move_rider(self, deck) Move the rider according to the card it clicked. __change_move(self, card, time) Move the rider's position based on the given card and time. __set_temp_variables(self) Set temporary variables that save code in movement. __reset_movement(self, deck) Resets the movement of the rider. _get_line_mask(color,start, end) Create a line mask based on the given color, start, and end points. select_card(self, card) Select a card for the rider. Source code in src/rider.py 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 class Bot ( Rider ): \"\"\" Represents a bot object. Attributes ---------- _number : int The number of the player. _path : list A list of the rider's positions. _velocity : float The velocity of the rider. _hand : pygame.sprite.Group The rider's hand. _color : str The color of the rider. __timer : int The timer of the rider. state_alive : bool The state of the rider. clicked_card : tuple The card that the rider clicked. _last_card : tuple The last card that the rider clicked. mask : pygame.rect.Rect The mask of the rider. line_mask : pygame.mask.Mask The line mask of the rider. _last_line_mask : pygame.mask.Mask The last line mask of the rider. Methods ------- update(self, deck) Update the rider's state based on the given deck. move_rider(self, deck) Move the rider according to the card it clicked. __change_move(self, card, time) Move the rider's position based on the given card and time. __set_temp_variables(self) Set temporary variables that save code in movement. __reset_movement(self, deck) Resets the movement of the rider. _get_line_mask(color,start, end) Create a line mask based on the given color, start, and end points. select_card(self, card) Select a card for the rider. \"\"\" def __init__ ( self , number , x_y , scale_size ): \"\"\" Initializes a Rider object. Parameters ---------- number : int The rider's number. x_y : tuple The initial position of the rider as a tuple of (x, y) coordinates. scale_size : float The scale size of the rider. Returns ------- None \"\"\" super () . __init__ ( number , x_y , scale_size ) def choose_card ( self , all_riders ): \"\"\" Choose a card from the rider's hand based on the preview movement. Parameters ---------- all_riders : list A list of all riders in the game. Returns ------- pygame.sprite.Sprite The chosen card from the rider's hand. Notes ----- This method iterates through each card in the rider's hand and checks if the preview movement is valid or not. If a card's movement is valid, it is added to the choices list. If there are valid choices, a random card is returned from the choices list. If there are no valid choices, a random card from the rider's hand is returned. \"\"\" choices = [] # Laceia cada carta e decide se o movimento \u00e9 v\u00e1lido ou n\u00e3o for card in self . _hand . sprites (): # Se for, adiciona \u00e0 lista choices if self . __preview_movement ( card , all_riders ): choices . append ( card ) # Se algum for v\u00e1lido, retorna um entre eles if choices : return random . choice ( choices ) # Se n\u00e3o houver nenhum, qualquer carta da m\u00e3o valer\u00e1 else : return random . choice ( self . _hand . sprites ()) def __preview_movement ( self , card , all_riders ): \"\"\" Calculate the preview movement of the rider based on the given card. Parameters ---------- card : tuple A tuple representing the movement card (x, y). all_riders : list A list of all riders in the game. Returns ------- bool True if the preview movement is valid, False otherwise. \"\"\" # Pega o ponto inicial e final do vetor start = self . _path [ - 1 ] end = ( start [ 0 ] + card [ 0 ] * DISTANCE , start [ 1 ] - card [ 1 ] * DISTANCE ) # Se for colidir com as fronteiras retorna if utilities . check_border_collision ( end ): return False # Cria uma m\u00e1scara para testar colis\u00f5es futuras desta linha line_mask = self . _get_line_mask ( self . _color , start , end ) # Se for colidir com as linhas de outrem retorna if utilities . check_line_cross ( all_riders , self , line_mask , card ): return False # Se n\u00e3o colidir com nada, a carta \u00e9 v\u00e1lida return True __init__ ( number , x_y , scale_size ) Initializes a Rider object. Parameters number : int The rider's number. x_y : tuple The initial position of the rider as a tuple of (x, y) coordinates. scale_size : float The scale size of the rider. Returns None Source code in src/rider.py 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 def __init__ ( self , number , x_y , scale_size ): \"\"\" Initializes a Rider object. Parameters ---------- number : int The rider's number. x_y : tuple The initial position of the rider as a tuple of (x, y) coordinates. scale_size : float The scale size of the rider. Returns ------- None \"\"\" super () . __init__ ( number , x_y , scale_size ) __preview_movement ( card , all_riders ) Calculate the preview movement of the rider based on the given card. Parameters card : tuple A tuple representing the movement card (x, y). all_riders : list A list of all riders in the game. Returns bool True if the preview movement is valid, False otherwise. Source code in src/rider.py 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 def __preview_movement ( self , card , all_riders ): \"\"\" Calculate the preview movement of the rider based on the given card. Parameters ---------- card : tuple A tuple representing the movement card (x, y). all_riders : list A list of all riders in the game. Returns ------- bool True if the preview movement is valid, False otherwise. \"\"\" # Pega o ponto inicial e final do vetor start = self . _path [ - 1 ] end = ( start [ 0 ] + card [ 0 ] * DISTANCE , start [ 1 ] - card [ 1 ] * DISTANCE ) # Se for colidir com as fronteiras retorna if utilities . check_border_collision ( end ): return False # Cria uma m\u00e1scara para testar colis\u00f5es futuras desta linha line_mask = self . _get_line_mask ( self . _color , start , end ) # Se for colidir com as linhas de outrem retorna if utilities . check_line_cross ( all_riders , self , line_mask , card ): return False # Se n\u00e3o colidir com nada, a carta \u00e9 v\u00e1lida return True choose_card ( all_riders ) Choose a card from the rider's hand based on the preview movement. Parameters all_riders : list A list of all riders in the game. Returns pygame.sprite.Sprite The chosen card from the rider's hand. Notes This method iterates through each card in the rider's hand and checks if the preview movement is valid or not. If a card's movement is valid, it is added to the choices list. If there are valid choices, a random card is returned from the choices list. If there are no valid choices, a random card from the rider's hand is returned. Source code in src/rider.py 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 def choose_card ( self , all_riders ): \"\"\" Choose a card from the rider's hand based on the preview movement. Parameters ---------- all_riders : list A list of all riders in the game. Returns ------- pygame.sprite.Sprite The chosen card from the rider's hand. Notes ----- This method iterates through each card in the rider's hand and checks if the preview movement is valid or not. If a card's movement is valid, it is added to the choices list. If there are valid choices, a random card is returned from the choices list. If there are no valid choices, a random card from the rider's hand is returned. \"\"\" choices = [] # Laceia cada carta e decide se o movimento \u00e9 v\u00e1lido ou n\u00e3o for card in self . _hand . sprites (): # Se for, adiciona \u00e0 lista choices if self . __preview_movement ( card , all_riders ): choices . append ( card ) # Se algum for v\u00e1lido, retorna um entre eles if choices : return random . choice ( choices ) # Se n\u00e3o houver nenhum, qualquer carta da m\u00e3o valer\u00e1 else : return random . choice ( self . _hand . sprites ()) Player Class representing a player in the game. Attributes __wrapper : pygame.sprite.GroupSingle The wrapper around the Rider sprite. Methods sprite() Returns the sprite of the SingleGroup. update() Updates the SingleGroup. draw(screen) Draws the SingleGroup. Source code in src/rider.py 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 @utilities . Singleton class Player (): \"\"\" Class representing a player in the game. Attributes ---------- __wrapper : pygame.sprite.GroupSingle The wrapper around the Rider sprite. Methods ------- sprite() Returns the sprite of the SingleGroup. update() Updates the SingleGroup. draw(screen) Draws the SingleGroup. \"\"\" def __init__ ( self , number , x_y , scale_size , deck ): \"\"\" Initialize a Player object. Parameters ---------- number : int The player's number. x_y : tuple The initial position of the player. scale_size : int The scale size of the player. deck : Deck The player's deck. Returns ------- None \"\"\" # Cria um envolt\u00f3rio entorno de um Rider self . __wrapper = Rider ( number , x_y , scale_size , deck ) self . __wrapper = pygame . sprite . GroupSingle ( self . __wrapper ) def __getattr__ ( self , attrvalue ): \"\"\" Get the attribute from the sprite and not from the group. Parameters ---------- attrvalue : str The name of the attribute to retrieve. Returns ------- Any The value of the requested attribute. Notes ----- This method is called when an attribute is accessed on the `Rider` object that is not defined directly in the class. It delegates the attribute retrieval to the underlying sprite object. \"\"\" return getattr ( self . __wrapper . sprite , attrvalue ) def __getattr__ ( self , attrvalue ): \"\"\" Get the attribute from the sprite and not from the group. Parameters ---------- attrvalue : str The name of the attribute to get. Returns ------- Any The value of the requested attribute. Notes ----- This method is called when an attribute is not found in the current object. It allows accessing attributes of the sprite directly instead of the group. Examples -------- >>> rider = Rider() >>> rider.x 100 >>> rider.y 200 \"\"\" # Pega o atributo do sprite e n\u00e3o do grupo return getattr ( self . __wrapper . sprite , attrvalue ) def __bool__ ( self ): \"\"\" Return the boolean value of the SingleGroup. Returns ------- bool The boolean value of the SingleGroup. \"\"\" return bool ( self . __wrapper ) def sprite ( self ): \"\"\" Return the sprite of the SingleGroup. Returns ------- sprite : object The sprite object representing the SingleGroup. \"\"\" return self . __wrapper . sprite def update ( self ): \"\"\" Update the SingleGroup. Returns ------- updated : bool True if the update was successful, False otherwise. \"\"\" # Atualiza o SingleGroup return self . __wrapper . update () def draw ( self , screen ): \"\"\" Draw the SingleGroup on the screen. Parameters ---------- screen : pygame.Surface The surface to draw on. Returns ------- pygame.Rect The rectangle that represents the area of the drawn SingleGroup. \"\"\" # Desenha o SingleGroup return self . __wrapper . draw ( screen ) __bool__ () Return the boolean value of the SingleGroup. Returns bool The boolean value of the SingleGroup. Source code in src/rider.py 414 415 416 417 418 419 420 421 422 423 424 def __bool__ ( self ): \"\"\" Return the boolean value of the SingleGroup. Returns ------- bool The boolean value of the SingleGroup. \"\"\" return bool ( self . __wrapper ) __getattr__ ( attrvalue ) Get the attribute from the sprite and not from the group. Parameters attrvalue : str The name of the attribute to get. Returns Any The value of the requested attribute. Notes This method is called when an attribute is not found in the current object. It allows accessing attributes of the sprite directly instead of the group. Examples rider = Rider() rider.x 100 rider.y 200 Source code in src/rider.py 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 def __getattr__ ( self , attrvalue ): \"\"\" Get the attribute from the sprite and not from the group. Parameters ---------- attrvalue : str The name of the attribute to get. Returns ------- Any The value of the requested attribute. Notes ----- This method is called when an attribute is not found in the current object. It allows accessing attributes of the sprite directly instead of the group. Examples -------- >>> rider = Rider() >>> rider.x 100 >>> rider.y 200 \"\"\" # Pega o atributo do sprite e n\u00e3o do grupo return getattr ( self . __wrapper . sprite , attrvalue ) __init__ ( number , x_y , scale_size , deck ) Initialize a Player object. Parameters number : int The player's number. x_y : tuple The initial position of the player. scale_size : int The scale size of the player. deck : Deck The player's deck. Returns None Source code in src/rider.py 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 def __init__ ( self , number , x_y , scale_size , deck ): \"\"\" Initialize a Player object. Parameters ---------- number : int The player's number. x_y : tuple The initial position of the player. scale_size : int The scale size of the player. deck : Deck The player's deck. Returns ------- None \"\"\" # Cria um envolt\u00f3rio entorno de um Rider self . __wrapper = Rider ( number , x_y , scale_size , deck ) self . __wrapper = pygame . sprite . GroupSingle ( self . __wrapper ) draw ( screen ) Draw the SingleGroup on the screen. Parameters screen : pygame.Surface The surface to draw on. Returns pygame.Rect The rectangle that represents the area of the drawn SingleGroup. Source code in src/rider.py 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 def draw ( self , screen ): \"\"\" Draw the SingleGroup on the screen. Parameters ---------- screen : pygame.Surface The surface to draw on. Returns ------- pygame.Rect The rectangle that represents the area of the drawn SingleGroup. \"\"\" # Desenha o SingleGroup return self . __wrapper . draw ( screen ) sprite () Return the sprite of the SingleGroup. Returns sprite : object The sprite object representing the SingleGroup. Source code in src/rider.py 426 427 428 429 430 431 432 433 434 435 436 def sprite ( self ): \"\"\" Return the sprite of the SingleGroup. Returns ------- sprite : object The sprite object representing the SingleGroup. \"\"\" return self . __wrapper . sprite update () Update the SingleGroup. Returns updated : bool True if the update was successful, False otherwise. Source code in src/rider.py 438 439 440 441 442 443 444 445 446 447 448 def update ( self ): \"\"\" Update the SingleGroup. Returns ------- updated : bool True if the update was successful, False otherwise. \"\"\" # Atualiza o SingleGroup return self . __wrapper . update () Rider Bases: Entity Represents a rider object. Attributes _number : int The number of the player. _path : list A list of the rider's positions. _velocity : float The velocity of the rider. _hand : pygame.sprite.Group The rider's hand. _color : str The color of the rider. __timer : int The timer of the rider. state_alive : bool The state of the rider. clicked_card : tuple The card that the rider clicked. _last_card : tuple The last card that the rider clicked. mask : pygame.rect.Rect The mask of the rider. line_mask : pygame.mask.Mask The line mask of the rider. _last_line_mask : pygame.mask.Mask The last line mask of the rider. Methods update(self, deck) Update the rider's state based on the given deck. move_rider(self, deck) Move the rider according to the card it clicked. __change_move(self, card, time) Move the rider's position based on the given card and time. __set_temp_variables(self) Set temporary variables that save code in movement. __reset_movement(self, deck) Resets the movement of the rider. _get_line_mask(color,start, end) Create a line mask based on the given color, start, and end points. select_card(self, card) Select a card for the rider. Source code in src/rider.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 class Rider ( Entity ): \"\"\" Represents a rider object. Attributes ---------- _number : int The number of the player. _path : list A list of the rider's positions. _velocity : float The velocity of the rider. _hand : pygame.sprite.Group The rider's hand. _color : str The color of the rider. __timer : int The timer of the rider. state_alive : bool The state of the rider. clicked_card : tuple The card that the rider clicked. _last_card : tuple The last card that the rider clicked. mask : pygame.rect.Rect The mask of the rider. line_mask : pygame.mask.Mask The line mask of the rider. _last_line_mask : pygame.mask.Mask The last line mask of the rider. Methods ------- update(self, deck) Update the rider's state based on the given deck. move_rider(self, deck) Move the rider according to the card it clicked. __change_move(self, card, time) Move the rider's position based on the given card and time. __set_temp_variables(self) Set temporary variables that save code in movement. __reset_movement(self, deck) Resets the movement of the rider. _get_line_mask(color,start, end) Create a line mask based on the given color, start, and end points. select_card(self, card) Select a card for the rider. \"\"\" def __init__ ( self , number , x_y , scale_size , deck ): \"\"\" Initialize a Rider object. Parameters ---------- number : int The number of the player. x_y : tuple The initial position of the rider. scale_size : float The scale size of the rider. deck : Deck The deck object that represents the game deck. Returns ------- None \"\"\" # Carrega texturas diferentes dependendo do n\u00ba do jogador archive = \"rider_\" + str ( number ) + \".png\" # Cria o rider e centraliza sua posi\u00e7\u00e3o super () . __init__ ( \"assets/textures/\" + archive , x_y , scale_size ) self . rect = self . image . get_rect ( center = x_y ) # Atributos adicionais self . _number = number self . _path = [ x_y , x_y ] self . _velocity = 1 / 2 # Salva a m\u00e3o de cartas do jogador self . _hand = pygame . sprite . Group () for foo in range ( 3 ): card = deck . draw_card () card . rect . topleft = ( GRID_X + 50 , GRID_Y / 2 - 55 + foo * 125 ) self . _hand . add ( card ) # Salva a cor da moto if number == 1 : self . _color = \"#258dc2\" elif number == 2 : self . _color = \"#ec6716\" elif number == 3 : self . _color = \"#cb101a\" elif number == 4 : self . _color = \"#ffb001\" # Atributos de estado self . __timer = 0 self . state_alive = True self . clicked_card = None self . _last_card = ( 0 , 0 ) # M\u00e1scaras para colis\u00f5es mais precisas self . mask = pygame . rect . Rect ( x_y , ( RIDER_X / 5 - 2 , RIDER_Y / 5 - 1 )) self . line_mask = self . _get_line_mask ( self . _color , ( - 10 , - 10 ), ( - 10 , - 10 )) self . _last_line_mask = self . line_mask def update ( self , deck ): \"\"\" Update the rider's state based on the given deck. Parameters ---------- deck : Deck The deck object that represents the game deck. Returns ------- None \"\"\" # Roda anima\u00e7\u00e3o de movimento se estiver vivo if self . state_alive : return self . move_rider ( deck ) # E anima\u00e7\u00e3o de morte caso contr\u00e1rio else : pass def move_rider ( self , deck ): \"\"\" Move the rider according to the card it clicked. Parameters ---------- deck : Deck The deck object. Returns ------- bool True if the rider is moved, False otherwise. \"\"\" self . __set_temp_variables () # Move o jogador de acordo com essa desigualdade (quase sempre satisfeita) if self . __temp_player_center [ 0 ] + 2 < self . __temp_player_target [ 0 ]: self . __change_move ( self . clicked_card , self . __timer ) self . __timer += 0.05 # No caso n\u00e3o-t\u00e3o-raro de vetores (0, y), move o jogador de acordo elif self . clicked_card [ 0 ] == 0 and self . __temp_player_center [ 1 ] + 2 < self . __temp_player_target [ 1 ]: self . __change_move ( self . clicked_card , self . __timer ) self . __timer += 0.05 # Se ficou parado, reseta o movimento else : self . __reset_movement ( deck ) return False return True def __change_move ( self , card , time ): \"\"\" Move the rider's position based on the given card and time. Parameters ---------- card : tuple The difference that the rider should move in the x and y directions. time : int The time duration of the movement. Returns ------- None Notes ----- This method updates the rider's position by calculating the temporary positions based on the card and time values. The rider's position is then rounded to the nearest integer and updated accordingly. \"\"\" # Diferen\u00e7a que a moto dever\u00e1 andar delta_x = card [ 0 ] delta_y = card [ 1 ] # Reinicia a posi\u00e7\u00e3o em cada nova anima\u00e7\u00e3o if time == 0 : self . __temp_x = self . rect . centerx self . __temp_y = self . rect . centery # Valores tempor\u00e1rios para n\u00e3o perder precis\u00e3o no movimento self . __temp_x = self . __temp_x + time * delta_x / self . _velocity self . __temp_y = self . __temp_y - time * delta_y / self . _velocity # Atualiza a posi\u00e7\u00e3o (e converte para inteiro) self . rect . centerx = round ( self . __temp_x ) self . rect . centery = round ( self . __temp_y ) self . mask . center = self . rect . center def __set_temp_variables ( self ): \"\"\" Set temporary variables that save code in movement. Parameters ---------- self : Rider The Rider object. Returns ------- None \"\"\" # Vari\u00e1veis tempor\u00e1rias que poupam c\u00f3digo no movimento self . __temp_player_center = self . rect . center self . __temp_player_target = self . __player_target # Dependendo do valor da carta, muda a coordenada relativa if self . clicked_card [ 0 ] < 0 : self . __temp_player_center = ( - self . __temp_player_center [ 0 ], self . __temp_player_center [ 1 ]) self . __temp_player_target = ( - self . __temp_player_target [ 0 ], self . __temp_player_target [ 1 ]) if self . clicked_card [ 1 ] > 0 : self . __temp_player_center = ( self . __temp_player_center [ 0 ], - self . __temp_player_center [ 1 ]) self . __temp_player_target = ( self . __temp_player_target [ 0 ], - self . __temp_player_target [ 1 ]) def __reset_movement ( self , deck ): \"\"\" Resets the movement of the rider. Parameters ---------- deck : Deck The deck of cards. Returns ------- None \"\"\" # Retorna _timer para 0 self . __timer = 0 # Pesca uma nova carta e adiciona \u00e0 m\u00e3o card = deck . draw_card () card . rect . topleft = self . clicked_card . rect . topleft self . _hand . add ( card ) # Remove a carta usada e limpa _clicked_card self . _hand . remove ( self . clicked_card ) self . _last_card = self . clicked_card self . clicked_card = ( 0 , 0 ) # Salva a posi\u00e7\u00e3o final do jogador no seu _path self . _path . append ( self . rect . center ) # Cria uma masc\u00e1ra para a linha e a adiciona em line_mask temp_mask = self . _get_line_mask ( self . _color , self . _path [ - 2 ], self . _path [ - 1 ]) self . _last_line_mask = self . line_mask . copy () self . line_mask . draw ( temp_mask , ( 0 , 0 )) @staticmethod def _get_line_mask ( color , start , end ): \"\"\" Create a line mask based on the given color, start, and end points. Parameters ---------- color : str The color of the line. start : tuple The starting point of the line. end : tuple The ending point of the line. Returns ------- pygame.mask.Mask The line mask. \"\"\" # Cria uma superf\u00edcie em preto temp_surf = pygame . Surface (( GRID_X , GRID_Y )) temp_surf . set_colorkey (( 0 , 0 , 0 )) # Desenha a linha e retorna a m\u00e1scara pygame . draw . line ( temp_surf , color , start , end , width = 6 ) return pygame . mask . from_surface ( temp_surf ) def select_card ( self , card ): \"\"\" Select a card for the rider. Parameters ---------- card : tuple The card that the rider clicked. Returns ------- None \"\"\" self . clicked_card = card self . __player_target = self . _path [ - 1 ] self . __player_target = ( card [ 0 ] * DISTANCE + self . __player_target [ 0 ], - card [ 1 ] * DISTANCE + self . __player_target [ 1 ]) __change_move ( card , time ) Move the rider's position based on the given card and time. Parameters card : tuple The difference that the rider should move in the x and y directions. time : int The time duration of the movement. Returns None Notes This method updates the rider's position by calculating the temporary positions based on the card and time values. The rider's position is then rounded to the nearest integer and updated accordingly. Source code in src/rider.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 def __change_move ( self , card , time ): \"\"\" Move the rider's position based on the given card and time. Parameters ---------- card : tuple The difference that the rider should move in the x and y directions. time : int The time duration of the movement. Returns ------- None Notes ----- This method updates the rider's position by calculating the temporary positions based on the card and time values. The rider's position is then rounded to the nearest integer and updated accordingly. \"\"\" # Diferen\u00e7a que a moto dever\u00e1 andar delta_x = card [ 0 ] delta_y = card [ 1 ] # Reinicia a posi\u00e7\u00e3o em cada nova anima\u00e7\u00e3o if time == 0 : self . __temp_x = self . rect . centerx self . __temp_y = self . rect . centery # Valores tempor\u00e1rios para n\u00e3o perder precis\u00e3o no movimento self . __temp_x = self . __temp_x + time * delta_x / self . _velocity self . __temp_y = self . __temp_y - time * delta_y / self . _velocity # Atualiza a posi\u00e7\u00e3o (e converte para inteiro) self . rect . centerx = round ( self . __temp_x ) self . rect . centery = round ( self . __temp_y ) self . mask . center = self . rect . center __init__ ( number , x_y , scale_size , deck ) Initialize a Rider object. Parameters number : int The number of the player. x_y : tuple The initial position of the rider. scale_size : float The scale size of the rider. deck : Deck The deck object that represents the game deck. Returns None Source code in src/rider.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def __init__ ( self , number , x_y , scale_size , deck ): \"\"\" Initialize a Rider object. Parameters ---------- number : int The number of the player. x_y : tuple The initial position of the rider. scale_size : float The scale size of the rider. deck : Deck The deck object that represents the game deck. Returns ------- None \"\"\" # Carrega texturas diferentes dependendo do n\u00ba do jogador archive = \"rider_\" + str ( number ) + \".png\" # Cria o rider e centraliza sua posi\u00e7\u00e3o super () . __init__ ( \"assets/textures/\" + archive , x_y , scale_size ) self . rect = self . image . get_rect ( center = x_y ) # Atributos adicionais self . _number = number self . _path = [ x_y , x_y ] self . _velocity = 1 / 2 # Salva a m\u00e3o de cartas do jogador self . _hand = pygame . sprite . Group () for foo in range ( 3 ): card = deck . draw_card () card . rect . topleft = ( GRID_X + 50 , GRID_Y / 2 - 55 + foo * 125 ) self . _hand . add ( card ) # Salva a cor da moto if number == 1 : self . _color = \"#258dc2\" elif number == 2 : self . _color = \"#ec6716\" elif number == 3 : self . _color = \"#cb101a\" elif number == 4 : self . _color = \"#ffb001\" # Atributos de estado self . __timer = 0 self . state_alive = True self . clicked_card = None self . _last_card = ( 0 , 0 ) # M\u00e1scaras para colis\u00f5es mais precisas self . mask = pygame . rect . Rect ( x_y , ( RIDER_X / 5 - 2 , RIDER_Y / 5 - 1 )) self . line_mask = self . _get_line_mask ( self . _color , ( - 10 , - 10 ), ( - 10 , - 10 )) self . _last_line_mask = self . line_mask __reset_movement ( deck ) Resets the movement of the rider. Parameters deck : Deck The deck of cards. Returns None Source code in src/rider.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 def __reset_movement ( self , deck ): \"\"\" Resets the movement of the rider. Parameters ---------- deck : Deck The deck of cards. Returns ------- None \"\"\" # Retorna _timer para 0 self . __timer = 0 # Pesca uma nova carta e adiciona \u00e0 m\u00e3o card = deck . draw_card () card . rect . topleft = self . clicked_card . rect . topleft self . _hand . add ( card ) # Remove a carta usada e limpa _clicked_card self . _hand . remove ( self . clicked_card ) self . _last_card = self . clicked_card self . clicked_card = ( 0 , 0 ) # Salva a posi\u00e7\u00e3o final do jogador no seu _path self . _path . append ( self . rect . center ) # Cria uma masc\u00e1ra para a linha e a adiciona em line_mask temp_mask = self . _get_line_mask ( self . _color , self . _path [ - 2 ], self . _path [ - 1 ]) self . _last_line_mask = self . line_mask . copy () self . line_mask . draw ( temp_mask , ( 0 , 0 )) __set_temp_variables () Set temporary variables that save code in movement. Parameters self : Rider The Rider object. Returns None Source code in src/rider.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def __set_temp_variables ( self ): \"\"\" Set temporary variables that save code in movement. Parameters ---------- self : Rider The Rider object. Returns ------- None \"\"\" # Vari\u00e1veis tempor\u00e1rias que poupam c\u00f3digo no movimento self . __temp_player_center = self . rect . center self . __temp_player_target = self . __player_target # Dependendo do valor da carta, muda a coordenada relativa if self . clicked_card [ 0 ] < 0 : self . __temp_player_center = ( - self . __temp_player_center [ 0 ], self . __temp_player_center [ 1 ]) self . __temp_player_target = ( - self . __temp_player_target [ 0 ], self . __temp_player_target [ 1 ]) if self . clicked_card [ 1 ] > 0 : self . __temp_player_center = ( self . __temp_player_center [ 0 ], - self . __temp_player_center [ 1 ]) self . __temp_player_target = ( self . __temp_player_target [ 0 ], - self . __temp_player_target [ 1 ]) move_rider ( deck ) Move the rider according to the card it clicked. Parameters deck : Deck The deck object. Returns bool True if the rider is moved, False otherwise. Source code in src/rider.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def move_rider ( self , deck ): \"\"\" Move the rider according to the card it clicked. Parameters ---------- deck : Deck The deck object. Returns ------- bool True if the rider is moved, False otherwise. \"\"\" self . __set_temp_variables () # Move o jogador de acordo com essa desigualdade (quase sempre satisfeita) if self . __temp_player_center [ 0 ] + 2 < self . __temp_player_target [ 0 ]: self . __change_move ( self . clicked_card , self . __timer ) self . __timer += 0.05 # No caso n\u00e3o-t\u00e3o-raro de vetores (0, y), move o jogador de acordo elif self . clicked_card [ 0 ] == 0 and self . __temp_player_center [ 1 ] + 2 < self . __temp_player_target [ 1 ]: self . __change_move ( self . clicked_card , self . __timer ) self . __timer += 0.05 # Se ficou parado, reseta o movimento else : self . __reset_movement ( deck ) return False return True select_card ( card ) Select a card for the rider. Parameters card : tuple The card that the rider clicked. Returns None Source code in src/rider.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 def select_card ( self , card ): \"\"\" Select a card for the rider. Parameters ---------- card : tuple The card that the rider clicked. Returns ------- None \"\"\" self . clicked_card = card self . __player_target = self . _path [ - 1 ] self . __player_target = ( card [ 0 ] * DISTANCE + self . __player_target [ 0 ], - card [ 1 ] * DISTANCE + self . __player_target [ 1 ]) update ( deck ) Update the rider's state based on the given deck. Parameters deck : Deck The deck object that represents the game deck. Returns None Source code in src/rider.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 def update ( self , deck ): \"\"\" Update the rider's state based on the given deck. Parameters ---------- deck : Deck The deck object that represents the game deck. Returns ------- None \"\"\" # Roda anima\u00e7\u00e3o de movimento se estiver vivo if self . state_alive : return self . move_rider ( deck ) # E anima\u00e7\u00e3o de morte caso contr\u00e1rio else : pass StateControl Class that controls the state of the game and manages the game loop. Attributes running : bool Flag indicating if the game is running. playing : bool Flag indicating if the game is currently being played. UP_KEY : bool Flag indicating if the up key is pressed. DOWN_KEY : bool Flag indicating if the down key is pressed. START_KEY : bool Flag indicating if the start key is pressed. BACK_KEY : bool Flag indicating if the back key is pressed. ESC_KEY : bool Flag indicating if the escape key is pressed. BUTTON_CLICKED : bool Flag indicating if a button is clicked. screen : pygame.Surface The game screen. fps_clock : pygame.time.Clock The clock used to control the game's frame rate. main_menu : MainMenu The main menu of the game. options_menu : OptionsMenu The options menu of the game. credits_menu : CreditsMenu The credits menu of the game. result_screen : ResultScreen The result screen of the game. curr_menu : Menu The current menu being displayed. game_run : GridGame The game instance. Methods game_loop(self) Main game loop that updates and renders the game until the game is no longer being played. check_events(self) Check for user events such as key presses or window close events. reset_keys(self) Reset the key flags to their initial state. start(self) Start the game by displaying the main menu and entering the game loop. Source code in src/state_control.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 class StateControl (): \"\"\" Class that controls the state of the game and manages the game loop. Attributes ---------- running : bool Flag indicating if the game is running. playing : bool Flag indicating if the game is currently being played. UP_KEY : bool Flag indicating if the up key is pressed. DOWN_KEY : bool Flag indicating if the down key is pressed. START_KEY : bool Flag indicating if the start key is pressed. BACK_KEY : bool Flag indicating if the back key is pressed. ESC_KEY : bool Flag indicating if the escape key is pressed. BUTTON_CLICKED : bool Flag indicating if a button is clicked. screen : pygame.Surface The game screen. fps_clock : pygame.time.Clock The clock used to control the game's frame rate. main_menu : MainMenu The main menu of the game. options_menu : OptionsMenu The options menu of the game. credits_menu : CreditsMenu The credits menu of the game. result_screen : ResultScreen The result screen of the game. curr_menu : Menu The current menu being displayed. game_run : GridGame The game instance. Methods ------- game_loop(self) Main game loop that updates and renders the game until the game is no longer being played. check_events(self) Check for user events such as key presses or window close events. reset_keys(self) Reset the key flags to their initial state. start(self) Start the game by displaying the main menu and entering the game loop. \"\"\" def __init__ ( self ): \"\"\" Initialize the StateControl object. Parameters ---------- None Returns ------- None \"\"\" # Inicia\u00e7\u00e3o das vari\u00e1veis de controle self . running , self . playing = True , False self . UP_KEY , self . DOWN_KEY , self . START_KEY , self . BACK_KEY , self . ESC_KEY = False , False , False , False , False self . BUTTON_CLICKED = False # Cria a tela do jogo self . screen = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( \"Vectrun\" ) pygame . display . set_icon ( pygame . image . load ( TEXTURE_PATH + \"icon.png\" )) # Cria o rel\u00f3gio interno do FPS self . fps_clock = pygame . time . Clock () # Cria um objeto para cada uma das telas self . main_menu = MainMenu ( self , ( TEXTURE_PATH + \"vectrun_logo.png\" ), ( WIDTH / 2 , HEIGHT / 5 ), ( LOGO_X , LOGO_Y )) self . options_menu = OptionsMenu ( self , ( TEXTURE_PATH + \"options_button.png\" ), ( WIDTH / 2 , ( HEIGHT / 6 - 50 )), ( 2 * BUTTON_X , 2 * BUTTON_Y )) self . credits_menu = CreditsMenu ( self , ( TEXTURE_PATH + \"credits_button.png\" ), ( WIDTH / 2 , ( HEIGHT / 6 - 50 )), ( 2 * BUTTON_X , 2 * BUTTON_Y )) # EDI\u00c7\u00e3o FUtura para considerar ambos casos (derrrota e virtoria) self . result_screen = ResultScreen ( self , ( TEXTURE_PATH + \"you_win.png\" ), ( WIDTH / 2 , HEIGHT / 2 ), ( LOGO_X , LOGO_Y )) # Define a tela inicial self . curr_menu = self . main_menu # Cria um objeto para o jogo self . game_run = GridGame ( TEXTURE_PATH + \"grid.png\" , ( 0 , 0 ), ( GRID_X , GRID_Y ), 3 ) # Posteriormente, criar um a cada vez que o jogo for iniciado def game_loop ( self ): \"\"\" Main game loop that updates and renders the game until the game is no longer being played. Parameters ---------- None Returns ------- None \"\"\" while self . playing : # Preenche a tela self . screen . fill ( BLACK ) # Atualiza e exibe o jogo na tela self . game_run . update () self . game_run . draw ( self . screen ) # Enfim mostra o diplay pygame . display . update () self . fps_clock . tick ( 30 ) # INSERIR AQUI # (DETECTAR DERROTA OU VITORIA) if False : self . curr_menu = self . result_screen def check_events ( self ): \"\"\" Check for user events such as key presses or window close events. Parameters ---------- None Returns ------- None \"\"\" for event in pygame . event . get (): if event . type == pygame . QUIT : self . running , self . playing = False , False self . curr_menu . run_display = False if event . type == pygame . KEYDOWN : if event . key == pygame . K_ESCAPE : self . ESC_KEY = True self . playing = False if event . key == pygame . K_RETURN : self . START_KEY = True if event . key == pygame . K_BACKSPACE : self . BACK_KEY = True if event . key == pygame . K_DOWN : self . DOWN_KEY = True if event . key == pygame . K_UP : self . UP_KEY = True def reset_keys ( self ): \"\"\" Reset the key flags to their initial state. Parameters ---------- None Returns ------- None \"\"\" self . UP_KEY , self . DOWN_KEY , self . START_KEY , self . BACK_KEY , self . ESC_KEY = False , False , False , False , False self . BUTTON_CLICKED = False def start ( self ): \"\"\" Start the game by displaying the main menu and entering the game loop. Parameters ---------- None Returns ------- None \"\"\" while not self . playing : self . curr_menu . display_menu () if not self . running : return self . game_loop () __init__ () Initialize the StateControl object. Parameters None Returns None Source code in src/state_control.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def __init__ ( self ): \"\"\" Initialize the StateControl object. Parameters ---------- None Returns ------- None \"\"\" # Inicia\u00e7\u00e3o das vari\u00e1veis de controle self . running , self . playing = True , False self . UP_KEY , self . DOWN_KEY , self . START_KEY , self . BACK_KEY , self . ESC_KEY = False , False , False , False , False self . BUTTON_CLICKED = False # Cria a tela do jogo self . screen = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( \"Vectrun\" ) pygame . display . set_icon ( pygame . image . load ( TEXTURE_PATH + \"icon.png\" )) # Cria o rel\u00f3gio interno do FPS self . fps_clock = pygame . time . Clock () # Cria um objeto para cada uma das telas self . main_menu = MainMenu ( self , ( TEXTURE_PATH + \"vectrun_logo.png\" ), ( WIDTH / 2 , HEIGHT / 5 ), ( LOGO_X , LOGO_Y )) self . options_menu = OptionsMenu ( self , ( TEXTURE_PATH + \"options_button.png\" ), ( WIDTH / 2 , ( HEIGHT / 6 - 50 )), ( 2 * BUTTON_X , 2 * BUTTON_Y )) self . credits_menu = CreditsMenu ( self , ( TEXTURE_PATH + \"credits_button.png\" ), ( WIDTH / 2 , ( HEIGHT / 6 - 50 )), ( 2 * BUTTON_X , 2 * BUTTON_Y )) # EDI\u00c7\u00e3o FUtura para considerar ambos casos (derrrota e virtoria) self . result_screen = ResultScreen ( self , ( TEXTURE_PATH + \"you_win.png\" ), ( WIDTH / 2 , HEIGHT / 2 ), ( LOGO_X , LOGO_Y )) # Define a tela inicial self . curr_menu = self . main_menu # Cria um objeto para o jogo self . game_run = GridGame ( TEXTURE_PATH + \"grid.png\" , ( 0 , 0 ), ( GRID_X , GRID_Y ), 3 ) check_events () Check for user events such as key presses or window close events. Parameters None Returns None Source code in src/state_control.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 def check_events ( self ): \"\"\" Check for user events such as key presses or window close events. Parameters ---------- None Returns ------- None \"\"\" for event in pygame . event . get (): if event . type == pygame . QUIT : self . running , self . playing = False , False self . curr_menu . run_display = False if event . type == pygame . KEYDOWN : if event . key == pygame . K_ESCAPE : self . ESC_KEY = True self . playing = False if event . key == pygame . K_RETURN : self . START_KEY = True if event . key == pygame . K_BACKSPACE : self . BACK_KEY = True if event . key == pygame . K_DOWN : self . DOWN_KEY = True if event . key == pygame . K_UP : self . UP_KEY = True game_loop () Main game loop that updates and renders the game until the game is no longer being played. Parameters None Returns None Source code in src/state_control.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def game_loop ( self ): \"\"\" Main game loop that updates and renders the game until the game is no longer being played. Parameters ---------- None Returns ------- None \"\"\" while self . playing : # Preenche a tela self . screen . fill ( BLACK ) # Atualiza e exibe o jogo na tela self . game_run . update () self . game_run . draw ( self . screen ) # Enfim mostra o diplay pygame . display . update () self . fps_clock . tick ( 30 ) # INSERIR AQUI # (DETECTAR DERROTA OU VITORIA) if False : self . curr_menu = self . result_screen reset_keys () Reset the key flags to their initial state. Parameters None Returns None Source code in src/state_control.py 159 160 161 162 163 164 165 166 167 168 169 170 171 172 def reset_keys ( self ): \"\"\" Reset the key flags to their initial state. Parameters ---------- None Returns ------- None \"\"\" self . UP_KEY , self . DOWN_KEY , self . START_KEY , self . BACK_KEY , self . ESC_KEY = False , False , False , False , False self . BUTTON_CLICKED = False start () Start the game by displaying the main menu and entering the game loop. Parameters None Returns None Source code in src/state_control.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 def start ( self ): \"\"\" Start the game by displaying the main menu and entering the game loop. Parameters ---------- None Returns ------- None \"\"\" while not self . playing : self . curr_menu . display_menu () if not self . running : return self . game_loop () Singleton This class is used to create a singleton object. Attributes aClass : object The object to be initialized. instance : object The instance of the object. Methods init (self, cls) Initialize the Utilities class. call (self, args, *kwargs) Execute the object call as a function. Source code in src/utilities.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 class Singleton (): \"\"\" This class is used to create a singleton object. Attributes ---------- aClass : object The object to be initialized. instance : object The instance of the object. Methods ------- __init__(self, cls) Initialize the Utilities class. __call__(self, *args, **kwargs) Execute the object call as a function. \"\"\" def __init__ ( self , cls ): \"\"\" Initialize the Utilities class. Parameters ---------- cls : object The object to be initialized. Returns ------- None \"\"\" # Salva a classe original self . aClass = cls self . instance = None def __call__ ( self , * args , ** kwargs ): \"\"\" Execute the object call as a function. Parameters ---------- *args : positional arguments Positional arguments passed to the function. **kwargs : keyword arguments Keyword arguments passed to the function. Returns ------- object The result of the function call. \"\"\" # Usa o mesmo objeto em todas chamadas if self . instance is None : self . instance = self . aClass ( * args , ** kwargs ) return self . instance __call__ ( * args , ** kwargs ) Execute the object call as a function. Parameters args : positional arguments Positional arguments passed to the function. *kwargs : keyword arguments Keyword arguments passed to the function. Returns object The result of the function call. Source code in src/utilities.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 def __call__ ( self , * args , ** kwargs ): \"\"\" Execute the object call as a function. Parameters ---------- *args : positional arguments Positional arguments passed to the function. **kwargs : keyword arguments Keyword arguments passed to the function. Returns ------- object The result of the function call. \"\"\" # Usa o mesmo objeto em todas chamadas if self . instance is None : self . instance = self . aClass ( * args , ** kwargs ) return self . instance __init__ ( cls ) Initialize the Utilities class. Parameters cls : object The object to be initialized. Returns None Source code in src/utilities.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 def __init__ ( self , cls ): \"\"\" Initialize the Utilities class. Parameters ---------- cls : object The object to be initialized. Returns ------- None \"\"\" # Salva a classe original self . aClass = cls self . instance = None __hide_mask_origin ( line_mask ) Hide the origin of the line mask. Parameters line_mask : pygame.mask.Mask The original line mask. Returns pygame.mask.Mask The new line mask with the origin hidden. Source code in src/utilities.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 def __hide_mask_origin ( line_mask ): \"\"\" Hide the origin of the line mask. Parameters ---------- line_mask : pygame.mask.Mask The original line mask. Returns ------- pygame.mask.Mask The new line mask with the origin hidden. \"\"\" new_mask = line_mask . copy () # Cria uma pequena m\u00e1scara entorno da origem origin_mask = pygame . mask . Mask (( RIDER_X , RIDER_Y ), fill = True ) size = origin_mask . get_size () # Apaga de fato a origem de temp_mask new_mask . erase ( origin_mask , ( GRID_X / 2 - size [ 0 ] / 2 , GRID_Y / 2 - size [ 1 ] / 2 )) return new_mask __last_vector_collision ( card , last_card ) Check if the last vector collision occurred between two vectors. Parameters card : tuple The current vector represented as a tuple (x, y). last_card : tuple The previous vector represented as a tuple (x, y). Returns bool True if the last vector collision occurred, False otherwise. Notes The function checks if the last vector collision occurred by comparing the x and y components of the current and previous vectors. If any component is zero, it only checks the other component. If both components are non-zero, it checks if the vectors are proportional. If the vectors are proportional and have opposite signs, it considers it as a collision. Examples __last_vector_collision((1, 2), (-1, -2)) True __last_vector_collision((3, 4), (5, 6)) False Source code in src/utilities.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 def __last_vector_collision ( card , last_card ): \"\"\" Check if the last vector collision occurred between two vectors. Parameters ---------- card : tuple The current vector represented as a tuple (x, y). last_card : tuple The previous vector represented as a tuple (x, y). Returns ------- bool True if the last vector collision occurred, False otherwise. Notes ----- The function checks if the last vector collision occurred by comparing the x and y components of the current and previous vectors. If any component is zero, it only checks the other component. If both components are non-zero, it checks if the vectors are proportional. If the vectors are proportional and have opposite signs, it considers it as a collision. Examples -------- >>> __last_vector_collision((1, 2), (-1, -2)) True >>> __last_vector_collision((3, 4), (5, 6)) False \"\"\" # Se algum valor de (x, y) for 0 verifica apenas o outro valor if not card [ 0 ] and not last_card [ 0 ]: if card [ 1 ] * last_card [ 1 ] < 0 : return True elif not card [ 1 ] and not last_card [ 1 ]: if card [ 0 ] * last_card [ 0 ] < 0 : return True # Se nenhum for, verifica se s\u00e3o proporcionais elif card [ 0 ] != 0 and card [ 1 ] != 0 : if last_card [ 0 ] / card [ 0 ] == last_card [ 1 ] / card [ 1 ]: if last_card [ 0 ] / card [ 0 ] < 0 : return True else : return False check_border_collision ( rider_position ) Checks if the rider's position collides with the grid borders. Parameters rider_position : tuple The current position of the rider (x, y). Returns bool True if there is a collision with the borders, False otherwise. Source code in src/utilities.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def check_border_collision ( rider_position : tuple ) -> bool : \"\"\" Checks if the rider's position collides with the grid borders. Parameters ---------- rider_position : tuple The current position of the rider (x, y). Returns ------- bool True if there is a collision with the borders, False otherwise. \"\"\" if rider_position [ 0 ] > GRID_X - BORDER or rider_position [ 0 ] < BORDER : return True if rider_position [ 1 ] > GRID_Y - BORDER or rider_position [ 1 ] < BORDER : return True return False check_line_collision ( players_group , rider , card = None ) Check if there is a collision between the rider's line and the lines of other players. Parameters players_group : Group Group containing all the players. rider : Player Current player. card : Card, optional Selected card. Defaults to None. Returns bool True if there is a collision, False otherwise. Source code in src/utilities.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def check_line_collision ( players_group , rider , card = None ): \"\"\" Check if there is a collision between the rider's line and the lines of other players. Parameters ---------- players_group : Group Group containing all the players. rider : Player Current player. card : Card, optional Selected card. Defaults to None. Returns ------- bool True if there is a collision, False otherwise. \"\"\" # Cria um grupo com todos jogadores menos o rider atual temp_group = players_group . copy () temp_group . remove ( rider ) # Testa se ele colide com a linha de cada um dos outros for enemy in temp_group : for index in range ( 2 , len ( enemy . _path )): temp_coord = rider . mask . clipline ( enemy . _path [ index - 1 ], enemy . _path [ index ]) # Se a linha colidir, desenpacota a tupla que clipline retorna if temp_coord : return True # No caso de colidir com as pr\u00f3prias linhas for index in range ( 2 , len ( rider . _path [: - 1 ])): temp_coord = rider . mask . clipline ( rider . _path [ index - 1 ], rider . _path [ index ]) # Desenpacota a tupla que clipline retorna if temp_coord : return True # Se n\u00e3o passou card usa a que estiver salva if not card : card = rider . clicked_card # E ent\u00e3o compara com o \u00faltimo vetor usado: se for m\u00faltiplo e contr\u00e1rio ao anterior deve haver colis\u00e3o if __last_vector_collision ( card , rider . _last_card ): return True return False check_line_cross ( players_group , player , line , card = None ) Check if a line crosses with other players' lines or with its own line. Parameters players_group : pygame.sprite.Group A group containing all players except the current player. player : Player The current player. line : pygame.Surface The line to check for collisions. card : Card, optional The card used to draw the line. Defaults to None. Returns bool True if the line crosses with other players' lines or with its own line, False otherwise. Source code in src/utilities.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 def check_line_cross ( players_group , player , line , card = None ): \"\"\" Check if a line crosses with other players' lines or with its own line. Parameters ---------- players_group : pygame.sprite.Group A group containing all players except the current player. player : Player The current player. line : pygame.Surface The line to check for collisions. card : Card, optional The card used to draw the line. Defaults to None. Returns ------- bool True if the line crosses with other players' lines or with its own line, False otherwise. \"\"\" # Cria um grupo com todos jogadores menos o rider atual temp_group = players_group . copy () temp_group . remove ( player ) # Se a linha colidir com o caminho de outro rider retorna True for rider in temp_group . sprites (): temp_line = rider . line_mask # No caso de ser o primeiro movimento do player \u00e9 necess\u00e1rio esconder # A origem da linha do inimigo para que elas n\u00e3o colidam ali # Pois por ser o primeiro turno, todas sair\u00e3o dali if not player . line_mask . get_at (( GRID_X / 2 - 1 , GRID_Y / 2 - 2 )): temp_line = __hide_mask_origin ( temp_line ) # Verifica se houve overlap das linhas if line . overlap ( temp_line , ( 0 , 0 )): return True # Se a linha colidir com alguma das pr\u00f3prias retorna True if line . overlap ( player . _last_line_mask , ( 0 , 0 )): return True # Se n\u00e3o passou card usa a que estiver salva if not card : card = player . clicked_card # E verifica se elas n\u00e3o s\u00e3o contr\u00e1rias if __last_vector_collision ( card , player . _last_card ): return True return False check_riders_collision ( group_1 , group_2 ) Check collision between two sprite groups and remove collided sprites. Parameters group_1 : pygame.sprite.Group The first sprite group to check collision with. group_2 : pygame.sprite.Group The second sprite group to check collision with. Returns None This function does not return any value. It modifies the sprite groups in-place. Source code in src/utilities.py 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 def check_riders_collision ( group_1 , group_2 ): \"\"\" Check collision between two sprite groups and remove collided sprites. Parameters ---------- group_1 : pygame.sprite.Group The first sprite group to check collision with. group_2 : pygame.sprite.Group The second sprite group to check collision with. Returns ------- None This function does not return any value. It modifies the sprite groups in-place. \"\"\" pygame . sprite . groupcollide ( group_1 , group_2 , True , True )","title":"Home"},{"location":"#welcome-to-vectrun","text":"","title":"Welcome to VectRun"},{"location":"#reference","text":"","title":"Reference"},{"location":"#src.game.GridGame","text":"Bases: Entity Represents the grid game. This class inherits from Entity and represents the grid game. It is responsible for handling the game's main events, such as quitting the game, pressing the escape key, and clicking the mouse button. If a click occurs, it validates the click and performs the player's movement and collision testing.","title":"GridGame"},{"location":"#src.game.GridGame--attributes","text":"image_path : str The path to the image file. x_y : tuple The x and y coordinates of the game object. scale_size : float The scale size of the game object. bot_number : int The number of bots in the game. next_menu : str The next menu to be displayed. _game_turn : int The current turn of the game. _mov_stage : int The current stage of the player's movement. _clicked : bool True if the player has clicked, False otherwise. _deck : Deck The deck of cards. _player : Player The player object. _bots : Group The group of bots. _all_riders : Group The group of all riders.","title":"Attributes"},{"location":"#src.game.GridGame--methods","text":"init (self, image_path, x_y, scale_size, bot_number) Initializes the Game object. update(self) Update the game state. draw(self, screen) Draw the game elements on the screen. choice_preview(self, screen) Preview the selected card and its path on the screen. __preview_selected_card(card, screen) Draw the outline of the selected card. __preview_selected_path(card, screen) Preview the selected path on the screen. __validate_click(self) Verifies if the player clicked on a card and prepares the player's movement. __card_clicked(self) Verifies if a card has been clicked by the player. move_player(self, rider) Move the player's rider. __end_turn(self) Reverses the game state and advances the turn. __next_player_movement(self, card=None) Perform the movement of the next player in the game. __first_turn_collision(self) Verifies if any rider has collided during the first turn. check_collision(self, rider) Check for collisions between the rider and the game elements. __kill_rider(self, rider) Kills the specified rider and advances the turn. Source code in src/game.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 class GridGame ( Entity ): \"\"\" Represents the grid game. This class inherits from Entity and represents the grid game. It is responsible for handling the game's main events, such as quitting the game, pressing the escape key, and clicking the mouse button. If a click occurs, it validates the click and performs the player's movement and collision testing. Attributes ---------- image_path : str The path to the image file. x_y : tuple The x and y coordinates of the game object. scale_size : float The scale size of the game object. bot_number : int The number of bots in the game. next_menu : str The next menu to be displayed. _game_turn : int The current turn of the game. _mov_stage : int The current stage of the player's movement. _clicked : bool True if the player has clicked, False otherwise. _deck : Deck The deck of cards. _player : Player The player object. _bots : Group The group of bots. _all_riders : Group The group of all riders. Methods ------- __init__(self, image_path, x_y, scale_size, bot_number) Initializes the Game object. update(self) Update the game state. draw(self, screen) Draw the game elements on the screen. choice_preview(self, screen) Preview the selected card and its path on the screen. __preview_selected_card(card, screen) Draw the outline of the selected card. __preview_selected_path(card, screen) Preview the selected path on the screen. __validate_click(self) Verifies if the player clicked on a card and prepares the player's movement. __card_clicked(self) Verifies if a card has been clicked by the player. move_player(self, rider) Move the player's rider. __end_turn(self) Reverses the game state and advances the turn. __next_player_movement(self, card=None) Perform the movement of the next player in the game. __first_turn_collision(self) Verifies if any rider has collided during the first turn. check_collision(self, rider) Check for collisions between the rider and the game elements. __kill_rider(self, rider) Kills the specified rider and advances the turn. \"\"\" def __init__ ( self , image_path , x_y , scale_size , bot_number ): \"\"\" Initializes the Game object. Parameters ---------- image_path : str The path to the image file. x_y : tuple The x and y coordinates of the game object. scale_size : float The scale size of the game object. bot_number : int The number of bots in the game. Returns ------- None \"\"\" super () . __init__ ( image_path , x_y , scale_size ) # Atributos para o estado do jogo self . next_menu = \"none\" self . _game_turn = 0 self . _mov_stage = - 1 self . _clicked = False # Cria o deck self . _deck = Deck ( TEXTURE_PATH + \"cards/\" , ( CARD_X , CARD_Y )) # Cria o jogador self . _player = Player ( 1 , ( GRID_X / 2 - 1 , GRID_Y / 2 - 2 ), ( RIDER_X , RIDER_Y ), self . _deck ) # Cria os bots __bot_list = [] for bot in range ( bot_number ): __bot_list . append ( Bot ( bot + 2 , ( GRID_X / 2 - 1 , GRID_Y / 2 - 2 ), ( RIDER_X , RIDER_Y ), self . _deck )) self . _bots = pygame . sprite . OrderedUpdates ( __bot_list [:: - 1 ]) # Grupo com todos personagens animados (bots e player) self . _all_riders = pygame . sprite . Group (( self . _player . sprite ()), self . _bots . sprites ()[:: - 1 ]) def update ( self ): \"\"\" Update the game state. This method handles the main events of the menu, such as quitting the game, pressing the escape key, and clicking the mouse button. If a click occurs, it validates the click and performs the player's movement and collision testing. Returns ------- bool False. \"\"\" # Eventos principais deste menu for event in pygame . event . get (): if event . type == pygame . QUIT : pygame . quit () sys . exit () if event . type == pygame . KEYDOWN : if event . key == pygame . K_ESCAPE : pygame . quit () sys . exit () if event . type == pygame . MOUSEBUTTONDOWN : if event . button == 1 and not self . _clicked and self . _player : self . __validate_click () # Se tiver clicado, roda o movimento do jogador ou dos bots e testa colis\u00e3o if self . _clicked and self . _all_riders : self . move_player ( self . _all_riders . sprites ()[ self . _mov_stage ]) self . check_collision ( self . _all_riders . sprites ()[ self . _mov_stage ]) return False def draw ( self , screen ): \"\"\" Draw the game elements on the screen. Parameters ---------- screen : pygame.Surface The surface to draw the game elements on. Returns ------- None \"\"\" # Desenha o tabuleiro no layer mais baixo screen . blit ( self . image , self . rect ) # Desenha as linhas dos riders for rider in self . _all_riders . sprites (): pygame . draw . lines ( screen , rider . _color , False , rider . _path + [ rider . rect . center ], width = 6 ) # Desenha o contorno e as cartas if self . _player : self . choice_preview ( screen ) self . _player . _hand . draw ( screen ) # Faz blit no jogador e nos bots self . _bots . draw ( screen ) self . _player . draw ( screen ) def choice_preview ( self , screen ): \"\"\" Preview the selected card and its path on the screen. Parameters ---------- screen : pygame.Surface The screen surface to draw on. Returns ------- None \"\"\" # Verifica se o mouse est\u00e1 em cima da carta for card in self . _player . _hand . sprites (): if card . update (): # Desenha o contorno self . __preview_selected_card ( card , screen ) # Se n\u00e3o houver clicado antes, mostra a trajet\u00f3ria da carta if not self . _clicked : self . __preview_selected_path ( card , screen ) @staticmethod def __preview_selected_card ( card , screen ): \"\"\" Draw the outline of the selected card. Parameters ---------- card : Card The selected card object. screen : pygame.Surface The screen surface to draw on. Returns ------- None \"\"\" # Desenha o contorno da carta selecionada rect_pos = ( card . rect . left - CARD_SELECTED_WIDTH , card . rect . top - CARD_SELECTED_WIDTH ) rect_size = ( card . rect . width + 2 * CARD_SELECTED_WIDTH , card . rect . height + 2 * CARD_SELECTED_WIDTH ) rectangle = pygame . Rect ( rect_pos , rect_size ) pygame . draw . rect ( screen , \"#258dc2\" , rectangle , width = 2 * CARD_SELECTED_WIDTH ) def __preview_selected_path ( self , card , screen ): \"\"\" Preview the selected path on the screen. Parameters ---------- card : Card The selected card. screen : pygame.Surface The screen surface to draw on. Returns ------- None \"\"\" # Pega o ponto inicial e final da reta start = pygame . Vector2 ( self . _player . _path [ - 1 ]) # Converte para Vector2 card_value = pygame . Vector2 ( card . value [ 0 ], - card . value [ 1 ]) size_segments = 12 # Defina a dist\u00e2ncia desejada entre os segmentos da linha tracejada num_segments = int ( start . distance_to ( start + card_value * DISTANCE ) / size_segments ) # Desenha a linha tracejada for i in range ( 0 , num_segments , 2 ): segment_start = start + card_value * i * DISTANCE / num_segments segment_end = start + card_value * ( i + 1 ) * DISTANCE / num_segments pygame . draw . line ( screen , self . _player . _color , segment_start , segment_end , width = 5 ) def __validate_click ( self ): \"\"\" Verifies if the player clicked on a card and prepares the player's movement. Returns ------- None \"\"\" # Verifica em qual carta clicou player_card = self . __card_clicked () # Se tiver clicado, prepara o movimento do player if player_card : self . _clicked = True self . __next_player_movement ( player_card ) def __card_clicked ( self ): \"\"\" Verifies if a card has been clicked by the player. Returns ------- Card or None: The clicked card if found, None otherwise. \"\"\" # Se o jogador clicar na carta, _clicked = True for card in self . _player . _hand . sprites (): if card . update (): return card return None def move_player ( self , rider ): \"\"\" Move the player's rider. Parameters ---------- rider : Rider The rider object to be moved. Returns ------- None Notes ----- If the rider is able to update its position on the deck, nothing happens. If the rider is unable to update its position, the next player movement is reset. \"\"\" # Move o rider if rider . update ( self . _deck ): pass # Se ficou parado, reseta o movimento else : self . __next_player_movement () def __end_turn ( self ): \"\"\" Reverses the game state and advances the turn. Returns ------- None \"\"\" # S\u00f3 reverte o estado do jogo e adiciona um turno self . _game_turn += 1 self . _clicked = False self . _mov_stage = - 1 # Quando o jogador estiver morto pula sua vez if not self . _player : self . _mov_stage += 1 self . _clicked = True def __next_player_movement ( self , card = None ): \"\"\" Perform the movement of the next player in the game. Parameters ---------- card : Card, optional The card chosen by the player. Defaults to None. Returns ------- None Notes ----- This method is responsible for advancing the game to the next player's movement. If all players have completed their movements, the turn ends. In the rare case of a collision on the first turn, a special action is triggered. If the player is not alive, the bots will play among themselves. If all players are dead, the method returns without further actions. \"\"\" self . _mov_stage += 1 # Se todos jogadores tiverem se movimentado, acaba o turno if self . _mov_stage == len ( self . _all_riders ): self . __end_turn () # No raro caso de colidirem no primeiro turno if self . _game_turn == 1 : self . __first_turn_collision () # Quando o jogador n\u00e3o estiver vivo os bots jogar\u00e3o entre si if self . _player : return # Se todos morrerem tamb\u00e9m retorna if not self . _all_riders : return # Caso contr\u00e1rio, prepara o jogo para rodar mais uma anima\u00e7\u00e3o next_player = self . _all_riders . sprites ()[ self . _mov_stage ] # Se n\u00e3o tiver passado uma carta, faz o rider escolher (em geral um bot) if not card : card = next_player . choose_card ( self . _all_riders ) # Atualiza o estado do pr\u00f3ximo jogador next_player . select_card ( card ) def __first_turn_collision ( self ): \"\"\" Verifies if any rider has collided during the first turn. This method checks if any rider has collided with the border or with other riders during the first turn of the game. If a collision is detected, the corresponding rider is removed from the game. Returns ------- None \"\"\" for rider in self . _all_riders . sprites ()[:: - 1 ]: if utilities . check_border_collision ( rider . rect . center ): rider . kill () continue if utilities . check_line_collision ( self . _all_riders , rider ) and self . _game_turn : rider . kill () continue def check_collision ( self , rider ): \"\"\" Check for collisions between the rider and the game elements. Parameters ---------- rider (Rider): The rider object to check for collisions. Returns ------- None \"\"\" # Testa colis\u00e3o com a fronteira if utilities . check_border_collision ( rider . rect . center ): self . __kill_rider ( rider ) return # Testa colis\u00e3o com as linhas if utilities . check_line_collision ( self . _all_riders , rider ) and self . _game_turn : self . __kill_rider ( rider ) return # Verifica se colidiram entre si #utilities.check_riders_collision(self._player, self._bots) def __kill_rider ( self , rider ): \"\"\" Kills the specified rider and advances the turn. Parameters ---------- rider (Rider): The rider to be killed. Returns ------- None \"\"\" # Mata o rider rider . kill () # Avan\u00e7a o turno self . _mov_stage -= 1 self . __next_player_movement ()","title":"Methods"},{"location":"#src.game.GridGame.__card_clicked","text":"Verifies if a card has been clicked by the player.","title":"__card_clicked()"},{"location":"#src.game.GridGame.__card_clicked--returns","text":"Card or None: The clicked card if found, None otherwise. Source code in src/game.py 278 279 280 281 282 283 284 285 286 287 288 289 290 291 def __card_clicked ( self ): \"\"\" Verifies if a card has been clicked by the player. Returns ------- Card or None: The clicked card if found, None otherwise. \"\"\" # Se o jogador clicar na carta, _clicked = True for card in self . _player . _hand . sprites (): if card . update (): return card return None","title":"Returns"},{"location":"#src.game.GridGame.__end_turn","text":"Reverses the game state and advances the turn.","title":"__end_turn()"},{"location":"#src.game.GridGame.__end_turn--returns","text":"None Source code in src/game.py 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 def __end_turn ( self ): \"\"\" Reverses the game state and advances the turn. Returns ------- None \"\"\" # S\u00f3 reverte o estado do jogo e adiciona um turno self . _game_turn += 1 self . _clicked = False self . _mov_stage = - 1 # Quando o jogador estiver morto pula sua vez if not self . _player : self . _mov_stage += 1 self . _clicked = True","title":"Returns"},{"location":"#src.game.GridGame.__first_turn_collision","text":"Verifies if any rider has collided during the first turn. This method checks if any rider has collided with the border or with other riders during the first turn of the game. If a collision is detected, the corresponding rider is removed from the game.","title":"__first_turn_collision()"},{"location":"#src.game.GridGame.__first_turn_collision--returns","text":"None Source code in src/game.py 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 def __first_turn_collision ( self ): \"\"\" Verifies if any rider has collided during the first turn. This method checks if any rider has collided with the border or with other riders during the first turn of the game. If a collision is detected, the corresponding rider is removed from the game. Returns ------- None \"\"\" for rider in self . _all_riders . sprites ()[:: - 1 ]: if utilities . check_border_collision ( rider . rect . center ): rider . kill () continue if utilities . check_line_collision ( self . _all_riders , rider ) and self . _game_turn : rider . kill () continue","title":"Returns"},{"location":"#src.game.GridGame.__init__","text":"Initializes the Game object.","title":"__init__()"},{"location":"#src.game.GridGame.__init__--parameters","text":"image_path : str The path to the image file. x_y : tuple The x and y coordinates of the game object. scale_size : float The scale size of the game object. bot_number : int The number of bots in the game.","title":"Parameters"},{"location":"#src.game.GridGame.__init__--returns","text":"None Source code in src/game.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 def __init__ ( self , image_path , x_y , scale_size , bot_number ): \"\"\" Initializes the Game object. Parameters ---------- image_path : str The path to the image file. x_y : tuple The x and y coordinates of the game object. scale_size : float The scale size of the game object. bot_number : int The number of bots in the game. Returns ------- None \"\"\" super () . __init__ ( image_path , x_y , scale_size ) # Atributos para o estado do jogo self . next_menu = \"none\" self . _game_turn = 0 self . _mov_stage = - 1 self . _clicked = False # Cria o deck self . _deck = Deck ( TEXTURE_PATH + \"cards/\" , ( CARD_X , CARD_Y )) # Cria o jogador self . _player = Player ( 1 , ( GRID_X / 2 - 1 , GRID_Y / 2 - 2 ), ( RIDER_X , RIDER_Y ), self . _deck ) # Cria os bots __bot_list = [] for bot in range ( bot_number ): __bot_list . append ( Bot ( bot + 2 , ( GRID_X / 2 - 1 , GRID_Y / 2 - 2 ), ( RIDER_X , RIDER_Y ), self . _deck )) self . _bots = pygame . sprite . OrderedUpdates ( __bot_list [:: - 1 ]) # Grupo com todos personagens animados (bots e player) self . _all_riders = pygame . sprite . Group (( self . _player . sprite ()), self . _bots . sprites ()[:: - 1 ])","title":"Returns"},{"location":"#src.game.GridGame.__kill_rider","text":"Kills the specified rider and advances the turn.","title":"__kill_rider()"},{"location":"#src.game.GridGame.__kill_rider--parameters","text":"rider (Rider): The rider to be killed.","title":"Parameters"},{"location":"#src.game.GridGame.__kill_rider--returns","text":"None Source code in src/game.py 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 def __kill_rider ( self , rider ): \"\"\" Kills the specified rider and advances the turn. Parameters ---------- rider (Rider): The rider to be killed. Returns ------- None \"\"\" # Mata o rider rider . kill () # Avan\u00e7a o turno self . _mov_stage -= 1 self . __next_player_movement ()","title":"Returns"},{"location":"#src.game.GridGame.__next_player_movement","text":"Perform the movement of the next player in the game.","title":"__next_player_movement()"},{"location":"#src.game.GridGame.__next_player_movement--parameters","text":"card : Card, optional The card chosen by the player. Defaults to None.","title":"Parameters"},{"location":"#src.game.GridGame.__next_player_movement--returns","text":"None","title":"Returns"},{"location":"#src.game.GridGame.__next_player_movement--notes","text":"This method is responsible for advancing the game to the next player's movement. If all players have completed their movements, the turn ends. In the rare case of a collision on the first turn, a special action is triggered. If the player is not alive, the bots will play among themselves. If all players are dead, the method returns without further actions. Source code in src/game.py 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 def __next_player_movement ( self , card = None ): \"\"\" Perform the movement of the next player in the game. Parameters ---------- card : Card, optional The card chosen by the player. Defaults to None. Returns ------- None Notes ----- This method is responsible for advancing the game to the next player's movement. If all players have completed their movements, the turn ends. In the rare case of a collision on the first turn, a special action is triggered. If the player is not alive, the bots will play among themselves. If all players are dead, the method returns without further actions. \"\"\" self . _mov_stage += 1 # Se todos jogadores tiverem se movimentado, acaba o turno if self . _mov_stage == len ( self . _all_riders ): self . __end_turn () # No raro caso de colidirem no primeiro turno if self . _game_turn == 1 : self . __first_turn_collision () # Quando o jogador n\u00e3o estiver vivo os bots jogar\u00e3o entre si if self . _player : return # Se todos morrerem tamb\u00e9m retorna if not self . _all_riders : return # Caso contr\u00e1rio, prepara o jogo para rodar mais uma anima\u00e7\u00e3o next_player = self . _all_riders . sprites ()[ self . _mov_stage ] # Se n\u00e3o tiver passado uma carta, faz o rider escolher (em geral um bot) if not card : card = next_player . choose_card ( self . _all_riders ) # Atualiza o estado do pr\u00f3ximo jogador next_player . select_card ( card )","title":"Notes"},{"location":"#src.game.GridGame.__preview_selected_card","text":"Draw the outline of the selected card.","title":"__preview_selected_card()"},{"location":"#src.game.GridGame.__preview_selected_card--parameters","text":"card : Card The selected card object. screen : pygame.Surface The screen surface to draw on.","title":"Parameters"},{"location":"#src.game.GridGame.__preview_selected_card--returns","text":"None Source code in src/game.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 @staticmethod def __preview_selected_card ( card , screen ): \"\"\" Draw the outline of the selected card. Parameters ---------- card : Card The selected card object. screen : pygame.Surface The screen surface to draw on. Returns ------- None \"\"\" # Desenha o contorno da carta selecionada rect_pos = ( card . rect . left - CARD_SELECTED_WIDTH , card . rect . top - CARD_SELECTED_WIDTH ) rect_size = ( card . rect . width + 2 * CARD_SELECTED_WIDTH , card . rect . height + 2 * CARD_SELECTED_WIDTH ) rectangle = pygame . Rect ( rect_pos , rect_size ) pygame . draw . rect ( screen , \"#258dc2\" , rectangle , width = 2 * CARD_SELECTED_WIDTH )","title":"Returns"},{"location":"#src.game.GridGame.__preview_selected_path","text":"Preview the selected path on the screen.","title":"__preview_selected_path()"},{"location":"#src.game.GridGame.__preview_selected_path--parameters","text":"card : Card The selected card. screen : pygame.Surface The screen surface to draw on.","title":"Parameters"},{"location":"#src.game.GridGame.__preview_selected_path--returns","text":"None Source code in src/game.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 def __preview_selected_path ( self , card , screen ): \"\"\" Preview the selected path on the screen. Parameters ---------- card : Card The selected card. screen : pygame.Surface The screen surface to draw on. Returns ------- None \"\"\" # Pega o ponto inicial e final da reta start = pygame . Vector2 ( self . _player . _path [ - 1 ]) # Converte para Vector2 card_value = pygame . Vector2 ( card . value [ 0 ], - card . value [ 1 ]) size_segments = 12 # Defina a dist\u00e2ncia desejada entre os segmentos da linha tracejada num_segments = int ( start . distance_to ( start + card_value * DISTANCE ) / size_segments ) # Desenha a linha tracejada for i in range ( 0 , num_segments , 2 ): segment_start = start + card_value * i * DISTANCE / num_segments segment_end = start + card_value * ( i + 1 ) * DISTANCE / num_segments pygame . draw . line ( screen , self . _player . _color , segment_start , segment_end , width = 5 )","title":"Returns"},{"location":"#src.game.GridGame.__validate_click","text":"Verifies if the player clicked on a card and prepares the player's movement.","title":"__validate_click()"},{"location":"#src.game.GridGame.__validate_click--returns","text":"None Source code in src/game.py 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 def __validate_click ( self ): \"\"\" Verifies if the player clicked on a card and prepares the player's movement. Returns ------- None \"\"\" # Verifica em qual carta clicou player_card = self . __card_clicked () # Se tiver clicado, prepara o movimento do player if player_card : self . _clicked = True self . __next_player_movement ( player_card )","title":"Returns"},{"location":"#src.game.GridGame.check_collision","text":"Check for collisions between the rider and the game elements.","title":"check_collision()"},{"location":"#src.game.GridGame.check_collision--parameters","text":"rider (Rider): The rider object to check for collisions.","title":"Parameters"},{"location":"#src.game.GridGame.check_collision--returns","text":"None Source code in src/game.py 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 def check_collision ( self , rider ): \"\"\" Check for collisions between the rider and the game elements. Parameters ---------- rider (Rider): The rider object to check for collisions. Returns ------- None \"\"\" # Testa colis\u00e3o com a fronteira if utilities . check_border_collision ( rider . rect . center ): self . __kill_rider ( rider ) return # Testa colis\u00e3o com as linhas if utilities . check_line_collision ( self . _all_riders , rider ) and self . _game_turn : self . __kill_rider ( rider ) return","title":"Returns"},{"location":"#src.game.GridGame.choice_preview","text":"Preview the selected card and its path on the screen.","title":"choice_preview()"},{"location":"#src.game.GridGame.choice_preview--parameters","text":"screen : pygame.Surface The screen surface to draw on.","title":"Parameters"},{"location":"#src.game.GridGame.choice_preview--returns","text":"None Source code in src/game.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 def choice_preview ( self , screen ): \"\"\" Preview the selected card and its path on the screen. Parameters ---------- screen : pygame.Surface The screen surface to draw on. Returns ------- None \"\"\" # Verifica se o mouse est\u00e1 em cima da carta for card in self . _player . _hand . sprites (): if card . update (): # Desenha o contorno self . __preview_selected_card ( card , screen ) # Se n\u00e3o houver clicado antes, mostra a trajet\u00f3ria da carta if not self . _clicked : self . __preview_selected_path ( card , screen )","title":"Returns"},{"location":"#src.game.GridGame.draw","text":"Draw the game elements on the screen.","title":"draw()"},{"location":"#src.game.GridGame.draw--parameters","text":"screen : pygame.Surface The surface to draw the game elements on.","title":"Parameters"},{"location":"#src.game.GridGame.draw--returns","text":"None Source code in src/game.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 def draw ( self , screen ): \"\"\" Draw the game elements on the screen. Parameters ---------- screen : pygame.Surface The surface to draw the game elements on. Returns ------- None \"\"\" # Desenha o tabuleiro no layer mais baixo screen . blit ( self . image , self . rect ) # Desenha as linhas dos riders for rider in self . _all_riders . sprites (): pygame . draw . lines ( screen , rider . _color , False , rider . _path + [ rider . rect . center ], width = 6 ) # Desenha o contorno e as cartas if self . _player : self . choice_preview ( screen ) self . _player . _hand . draw ( screen ) # Faz blit no jogador e nos bots self . _bots . draw ( screen ) self . _player . draw ( screen )","title":"Returns"},{"location":"#src.game.GridGame.move_player","text":"Move the player's rider.","title":"move_player()"},{"location":"#src.game.GridGame.move_player--parameters","text":"rider : Rider The rider object to be moved.","title":"Parameters"},{"location":"#src.game.GridGame.move_player--returns","text":"None","title":"Returns"},{"location":"#src.game.GridGame.move_player--notes","text":"If the rider is able to update its position on the deck, nothing happens. If the rider is unable to update its position, the next player movement is reset. Source code in src/game.py 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 def move_player ( self , rider ): \"\"\" Move the player's rider. Parameters ---------- rider : Rider The rider object to be moved. Returns ------- None Notes ----- If the rider is able to update its position on the deck, nothing happens. If the rider is unable to update its position, the next player movement is reset. \"\"\" # Move o rider if rider . update ( self . _deck ): pass # Se ficou parado, reseta o movimento else : self . __next_player_movement ()","title":"Notes"},{"location":"#src.game.GridGame.update","text":"Update the game state. This method handles the main events of the menu, such as quitting the game, pressing the escape key, and clicking the mouse button. If a click occurs, it validates the click and performs the player's movement and collision testing.","title":"update()"},{"location":"#src.game.GridGame.update--returns","text":"bool False. Source code in src/game.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def update ( self ): \"\"\" Update the game state. This method handles the main events of the menu, such as quitting the game, pressing the escape key, and clicking the mouse button. If a click occurs, it validates the click and performs the player's movement and collision testing. Returns ------- bool False. \"\"\" # Eventos principais deste menu for event in pygame . event . get (): if event . type == pygame . QUIT : pygame . quit () sys . exit () if event . type == pygame . KEYDOWN : if event . key == pygame . K_ESCAPE : pygame . quit () sys . exit () if event . type == pygame . MOUSEBUTTONDOWN : if event . button == 1 and not self . _clicked and self . _player : self . __validate_click () # Se tiver clicado, roda o movimento do jogador ou dos bots e testa colis\u00e3o if self . _clicked and self . _all_riders : self . move_player ( self . _all_riders . sprites ()[ self . _mov_stage ]) self . check_collision ( self . _all_riders . sprites ()[ self . _mov_stage ]) return False","title":"Returns"},{"location":"#src.deck.Card","text":"Bases: Entity Represents a card object.","title":"Card"},{"location":"#src.deck.Card--attributes","text":"image_path : str The path to the image file for the card. x_y : tuple The x and y coordinates of the card's position. scale_size : float The scale size of the card. value : int The value of the card.","title":"Attributes"},{"location":"#src.deck.Card--methods","text":"init (self, image_path, x_y, scale_size, value) Initialize a Card object. getitem (self, key) Get the value of the card at the specified index. update(self) Update the card's state. Source code in src/deck.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 class Card ( Entity ): \"\"\" Represents a card object. Attributes ---------- image_path : str The path to the image file for the card. x_y : tuple The x and y coordinates of the card's position. scale_size : float The scale size of the card. value : int The value of the card. Methods ------- __init__(self, image_path, x_y, scale_size, value) Initialize a Card object. __getitem__(self, key) Get the value of the card at the specified index. update(self) Update the card's state. \"\"\" def __init__ ( self , image_path , x_y , scale_size , value ): \"\"\" Initialize a Card object. Parameters ---------- image_path : str The path to the image file for the card. x_y : tuple The x and y coordinates of the card's position. scale_size : float The scale size of the card. value : int The value of the card. Returns ------- None \"\"\" super () . __init__ ( image_path , x_y , scale_size ) # Dire\u00e7\u00e3o do vetor self . value = value def __getitem__ ( self , key ): \"\"\" Get the value of the card at the specified index. Parameters ---------- key : int The index of the value to retrieve. Returns ------- int The value of the card at the specified index. \"\"\" return self . value [ key ] def update ( self ): \"\"\" Update the card's state. Returns ------- bool True if the card collides with the mouse position, False otherwise. \"\"\" # Testa se houve colis\u00e3o com o mouse mouse_pos = pygame . mouse . get_pos () # Se houver, retorna True if self . rect . collidepoint ( mouse_pos ): return True else : return False","title":"Methods"},{"location":"#src.deck.Card.__getitem__","text":"Get the value of the card at the specified index.","title":"__getitem__()"},{"location":"#src.deck.Card.__getitem__--parameters","text":"key : int The index of the value to retrieve.","title":"Parameters"},{"location":"#src.deck.Card.__getitem__--returns","text":"int The value of the card at the specified index. Source code in src/deck.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def __getitem__ ( self , key ): \"\"\" Get the value of the card at the specified index. Parameters ---------- key : int The index of the value to retrieve. Returns ------- int The value of the card at the specified index. \"\"\" return self . value [ key ]","title":"Returns"},{"location":"#src.deck.Card.__init__","text":"Initialize a Card object.","title":"__init__()"},{"location":"#src.deck.Card.__init__--parameters","text":"image_path : str The path to the image file for the card. x_y : tuple The x and y coordinates of the card's position. scale_size : float The scale size of the card. value : int The value of the card.","title":"Parameters"},{"location":"#src.deck.Card.__init__--returns","text":"None Source code in src/deck.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def __init__ ( self , image_path , x_y , scale_size , value ): \"\"\" Initialize a Card object. Parameters ---------- image_path : str The path to the image file for the card. x_y : tuple The x and y coordinates of the card's position. scale_size : float The scale size of the card. value : int The value of the card. Returns ------- None \"\"\" super () . __init__ ( image_path , x_y , scale_size ) # Dire\u00e7\u00e3o do vetor self . value = value","title":"Returns"},{"location":"#src.deck.Card.update","text":"Update the card's state.","title":"update()"},{"location":"#src.deck.Card.update--returns","text":"bool True if the card collides with the mouse position, False otherwise. Source code in src/deck.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def update ( self ): \"\"\" Update the card's state. Returns ------- bool True if the card collides with the mouse position, False otherwise. \"\"\" # Testa se houve colis\u00e3o com o mouse mouse_pos = pygame . mouse . get_pos () # Se houver, retorna True if self . rect . collidepoint ( mouse_pos ): return True else : return False","title":"Returns"},{"location":"#src.deck.Deck","text":"Bases: Entity Represents a deck of cards.","title":"Deck"},{"location":"#src.deck.Deck--attributes","text":"cards : list A list of Card objects representing the cards in the deck. drawn_cards : list A list of Card objects representing the cards that have been drawn from the deck and are in play.","title":"Attributes"},{"location":"#src.deck.Deck--methods","text":"init (self, card_path, scale_size) Initializes a Deck object. shuffle_deck(self) Shuffles the deck of cards. draw_card(self) Draws a card from the deck. Source code in src/deck.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 class Deck ( Entity ): \"\"\" Represents a deck of cards. Attributes ---------- cards : list A list of Card objects representing the cards in the deck. drawn_cards : list A list of Card objects representing the cards that have been drawn from the deck and are in play. Methods ------- __init__(self, card_path, scale_size) Initializes a Deck object. shuffle_deck(self) Shuffles the deck of cards. draw_card(self) Draws a card from the deck. \"\"\" def __init__ ( self , card_path , scale_size ): \"\"\" Initializes a Deck object. Parameters ---------- card_path : str The path to the directory containing the card images. scale_size : tuple A tuple representing the scale size of the cards. Returns ------- None \"\"\" super () . __init__ ( card_path + \"card_back.png\" , ( 0 , 0 ), ( 0 , 0 )) self . cards = [] self . drawn_cards = [] # Cartas que foram tiradas do deck e est\u00e3o em jogo # Carrega todas as cartas pra mem\u00f3ria __card_count = 1 for y in range ( - 4 , 5 ): for x in range ( - 4 , 5 ): # Se for a origem, pula (esta carta-vetor n\u00e3o existe) if ( x , y ) == ( 0 , 0 ): continue # Nome do arquivo da carta card_name = \"card_\" + str ( __card_count ) + \".png\" # Cria a carta em si card = Card ( card_path + card_name , ( 0 , 0 ), scale_size , value = ( x , y )) self . cards . append ( card ) __card_count += 1 # Embaralha as cartas self . shuffle_deck () def shuffle_deck ( self ): \"\"\" Shuffles the deck of cards. If the deck is empty, the drawn cards are shuffled and added back to the deck. Otherwise, the deck itself is shuffled. Returns ------- None \"\"\" if not self . cards : random . shuffle ( self . drawn_cards ) self . cards = self . drawn_cards . copy () self . drawn_cards . clear () else : random . shuffle ( self . cards ) def draw_card ( self ): \"\"\" Draws a card from the deck. If the deck is empty, it is shuffled again before drawing a card. Returns: Card: The card that was drawn from the deck. \"\"\" if not self . cards : self . shuffle_deck () card = self . cards . pop ( 0 ) self . drawn_cards . append ( card ) return card","title":"Methods"},{"location":"#src.deck.Deck.__init__","text":"Initializes a Deck object.","title":"__init__()"},{"location":"#src.deck.Deck.__init__--parameters","text":"card_path : str The path to the directory containing the card images. scale_size : tuple A tuple representing the scale size of the cards.","title":"Parameters"},{"location":"#src.deck.Deck.__init__--returns","text":"None Source code in src/deck.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def __init__ ( self , card_path , scale_size ): \"\"\" Initializes a Deck object. Parameters ---------- card_path : str The path to the directory containing the card images. scale_size : tuple A tuple representing the scale size of the cards. Returns ------- None \"\"\" super () . __init__ ( card_path + \"card_back.png\" , ( 0 , 0 ), ( 0 , 0 )) self . cards = [] self . drawn_cards = [] # Cartas que foram tiradas do deck e est\u00e3o em jogo # Carrega todas as cartas pra mem\u00f3ria __card_count = 1 for y in range ( - 4 , 5 ): for x in range ( - 4 , 5 ): # Se for a origem, pula (esta carta-vetor n\u00e3o existe) if ( x , y ) == ( 0 , 0 ): continue # Nome do arquivo da carta card_name = \"card_\" + str ( __card_count ) + \".png\" # Cria a carta em si card = Card ( card_path + card_name , ( 0 , 0 ), scale_size , value = ( x , y )) self . cards . append ( card ) __card_count += 1 # Embaralha as cartas self . shuffle_deck ()","title":"Returns"},{"location":"#src.deck.Deck.draw_card","text":"Draws a card from the deck. If the deck is empty, it is shuffled again before drawing a card. Returns: Card \u2013 The card that was drawn from the deck. Source code in src/deck.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 def draw_card ( self ): \"\"\" Draws a card from the deck. If the deck is empty, it is shuffled again before drawing a card. Returns: Card: The card that was drawn from the deck. \"\"\" if not self . cards : self . shuffle_deck () card = self . cards . pop ( 0 ) self . drawn_cards . append ( card ) return card","title":"draw_card()"},{"location":"#src.deck.Deck.shuffle_deck","text":"Shuffles the deck of cards. If the deck is empty, the drawn cards are shuffled and added back to the deck. Otherwise, the deck itself is shuffled.","title":"shuffle_deck()"},{"location":"#src.deck.Deck.shuffle_deck--returns","text":"None Source code in src/deck.py 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 def shuffle_deck ( self ): \"\"\" Shuffles the deck of cards. If the deck is empty, the drawn cards are shuffled and added back to the deck. Otherwise, the deck itself is shuffled. Returns ------- None \"\"\" if not self . cards : random . shuffle ( self . drawn_cards ) self . cards = self . drawn_cards . copy () self . drawn_cards . clear () else : random . shuffle ( self . cards )","title":"Returns"},{"location":"#src.entity.Entity","text":"Bases: Sprite Base class for game entities. This class inherits from pygame.sprite.Sprite and serves as a base class for all game entities. It provides common functionality such as loading and scaling images, as well as updating the entity's state.","title":"Entity"},{"location":"#src.entity.Entity--attributes","text":"image : pygame.Surface The image of the entity. rect : pygame.Rect The rectangular area occupied by the entity on the screen.","title":"Attributes"},{"location":"#src.entity.Entity--methods","text":"init (self, image_path, x_y, scale_size) Initialize the Entity object. update(self) Update the entity's state. Source code in src/entity.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class Entity ( pygame . sprite . Sprite , metaclass = ABCMeta ): \"\"\" Base class for game entities. This class inherits from pygame.sprite.Sprite and serves as a base class for all game entities. It provides common functionality such as loading and scaling images, as well as updating the entity's state. Attributes ---------- image : pygame.Surface The image of the entity. rect : pygame.Rect The rectangular area occupied by the entity on the screen. Methods ------- __init__(self, image_path, x_y, scale_size) Initialize the Entity object. update(self) Update the entity's state. \"\"\" def __init__ ( self , image_path , x_y , scale_size ): \"\"\" Initialize the Entity object. Parameters ---------- image_path : str The path to the image file. x_y : tuple The x and y coordinates of the entity's top-left corner. scale_size : tuple The width and height to scale the image. Returns ------- None \"\"\" super () . __init__ () self . image = pygame . image . load ( image_path ) . convert_alpha () self . image = pygame . transform . smoothscale ( self . image , scale_size ) self . rect = self . image . get_rect ( topleft = x_y ) def update ( self ): \"\"\" Update the entity's state. Returns ------- None This method does not return anything. \"\"\" pass","title":"Methods"},{"location":"#src.entity.Entity.__init__","text":"Initialize the Entity object.","title":"__init__()"},{"location":"#src.entity.Entity.__init__--parameters","text":"image_path : str The path to the image file. x_y : tuple The x and y coordinates of the entity's top-left corner. scale_size : tuple The width and height to scale the image.","title":"Parameters"},{"location":"#src.entity.Entity.__init__--returns","text":"None Source code in src/entity.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def __init__ ( self , image_path , x_y , scale_size ): \"\"\" Initialize the Entity object. Parameters ---------- image_path : str The path to the image file. x_y : tuple The x and y coordinates of the entity's top-left corner. scale_size : tuple The width and height to scale the image. Returns ------- None \"\"\" super () . __init__ () self . image = pygame . image . load ( image_path ) . convert_alpha () self . image = pygame . transform . smoothscale ( self . image , scale_size ) self . rect = self . image . get_rect ( topleft = x_y )","title":"Returns"},{"location":"#src.entity.Entity.update","text":"Update the entity's state.","title":"update()"},{"location":"#src.entity.Entity.update--returns","text":"None This method does not return anything. Source code in src/entity.py 50 51 52 53 54 55 56 57 58 59 def update ( self ): \"\"\" Update the entity's state. Returns ------- None This method does not return anything. \"\"\" pass","title":"Returns"},{"location":"#src.game.GridGame","text":"Bases: Entity Represents the grid game. This class inherits from Entity and represents the grid game. It is responsible for handling the game's main events, such as quitting the game, pressing the escape key, and clicking the mouse button. If a click occurs, it validates the click and performs the player's movement and collision testing.","title":"GridGame"},{"location":"#src.game.GridGame--attributes","text":"image_path : str The path to the image file. x_y : tuple The x and y coordinates of the game object. scale_size : float The scale size of the game object. bot_number : int The number of bots in the game. next_menu : str The next menu to be displayed. _game_turn : int The current turn of the game. _mov_stage : int The current stage of the player's movement. _clicked : bool True if the player has clicked, False otherwise. _deck : Deck The deck of cards. _player : Player The player object. _bots : Group The group of bots. _all_riders : Group The group of all riders.","title":"Attributes"},{"location":"#src.game.GridGame--methods","text":"init (self, image_path, x_y, scale_size, bot_number) Initializes the Game object. update(self) Update the game state. draw(self, screen) Draw the game elements on the screen. choice_preview(self, screen) Preview the selected card and its path on the screen. __preview_selected_card(card, screen) Draw the outline of the selected card. __preview_selected_path(card, screen) Preview the selected path on the screen. __validate_click(self) Verifies if the player clicked on a card and prepares the player's movement. __card_clicked(self) Verifies if a card has been clicked by the player. move_player(self, rider) Move the player's rider. __end_turn(self) Reverses the game state and advances the turn. __next_player_movement(self, card=None) Perform the movement of the next player in the game. __first_turn_collision(self) Verifies if any rider has collided during the first turn. check_collision(self, rider) Check for collisions between the rider and the game elements. __kill_rider(self, rider) Kills the specified rider and advances the turn. Source code in src/game.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 class GridGame ( Entity ): \"\"\" Represents the grid game. This class inherits from Entity and represents the grid game. It is responsible for handling the game's main events, such as quitting the game, pressing the escape key, and clicking the mouse button. If a click occurs, it validates the click and performs the player's movement and collision testing. Attributes ---------- image_path : str The path to the image file. x_y : tuple The x and y coordinates of the game object. scale_size : float The scale size of the game object. bot_number : int The number of bots in the game. next_menu : str The next menu to be displayed. _game_turn : int The current turn of the game. _mov_stage : int The current stage of the player's movement. _clicked : bool True if the player has clicked, False otherwise. _deck : Deck The deck of cards. _player : Player The player object. _bots : Group The group of bots. _all_riders : Group The group of all riders. Methods ------- __init__(self, image_path, x_y, scale_size, bot_number) Initializes the Game object. update(self) Update the game state. draw(self, screen) Draw the game elements on the screen. choice_preview(self, screen) Preview the selected card and its path on the screen. __preview_selected_card(card, screen) Draw the outline of the selected card. __preview_selected_path(card, screen) Preview the selected path on the screen. __validate_click(self) Verifies if the player clicked on a card and prepares the player's movement. __card_clicked(self) Verifies if a card has been clicked by the player. move_player(self, rider) Move the player's rider. __end_turn(self) Reverses the game state and advances the turn. __next_player_movement(self, card=None) Perform the movement of the next player in the game. __first_turn_collision(self) Verifies if any rider has collided during the first turn. check_collision(self, rider) Check for collisions between the rider and the game elements. __kill_rider(self, rider) Kills the specified rider and advances the turn. \"\"\" def __init__ ( self , image_path , x_y , scale_size , bot_number ): \"\"\" Initializes the Game object. Parameters ---------- image_path : str The path to the image file. x_y : tuple The x and y coordinates of the game object. scale_size : float The scale size of the game object. bot_number : int The number of bots in the game. Returns ------- None \"\"\" super () . __init__ ( image_path , x_y , scale_size ) # Atributos para o estado do jogo self . next_menu = \"none\" self . _game_turn = 0 self . _mov_stage = - 1 self . _clicked = False # Cria o deck self . _deck = Deck ( TEXTURE_PATH + \"cards/\" , ( CARD_X , CARD_Y )) # Cria o jogador self . _player = Player ( 1 , ( GRID_X / 2 - 1 , GRID_Y / 2 - 2 ), ( RIDER_X , RIDER_Y ), self . _deck ) # Cria os bots __bot_list = [] for bot in range ( bot_number ): __bot_list . append ( Bot ( bot + 2 , ( GRID_X / 2 - 1 , GRID_Y / 2 - 2 ), ( RIDER_X , RIDER_Y ), self . _deck )) self . _bots = pygame . sprite . OrderedUpdates ( __bot_list [:: - 1 ]) # Grupo com todos personagens animados (bots e player) self . _all_riders = pygame . sprite . Group (( self . _player . sprite ()), self . _bots . sprites ()[:: - 1 ]) def update ( self ): \"\"\" Update the game state. This method handles the main events of the menu, such as quitting the game, pressing the escape key, and clicking the mouse button. If a click occurs, it validates the click and performs the player's movement and collision testing. Returns ------- bool False. \"\"\" # Eventos principais deste menu for event in pygame . event . get (): if event . type == pygame . QUIT : pygame . quit () sys . exit () if event . type == pygame . KEYDOWN : if event . key == pygame . K_ESCAPE : pygame . quit () sys . exit () if event . type == pygame . MOUSEBUTTONDOWN : if event . button == 1 and not self . _clicked and self . _player : self . __validate_click () # Se tiver clicado, roda o movimento do jogador ou dos bots e testa colis\u00e3o if self . _clicked and self . _all_riders : self . move_player ( self . _all_riders . sprites ()[ self . _mov_stage ]) self . check_collision ( self . _all_riders . sprites ()[ self . _mov_stage ]) return False def draw ( self , screen ): \"\"\" Draw the game elements on the screen. Parameters ---------- screen : pygame.Surface The surface to draw the game elements on. Returns ------- None \"\"\" # Desenha o tabuleiro no layer mais baixo screen . blit ( self . image , self . rect ) # Desenha as linhas dos riders for rider in self . _all_riders . sprites (): pygame . draw . lines ( screen , rider . _color , False , rider . _path + [ rider . rect . center ], width = 6 ) # Desenha o contorno e as cartas if self . _player : self . choice_preview ( screen ) self . _player . _hand . draw ( screen ) # Faz blit no jogador e nos bots self . _bots . draw ( screen ) self . _player . draw ( screen ) def choice_preview ( self , screen ): \"\"\" Preview the selected card and its path on the screen. Parameters ---------- screen : pygame.Surface The screen surface to draw on. Returns ------- None \"\"\" # Verifica se o mouse est\u00e1 em cima da carta for card in self . _player . _hand . sprites (): if card . update (): # Desenha o contorno self . __preview_selected_card ( card , screen ) # Se n\u00e3o houver clicado antes, mostra a trajet\u00f3ria da carta if not self . _clicked : self . __preview_selected_path ( card , screen ) @staticmethod def __preview_selected_card ( card , screen ): \"\"\" Draw the outline of the selected card. Parameters ---------- card : Card The selected card object. screen : pygame.Surface The screen surface to draw on. Returns ------- None \"\"\" # Desenha o contorno da carta selecionada rect_pos = ( card . rect . left - CARD_SELECTED_WIDTH , card . rect . top - CARD_SELECTED_WIDTH ) rect_size = ( card . rect . width + 2 * CARD_SELECTED_WIDTH , card . rect . height + 2 * CARD_SELECTED_WIDTH ) rectangle = pygame . Rect ( rect_pos , rect_size ) pygame . draw . rect ( screen , \"#258dc2\" , rectangle , width = 2 * CARD_SELECTED_WIDTH ) def __preview_selected_path ( self , card , screen ): \"\"\" Preview the selected path on the screen. Parameters ---------- card : Card The selected card. screen : pygame.Surface The screen surface to draw on. Returns ------- None \"\"\" # Pega o ponto inicial e final da reta start = pygame . Vector2 ( self . _player . _path [ - 1 ]) # Converte para Vector2 card_value = pygame . Vector2 ( card . value [ 0 ], - card . value [ 1 ]) size_segments = 12 # Defina a dist\u00e2ncia desejada entre os segmentos da linha tracejada num_segments = int ( start . distance_to ( start + card_value * DISTANCE ) / size_segments ) # Desenha a linha tracejada for i in range ( 0 , num_segments , 2 ): segment_start = start + card_value * i * DISTANCE / num_segments segment_end = start + card_value * ( i + 1 ) * DISTANCE / num_segments pygame . draw . line ( screen , self . _player . _color , segment_start , segment_end , width = 5 ) def __validate_click ( self ): \"\"\" Verifies if the player clicked on a card and prepares the player's movement. Returns ------- None \"\"\" # Verifica em qual carta clicou player_card = self . __card_clicked () # Se tiver clicado, prepara o movimento do player if player_card : self . _clicked = True self . __next_player_movement ( player_card ) def __card_clicked ( self ): \"\"\" Verifies if a card has been clicked by the player. Returns ------- Card or None: The clicked card if found, None otherwise. \"\"\" # Se o jogador clicar na carta, _clicked = True for card in self . _player . _hand . sprites (): if card . update (): return card return None def move_player ( self , rider ): \"\"\" Move the player's rider. Parameters ---------- rider : Rider The rider object to be moved. Returns ------- None Notes ----- If the rider is able to update its position on the deck, nothing happens. If the rider is unable to update its position, the next player movement is reset. \"\"\" # Move o rider if rider . update ( self . _deck ): pass # Se ficou parado, reseta o movimento else : self . __next_player_movement () def __end_turn ( self ): \"\"\" Reverses the game state and advances the turn. Returns ------- None \"\"\" # S\u00f3 reverte o estado do jogo e adiciona um turno self . _game_turn += 1 self . _clicked = False self . _mov_stage = - 1 # Quando o jogador estiver morto pula sua vez if not self . _player : self . _mov_stage += 1 self . _clicked = True def __next_player_movement ( self , card = None ): \"\"\" Perform the movement of the next player in the game. Parameters ---------- card : Card, optional The card chosen by the player. Defaults to None. Returns ------- None Notes ----- This method is responsible for advancing the game to the next player's movement. If all players have completed their movements, the turn ends. In the rare case of a collision on the first turn, a special action is triggered. If the player is not alive, the bots will play among themselves. If all players are dead, the method returns without further actions. \"\"\" self . _mov_stage += 1 # Se todos jogadores tiverem se movimentado, acaba o turno if self . _mov_stage == len ( self . _all_riders ): self . __end_turn () # No raro caso de colidirem no primeiro turno if self . _game_turn == 1 : self . __first_turn_collision () # Quando o jogador n\u00e3o estiver vivo os bots jogar\u00e3o entre si if self . _player : return # Se todos morrerem tamb\u00e9m retorna if not self . _all_riders : return # Caso contr\u00e1rio, prepara o jogo para rodar mais uma anima\u00e7\u00e3o next_player = self . _all_riders . sprites ()[ self . _mov_stage ] # Se n\u00e3o tiver passado uma carta, faz o rider escolher (em geral um bot) if not card : card = next_player . choose_card ( self . _all_riders ) # Atualiza o estado do pr\u00f3ximo jogador next_player . select_card ( card ) def __first_turn_collision ( self ): \"\"\" Verifies if any rider has collided during the first turn. This method checks if any rider has collided with the border or with other riders during the first turn of the game. If a collision is detected, the corresponding rider is removed from the game. Returns ------- None \"\"\" for rider in self . _all_riders . sprites ()[:: - 1 ]: if utilities . check_border_collision ( rider . rect . center ): rider . kill () continue if utilities . check_line_collision ( self . _all_riders , rider ) and self . _game_turn : rider . kill () continue def check_collision ( self , rider ): \"\"\" Check for collisions between the rider and the game elements. Parameters ---------- rider (Rider): The rider object to check for collisions. Returns ------- None \"\"\" # Testa colis\u00e3o com a fronteira if utilities . check_border_collision ( rider . rect . center ): self . __kill_rider ( rider ) return # Testa colis\u00e3o com as linhas if utilities . check_line_collision ( self . _all_riders , rider ) and self . _game_turn : self . __kill_rider ( rider ) return # Verifica se colidiram entre si #utilities.check_riders_collision(self._player, self._bots) def __kill_rider ( self , rider ): \"\"\" Kills the specified rider and advances the turn. Parameters ---------- rider (Rider): The rider to be killed. Returns ------- None \"\"\" # Mata o rider rider . kill () # Avan\u00e7a o turno self . _mov_stage -= 1 self . __next_player_movement ()","title":"Methods"},{"location":"#src.game.GridGame.__card_clicked","text":"Verifies if a card has been clicked by the player.","title":"__card_clicked()"},{"location":"#src.game.GridGame.__card_clicked--returns","text":"Card or None: The clicked card if found, None otherwise. Source code in src/game.py 278 279 280 281 282 283 284 285 286 287 288 289 290 291 def __card_clicked ( self ): \"\"\" Verifies if a card has been clicked by the player. Returns ------- Card or None: The clicked card if found, None otherwise. \"\"\" # Se o jogador clicar na carta, _clicked = True for card in self . _player . _hand . sprites (): if card . update (): return card return None","title":"Returns"},{"location":"#src.game.GridGame.__end_turn","text":"Reverses the game state and advances the turn.","title":"__end_turn()"},{"location":"#src.game.GridGame.__end_turn--returns","text":"None Source code in src/game.py 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 def __end_turn ( self ): \"\"\" Reverses the game state and advances the turn. Returns ------- None \"\"\" # S\u00f3 reverte o estado do jogo e adiciona um turno self . _game_turn += 1 self . _clicked = False self . _mov_stage = - 1 # Quando o jogador estiver morto pula sua vez if not self . _player : self . _mov_stage += 1 self . _clicked = True","title":"Returns"},{"location":"#src.game.GridGame.__first_turn_collision","text":"Verifies if any rider has collided during the first turn. This method checks if any rider has collided with the border or with other riders during the first turn of the game. If a collision is detected, the corresponding rider is removed from the game.","title":"__first_turn_collision()"},{"location":"#src.game.GridGame.__first_turn_collision--returns","text":"None Source code in src/game.py 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 def __first_turn_collision ( self ): \"\"\" Verifies if any rider has collided during the first turn. This method checks if any rider has collided with the border or with other riders during the first turn of the game. If a collision is detected, the corresponding rider is removed from the game. Returns ------- None \"\"\" for rider in self . _all_riders . sprites ()[:: - 1 ]: if utilities . check_border_collision ( rider . rect . center ): rider . kill () continue if utilities . check_line_collision ( self . _all_riders , rider ) and self . _game_turn : rider . kill () continue","title":"Returns"},{"location":"#src.game.GridGame.__init__","text":"Initializes the Game object.","title":"__init__()"},{"location":"#src.game.GridGame.__init__--parameters","text":"image_path : str The path to the image file. x_y : tuple The x and y coordinates of the game object. scale_size : float The scale size of the game object. bot_number : int The number of bots in the game.","title":"Parameters"},{"location":"#src.game.GridGame.__init__--returns","text":"None Source code in src/game.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 def __init__ ( self , image_path , x_y , scale_size , bot_number ): \"\"\" Initializes the Game object. Parameters ---------- image_path : str The path to the image file. x_y : tuple The x and y coordinates of the game object. scale_size : float The scale size of the game object. bot_number : int The number of bots in the game. Returns ------- None \"\"\" super () . __init__ ( image_path , x_y , scale_size ) # Atributos para o estado do jogo self . next_menu = \"none\" self . _game_turn = 0 self . _mov_stage = - 1 self . _clicked = False # Cria o deck self . _deck = Deck ( TEXTURE_PATH + \"cards/\" , ( CARD_X , CARD_Y )) # Cria o jogador self . _player = Player ( 1 , ( GRID_X / 2 - 1 , GRID_Y / 2 - 2 ), ( RIDER_X , RIDER_Y ), self . _deck ) # Cria os bots __bot_list = [] for bot in range ( bot_number ): __bot_list . append ( Bot ( bot + 2 , ( GRID_X / 2 - 1 , GRID_Y / 2 - 2 ), ( RIDER_X , RIDER_Y ), self . _deck )) self . _bots = pygame . sprite . OrderedUpdates ( __bot_list [:: - 1 ]) # Grupo com todos personagens animados (bots e player) self . _all_riders = pygame . sprite . Group (( self . _player . sprite ()), self . _bots . sprites ()[:: - 1 ])","title":"Returns"},{"location":"#src.game.GridGame.__kill_rider","text":"Kills the specified rider and advances the turn.","title":"__kill_rider()"},{"location":"#src.game.GridGame.__kill_rider--parameters","text":"rider (Rider): The rider to be killed.","title":"Parameters"},{"location":"#src.game.GridGame.__kill_rider--returns","text":"None Source code in src/game.py 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 def __kill_rider ( self , rider ): \"\"\" Kills the specified rider and advances the turn. Parameters ---------- rider (Rider): The rider to be killed. Returns ------- None \"\"\" # Mata o rider rider . kill () # Avan\u00e7a o turno self . _mov_stage -= 1 self . __next_player_movement ()","title":"Returns"},{"location":"#src.game.GridGame.__next_player_movement","text":"Perform the movement of the next player in the game.","title":"__next_player_movement()"},{"location":"#src.game.GridGame.__next_player_movement--parameters","text":"card : Card, optional The card chosen by the player. Defaults to None.","title":"Parameters"},{"location":"#src.game.GridGame.__next_player_movement--returns","text":"None","title":"Returns"},{"location":"#src.game.GridGame.__next_player_movement--notes","text":"This method is responsible for advancing the game to the next player's movement. If all players have completed their movements, the turn ends. In the rare case of a collision on the first turn, a special action is triggered. If the player is not alive, the bots will play among themselves. If all players are dead, the method returns without further actions. Source code in src/game.py 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 def __next_player_movement ( self , card = None ): \"\"\" Perform the movement of the next player in the game. Parameters ---------- card : Card, optional The card chosen by the player. Defaults to None. Returns ------- None Notes ----- This method is responsible for advancing the game to the next player's movement. If all players have completed their movements, the turn ends. In the rare case of a collision on the first turn, a special action is triggered. If the player is not alive, the bots will play among themselves. If all players are dead, the method returns without further actions. \"\"\" self . _mov_stage += 1 # Se todos jogadores tiverem se movimentado, acaba o turno if self . _mov_stage == len ( self . _all_riders ): self . __end_turn () # No raro caso de colidirem no primeiro turno if self . _game_turn == 1 : self . __first_turn_collision () # Quando o jogador n\u00e3o estiver vivo os bots jogar\u00e3o entre si if self . _player : return # Se todos morrerem tamb\u00e9m retorna if not self . _all_riders : return # Caso contr\u00e1rio, prepara o jogo para rodar mais uma anima\u00e7\u00e3o next_player = self . _all_riders . sprites ()[ self . _mov_stage ] # Se n\u00e3o tiver passado uma carta, faz o rider escolher (em geral um bot) if not card : card = next_player . choose_card ( self . _all_riders ) # Atualiza o estado do pr\u00f3ximo jogador next_player . select_card ( card )","title":"Notes"},{"location":"#src.game.GridGame.__preview_selected_card","text":"Draw the outline of the selected card.","title":"__preview_selected_card()"},{"location":"#src.game.GridGame.__preview_selected_card--parameters","text":"card : Card The selected card object. screen : pygame.Surface The screen surface to draw on.","title":"Parameters"},{"location":"#src.game.GridGame.__preview_selected_card--returns","text":"None Source code in src/game.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 @staticmethod def __preview_selected_card ( card , screen ): \"\"\" Draw the outline of the selected card. Parameters ---------- card : Card The selected card object. screen : pygame.Surface The screen surface to draw on. Returns ------- None \"\"\" # Desenha o contorno da carta selecionada rect_pos = ( card . rect . left - CARD_SELECTED_WIDTH , card . rect . top - CARD_SELECTED_WIDTH ) rect_size = ( card . rect . width + 2 * CARD_SELECTED_WIDTH , card . rect . height + 2 * CARD_SELECTED_WIDTH ) rectangle = pygame . Rect ( rect_pos , rect_size ) pygame . draw . rect ( screen , \"#258dc2\" , rectangle , width = 2 * CARD_SELECTED_WIDTH )","title":"Returns"},{"location":"#src.game.GridGame.__preview_selected_path","text":"Preview the selected path on the screen.","title":"__preview_selected_path()"},{"location":"#src.game.GridGame.__preview_selected_path--parameters","text":"card : Card The selected card. screen : pygame.Surface The screen surface to draw on.","title":"Parameters"},{"location":"#src.game.GridGame.__preview_selected_path--returns","text":"None Source code in src/game.py 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 def __preview_selected_path ( self , card , screen ): \"\"\" Preview the selected path on the screen. Parameters ---------- card : Card The selected card. screen : pygame.Surface The screen surface to draw on. Returns ------- None \"\"\" # Pega o ponto inicial e final da reta start = pygame . Vector2 ( self . _player . _path [ - 1 ]) # Converte para Vector2 card_value = pygame . Vector2 ( card . value [ 0 ], - card . value [ 1 ]) size_segments = 12 # Defina a dist\u00e2ncia desejada entre os segmentos da linha tracejada num_segments = int ( start . distance_to ( start + card_value * DISTANCE ) / size_segments ) # Desenha a linha tracejada for i in range ( 0 , num_segments , 2 ): segment_start = start + card_value * i * DISTANCE / num_segments segment_end = start + card_value * ( i + 1 ) * DISTANCE / num_segments pygame . draw . line ( screen , self . _player . _color , segment_start , segment_end , width = 5 )","title":"Returns"},{"location":"#src.game.GridGame.__validate_click","text":"Verifies if the player clicked on a card and prepares the player's movement.","title":"__validate_click()"},{"location":"#src.game.GridGame.__validate_click--returns","text":"None Source code in src/game.py 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 def __validate_click ( self ): \"\"\" Verifies if the player clicked on a card and prepares the player's movement. Returns ------- None \"\"\" # Verifica em qual carta clicou player_card = self . __card_clicked () # Se tiver clicado, prepara o movimento do player if player_card : self . _clicked = True self . __next_player_movement ( player_card )","title":"Returns"},{"location":"#src.game.GridGame.check_collision","text":"Check for collisions between the rider and the game elements.","title":"check_collision()"},{"location":"#src.game.GridGame.check_collision--parameters","text":"rider (Rider): The rider object to check for collisions.","title":"Parameters"},{"location":"#src.game.GridGame.check_collision--returns","text":"None Source code in src/game.py 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 def check_collision ( self , rider ): \"\"\" Check for collisions between the rider and the game elements. Parameters ---------- rider (Rider): The rider object to check for collisions. Returns ------- None \"\"\" # Testa colis\u00e3o com a fronteira if utilities . check_border_collision ( rider . rect . center ): self . __kill_rider ( rider ) return # Testa colis\u00e3o com as linhas if utilities . check_line_collision ( self . _all_riders , rider ) and self . _game_turn : self . __kill_rider ( rider ) return","title":"Returns"},{"location":"#src.game.GridGame.choice_preview","text":"Preview the selected card and its path on the screen.","title":"choice_preview()"},{"location":"#src.game.GridGame.choice_preview--parameters","text":"screen : pygame.Surface The screen surface to draw on.","title":"Parameters"},{"location":"#src.game.GridGame.choice_preview--returns","text":"None Source code in src/game.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 def choice_preview ( self , screen ): \"\"\" Preview the selected card and its path on the screen. Parameters ---------- screen : pygame.Surface The screen surface to draw on. Returns ------- None \"\"\" # Verifica se o mouse est\u00e1 em cima da carta for card in self . _player . _hand . sprites (): if card . update (): # Desenha o contorno self . __preview_selected_card ( card , screen ) # Se n\u00e3o houver clicado antes, mostra a trajet\u00f3ria da carta if not self . _clicked : self . __preview_selected_path ( card , screen )","title":"Returns"},{"location":"#src.game.GridGame.draw","text":"Draw the game elements on the screen.","title":"draw()"},{"location":"#src.game.GridGame.draw--parameters","text":"screen : pygame.Surface The surface to draw the game elements on.","title":"Parameters"},{"location":"#src.game.GridGame.draw--returns","text":"None Source code in src/game.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 def draw ( self , screen ): \"\"\" Draw the game elements on the screen. Parameters ---------- screen : pygame.Surface The surface to draw the game elements on. Returns ------- None \"\"\" # Desenha o tabuleiro no layer mais baixo screen . blit ( self . image , self . rect ) # Desenha as linhas dos riders for rider in self . _all_riders . sprites (): pygame . draw . lines ( screen , rider . _color , False , rider . _path + [ rider . rect . center ], width = 6 ) # Desenha o contorno e as cartas if self . _player : self . choice_preview ( screen ) self . _player . _hand . draw ( screen ) # Faz blit no jogador e nos bots self . _bots . draw ( screen ) self . _player . draw ( screen )","title":"Returns"},{"location":"#src.game.GridGame.move_player","text":"Move the player's rider.","title":"move_player()"},{"location":"#src.game.GridGame.move_player--parameters","text":"rider : Rider The rider object to be moved.","title":"Parameters"},{"location":"#src.game.GridGame.move_player--returns","text":"None","title":"Returns"},{"location":"#src.game.GridGame.move_player--notes","text":"If the rider is able to update its position on the deck, nothing happens. If the rider is unable to update its position, the next player movement is reset. Source code in src/game.py 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 def move_player ( self , rider ): \"\"\" Move the player's rider. Parameters ---------- rider : Rider The rider object to be moved. Returns ------- None Notes ----- If the rider is able to update its position on the deck, nothing happens. If the rider is unable to update its position, the next player movement is reset. \"\"\" # Move o rider if rider . update ( self . _deck ): pass # Se ficou parado, reseta o movimento else : self . __next_player_movement ()","title":"Notes"},{"location":"#src.game.GridGame.update","text":"Update the game state. This method handles the main events of the menu, such as quitting the game, pressing the escape key, and clicking the mouse button. If a click occurs, it validates the click and performs the player's movement and collision testing.","title":"update()"},{"location":"#src.game.GridGame.update--returns","text":"bool False. Source code in src/game.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 def update ( self ): \"\"\" Update the game state. This method handles the main events of the menu, such as quitting the game, pressing the escape key, and clicking the mouse button. If a click occurs, it validates the click and performs the player's movement and collision testing. Returns ------- bool False. \"\"\" # Eventos principais deste menu for event in pygame . event . get (): if event . type == pygame . QUIT : pygame . quit () sys . exit () if event . type == pygame . KEYDOWN : if event . key == pygame . K_ESCAPE : pygame . quit () sys . exit () if event . type == pygame . MOUSEBUTTONDOWN : if event . button == 1 and not self . _clicked and self . _player : self . __validate_click () # Se tiver clicado, roda o movimento do jogador ou dos bots e testa colis\u00e3o if self . _clicked and self . _all_riders : self . move_player ( self . _all_riders . sprites ()[ self . _mov_stage ]) self . check_collision ( self . _all_riders . sprites ()[ self . _mov_stage ]) return False","title":"Returns"},{"location":"#src.menu.Button","text":"Bases: Entity Represents a menu button.","title":"Button"},{"location":"#src.menu.Button--attributes","text":"label : str The label for the menu. rect : Rect The rectangle that represents the menu's position and size. selected : bool Indicates whether the menu is selected or not.","title":"Attributes"},{"location":"#src.menu.Button--methods","text":"init (self, image_path, x_y, scale_size, label) Initializes a Menu object. update(self) Update the state of the menu. Source code in src/menu.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class Button ( Entity ): \"\"\" Represents a menu button. Attributes ---------- label : str The label for the menu. rect : Rect The rectangle that represents the menu's position and size. selected : bool Indicates whether the menu is selected or not. Methods ------- __init__(self, image_path, x_y, scale_size, label) Initializes a Menu object. update(self) Update the state of the menu. \"\"\" def __init__ ( self , image_path , x_y , scale_size , label ): \"\"\" Initializes a Menu object. Parameters ---------- image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu. label : str The label for the menu. Returns ------- None \"\"\" super () . __init__ ( image_path , x_y , scale_size ) self . label = label self . rect = self . image . get_rect ( center = x_y ) self . selected = False def update ( self ): \"\"\" Update the state of the menu. Check for collision with the mouse and return True if there is a collision, otherwise return False. Returns ------- bool True if there is a collision with the mouse, False otherwise. \"\"\" mouse_pos = pygame . mouse . get_pos () is_over = self . rect . collidepoint ( mouse_pos ) if is_over : return True else : return False","title":"Methods"},{"location":"#src.menu.Button.__init__","text":"Initializes a Menu object.","title":"__init__()"},{"location":"#src.menu.Button.__init__--parameters","text":"image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu. label : str The label for the menu.","title":"Parameters"},{"location":"#src.menu.Button.__init__--returns","text":"None Source code in src/menu.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 def __init__ ( self , image_path , x_y , scale_size , label ): \"\"\" Initializes a Menu object. Parameters ---------- image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu. label : str The label for the menu. Returns ------- None \"\"\" super () . __init__ ( image_path , x_y , scale_size ) self . label = label self . rect = self . image . get_rect ( center = x_y ) self . selected = False","title":"Returns"},{"location":"#src.menu.Button.update","text":"Update the state of the menu. Check for collision with the mouse and return True if there is a collision, otherwise return False.","title":"update()"},{"location":"#src.menu.Button.update--returns","text":"bool True if there is a collision with the mouse, False otherwise. Source code in src/menu.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def update ( self ): \"\"\" Update the state of the menu. Check for collision with the mouse and return True if there is a collision, otherwise return False. Returns ------- bool True if there is a collision with the mouse, False otherwise. \"\"\" mouse_pos = pygame . mouse . get_pos () is_over = self . rect . collidepoint ( mouse_pos ) if is_over : return True else : return False","title":"Returns"},{"location":"#src.menu.CreditsMenu","text":"Bases: Menu Represents the credits menu.","title":"CreditsMenu"},{"location":"#src.menu.CreditsMenu--attributes","text":"next_state : str The next state to transition to. font_size : list The font sizes for the menu. space_size : list The space sizes for the menu. txt_x : int The x coordinate of the text. txt_y : int The y coordinate of the text. background_image : Surface The background image for the menu. btn_back : Button The button to transition to the main menu. buttons_group : Group The group of buttons for the menu.","title":"Attributes"},{"location":"#src.menu.CreditsMenu--methods","text":"init (self, game, image_path, x_y, scale_size) Initializes a CreditsMenu object. display_menu(self) Display the credits menu. check_input(self) Check the input for the menu. Source code in src/menu.py 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 class CreditsMenu ( Menu ): \"\"\" Represents the credits menu. Attributes ---------- next_state : str The next state to transition to. font_size : list The font sizes for the menu. space_size : list The space sizes for the menu. txt_x : int The x coordinate of the text. txt_y : int The y coordinate of the text. background_image : Surface The background image for the menu. btn_back : Button The button to transition to the main menu. buttons_group : Group The group of buttons for the menu. Methods ------- __init__(self, game, image_path, x_y, scale_size) Initializes a CreditsMenu object. display_menu(self) Display the credits menu. check_input(self) Check the input for the menu. \"\"\" def __init__ ( self , game , image_path , x_y , scale_size ): \"\"\" Initializes a CreditsMenu object. Parameters ---------- game : Game The game object that controls the menu. image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu. Returns ------- None \"\"\" super () . __init__ ( game , image_path , x_y , scale_size ) self . next_state = \"main_menu\" # Define vari\u00e1veis com valores recorrentes no menu self . font_size = [ 25 , 30 , 40 ] self . space_size = [ 40 , 27 ] self . txt_x = WIDTH / 2 self . txt_y = HEIGHT / 4 + self . space_size [ 1 ] # Carrega a imagem da tela de fundo self . background_image = pygame . image . load ( TEXTURE_PATH + \"background_credits.png\" ) . convert () # Define os bot\u00f5es dessa tela self . btn_back = Button ( TEXTURE_PATH + \"back_button.png\" , ( WIDTH / 2 , ( HEIGHT - 100 )), ( BUTTON_X , BUTTON_Y ), \"main_menu\" ) # Adiciona os bot\u00f5es a um grupo self . buttons_group . add ( self . btn_back ) def display_menu ( self ): \"\"\" Display the credits menu. Returns ------- None \"\"\" self . run_display = True while self . run_display : # Exibe o plano de fundo da tela self . state_control . screen . blit ( self . background_image , ( 0 , 0 )) #Verifica as entradas e intera\u00e7\u00e3o com os bot\u00f5es self . verify () # Exibe a imagem \"credits\" self . state_control . screen . blit ( self . image , self . rect ) # Insere os bot\u00f5es na tela: self . buttons_group . draw ( self . state_control . screen ) # Desenha os textos na tela self . draw_text ( \"A2 - LP - 2023\" , self . font_size [ 2 ], self . txt_x , self . txt_y ) self . draw_text ( \"- Code by:\" , self . font_size [ 1 ], self . txt_x , ( self . txt_y + 2 * self . space_size [ 0 ])) self . draw_text ( \"Beatriz Miranda Bezerra\" , self . font_size [ 0 ], self . txt_x , ( self . txt_y + 3 * self . space_size [ 0 ])) self . draw_text ( \"Gustavo Murilo Cavalcante Carvalho\" , self . font_size [ 0 ], self . txt_x , ( self . txt_y + 4 * self . space_size [ 0 ])) self . draw_text ( \"Henzo Felipe Carvalho de Mattos\" , self . font_size [ 0 ], self . txt_x , ( self . txt_y + 5 * self . space_size [ 0 ])) self . draw_text ( \"- Art and Concept granted by:\" , self . font_size [ 1 ], self . txt_x , ( self . txt_y + 7 * self . space_size [ 0 ])) self . draw_text ( \"Tulio Kone\u00e7ny\" , self . font_size [ 0 ], self . txt_x , ( self . txt_y + 8 * self . space_size [ 0 ])) self . update () def check_input ( self ): \"\"\" Check the input for the menu. Returns ------- None \"\"\" if self . state_control . ESC_KEY : self . state_control . curr_menu = self . state_control . main_menu self . run_display = False if self . state_control . BACK_KEY : self . state_control . curr_menu = self . state_control . main_menu self . run_display = False if self . state_control . START_KEY or self . state_control . BUTTON_CLICKED : if self . next_state == \"main_menu\" : self . state_control . curr_menu = self . state_control . main_menu self . run_display = False","title":"Methods"},{"location":"#src.menu.CreditsMenu.__init__","text":"Initializes a CreditsMenu object.","title":"__init__()"},{"location":"#src.menu.CreditsMenu.__init__--parameters","text":"game : Game The game object that controls the menu. image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu.","title":"Parameters"},{"location":"#src.menu.CreditsMenu.__init__--returns","text":"None Source code in src/menu.py 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 def __init__ ( self , game , image_path , x_y , scale_size ): \"\"\" Initializes a CreditsMenu object. Parameters ---------- game : Game The game object that controls the menu. image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu. Returns ------- None \"\"\" super () . __init__ ( game , image_path , x_y , scale_size ) self . next_state = \"main_menu\" # Define vari\u00e1veis com valores recorrentes no menu self . font_size = [ 25 , 30 , 40 ] self . space_size = [ 40 , 27 ] self . txt_x = WIDTH / 2 self . txt_y = HEIGHT / 4 + self . space_size [ 1 ] # Carrega a imagem da tela de fundo self . background_image = pygame . image . load ( TEXTURE_PATH + \"background_credits.png\" ) . convert () # Define os bot\u00f5es dessa tela self . btn_back = Button ( TEXTURE_PATH + \"back_button.png\" , ( WIDTH / 2 , ( HEIGHT - 100 )), ( BUTTON_X , BUTTON_Y ), \"main_menu\" ) # Adiciona os bot\u00f5es a um grupo self . buttons_group . add ( self . btn_back )","title":"Returns"},{"location":"#src.menu.CreditsMenu.check_input","text":"Check the input for the menu.","title":"check_input()"},{"location":"#src.menu.CreditsMenu.check_input--returns","text":"None Source code in src/menu.py 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 def check_input ( self ): \"\"\" Check the input for the menu. Returns ------- None \"\"\" if self . state_control . ESC_KEY : self . state_control . curr_menu = self . state_control . main_menu self . run_display = False if self . state_control . BACK_KEY : self . state_control . curr_menu = self . state_control . main_menu self . run_display = False if self . state_control . START_KEY or self . state_control . BUTTON_CLICKED : if self . next_state == \"main_menu\" : self . state_control . curr_menu = self . state_control . main_menu self . run_display = False","title":"Returns"},{"location":"#src.menu.CreditsMenu.display_menu","text":"Display the credits menu.","title":"display_menu()"},{"location":"#src.menu.CreditsMenu.display_menu--returns","text":"None Source code in src/menu.py 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 def display_menu ( self ): \"\"\" Display the credits menu. Returns ------- None \"\"\" self . run_display = True while self . run_display : # Exibe o plano de fundo da tela self . state_control . screen . blit ( self . background_image , ( 0 , 0 )) #Verifica as entradas e intera\u00e7\u00e3o com os bot\u00f5es self . verify () # Exibe a imagem \"credits\" self . state_control . screen . blit ( self . image , self . rect ) # Insere os bot\u00f5es na tela: self . buttons_group . draw ( self . state_control . screen ) # Desenha os textos na tela self . draw_text ( \"A2 - LP - 2023\" , self . font_size [ 2 ], self . txt_x , self . txt_y ) self . draw_text ( \"- Code by:\" , self . font_size [ 1 ], self . txt_x , ( self . txt_y + 2 * self . space_size [ 0 ])) self . draw_text ( \"Beatriz Miranda Bezerra\" , self . font_size [ 0 ], self . txt_x , ( self . txt_y + 3 * self . space_size [ 0 ])) self . draw_text ( \"Gustavo Murilo Cavalcante Carvalho\" , self . font_size [ 0 ], self . txt_x , ( self . txt_y + 4 * self . space_size [ 0 ])) self . draw_text ( \"Henzo Felipe Carvalho de Mattos\" , self . font_size [ 0 ], self . txt_x , ( self . txt_y + 5 * self . space_size [ 0 ])) self . draw_text ( \"- Art and Concept granted by:\" , self . font_size [ 1 ], self . txt_x , ( self . txt_y + 7 * self . space_size [ 0 ])) self . draw_text ( \"Tulio Kone\u00e7ny\" , self . font_size [ 0 ], self . txt_x , ( self . txt_y + 8 * self . space_size [ 0 ])) self . update ()","title":"Returns"},{"location":"#src.menu.MainMenu","text":"Bases: Menu Represents the main menu.","title":"MainMenu"},{"location":"#src.menu.MainMenu--attributes","text":"next_state : str The next state to transition to. start_x : int The x coordinate of the start button. start_y : int The y coordinate of the start button. options_x : int The x coordinate of the options button. options_y : int The y coordinate of the options button. credits_x : int The x coordinate of the credits button. credits_y : int The y coordinate of the credits button. btn_the_grid : Button The button to transition to the grid. btn_options : Button The button to transition to the options menu. btn_credits : Button The button to transition to the credits menu. buttons_group : Group The group of buttons for the menu.","title":"Attributes"},{"location":"#src.menu.MainMenu--methods","text":"init (self, game, image_path, x_y, scale_size) Initializes a MainMenu object. display_menu(self) Display the main menu. check_input(self) Check the input for the menu. Source code in src/menu.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 class MainMenu ( Menu ): \"\"\" Represents the main menu. Attributes ---------- next_state : str The next state to transition to. start_x : int The x coordinate of the start button. start_y : int The y coordinate of the start button. options_x : int The x coordinate of the options button. options_y : int The y coordinate of the options button. credits_x : int The x coordinate of the credits button. credits_y : int The y coordinate of the credits button. btn_the_grid : Button The button to transition to the grid. btn_options : Button The button to transition to the options menu. btn_credits : Button The button to transition to the credits menu. buttons_group : Group The group of buttons for the menu. Methods ------- __init__(self, game, image_path, x_y, scale_size) Initializes a MainMenu object. display_menu(self) Display the main menu. check_input(self) Check the input for the menu. \"\"\" def __init__ ( self , game , image_path , x_y , scale_size ): \"\"\" Initializes a MainMenu object. Parameters ---------- game : Game The game object that controls the menu. image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu. Returns ------- None \"\"\" super () . __init__ ( game , image_path , x_y , scale_size ) self . next_state = \"the_grid\" # Posi\u00e7\u00f5es para os elementos na tela self . start_x , self . start_y = ( WIDTH / 2 ), ( HEIGHT / 2 ) self . options_x , self . options_y = ( WIDTH / 2 ), ( HEIGHT / 2 + 100 ) self . credits_x , self . credits_y = ( WIDTH / 2 ), ( HEIGHT / 2 + 200 ) # Define os bot\u00f5es dessa tela self . btn_the_grid = Button ( TEXTURE_PATH + \"grid_logo.png\" , ( self . start_x , self . start_y ), ( BUTTON_X , BUTTON_Y ), \"the_grid\" ) self . btn_options = Button ( TEXTURE_PATH + \"options_button.png\" , ( self . options_x , self . options_y ), ( BUTTON_X , BUTTON_Y ), \"options_menu\" ) self . btn_credits = Button ( TEXTURE_PATH + \"credits_button.png\" , ( self . credits_x , self . credits_y ), ( BUTTON_X , BUTTON_Y ), \"credits_menu\" ) # Adiciona os bot\u00f5es a um grupo self . buttons_group = pygame . sprite . Group ( self . btn_the_grid , self . btn_options , self . btn_credits ) def display_menu ( self ): \"\"\" Display the main menu. Returns ------- None \"\"\" self . run_display = True while self . run_display : # Preenche o fundo self . state_control . screen . fill ( BLACK ) #Verifica as entradas e intera\u00e7\u00e3o com os bot\u00f5es self . verify () # Exibie o logo do jogo self . state_control . screen . blit ( self . image , self . rect ) # Insere os bot\u00f5es na tela: self . buttons_group . draw ( self . state_control . screen ) self . update () def check_input ( self ): \"\"\" Check the input for the menu. Returns ------- None \"\"\" if self . state_control . ESC_KEY : self . state_control . running = False self . state_control . curr_menu . run_display = False # Checa os cliques em bot\u00f5es if self . state_control . START_KEY or self . state_control . BUTTON_CLICKED : if self . next_state == \"the_grid\" : self . state_control . playing = True elif self . next_state == \"options_menu\" : self . state_control . curr_menu = self . state_control . options_menu elif self . next_state == \"credits_menu\" : self . state_control . curr_menu = self . state_control . credits_menu self . run_display = False","title":"Methods"},{"location":"#src.menu.MainMenu.__init__","text":"Initializes a MainMenu object.","title":"__init__()"},{"location":"#src.menu.MainMenu.__init__--parameters","text":"game : Game The game object that controls the menu. image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu.","title":"Parameters"},{"location":"#src.menu.MainMenu.__init__--returns","text":"None Source code in src/menu.py 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 def __init__ ( self , game , image_path , x_y , scale_size ): \"\"\" Initializes a MainMenu object. Parameters ---------- game : Game The game object that controls the menu. image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu. Returns ------- None \"\"\" super () . __init__ ( game , image_path , x_y , scale_size ) self . next_state = \"the_grid\" # Posi\u00e7\u00f5es para os elementos na tela self . start_x , self . start_y = ( WIDTH / 2 ), ( HEIGHT / 2 ) self . options_x , self . options_y = ( WIDTH / 2 ), ( HEIGHT / 2 + 100 ) self . credits_x , self . credits_y = ( WIDTH / 2 ), ( HEIGHT / 2 + 200 ) # Define os bot\u00f5es dessa tela self . btn_the_grid = Button ( TEXTURE_PATH + \"grid_logo.png\" , ( self . start_x , self . start_y ), ( BUTTON_X , BUTTON_Y ), \"the_grid\" ) self . btn_options = Button ( TEXTURE_PATH + \"options_button.png\" , ( self . options_x , self . options_y ), ( BUTTON_X , BUTTON_Y ), \"options_menu\" ) self . btn_credits = Button ( TEXTURE_PATH + \"credits_button.png\" , ( self . credits_x , self . credits_y ), ( BUTTON_X , BUTTON_Y ), \"credits_menu\" ) # Adiciona os bot\u00f5es a um grupo self . buttons_group = pygame . sprite . Group ( self . btn_the_grid , self . btn_options , self . btn_credits )","title":"Returns"},{"location":"#src.menu.MainMenu.check_input","text":"Check the input for the menu.","title":"check_input()"},{"location":"#src.menu.MainMenu.check_input--returns","text":"None Source code in src/menu.py 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 def check_input ( self ): \"\"\" Check the input for the menu. Returns ------- None \"\"\" if self . state_control . ESC_KEY : self . state_control . running = False self . state_control . curr_menu . run_display = False # Checa os cliques em bot\u00f5es if self . state_control . START_KEY or self . state_control . BUTTON_CLICKED : if self . next_state == \"the_grid\" : self . state_control . playing = True elif self . next_state == \"options_menu\" : self . state_control . curr_menu = self . state_control . options_menu elif self . next_state == \"credits_menu\" : self . state_control . curr_menu = self . state_control . credits_menu self . run_display = False","title":"Returns"},{"location":"#src.menu.MainMenu.display_menu","text":"Display the main menu.","title":"display_menu()"},{"location":"#src.menu.MainMenu.display_menu--returns","text":"None Source code in src/menu.py 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 def display_menu ( self ): \"\"\" Display the main menu. Returns ------- None \"\"\" self . run_display = True while self . run_display : # Preenche o fundo self . state_control . screen . fill ( BLACK ) #Verifica as entradas e intera\u00e7\u00e3o com os bot\u00f5es self . verify () # Exibie o logo do jogo self . state_control . screen . blit ( self . image , self . rect ) # Insere os bot\u00f5es na tela: self . buttons_group . draw ( self . state_control . screen ) self . update ()","title":"Returns"},{"location":"#src.menu.Menu","text":"Bases: Entity Represents a menu.","title":"Menu"},{"location":"#src.menu.Menu--attributes","text":"state_control : Game The game object that controls the menu. rect : Rect The rectangle that represents the menu's position and size. run_display : bool Indicates whether the menu is running or not. button_clicked : bool Indicates whether a button was clicked or not. selected_button : Button The button that was selected. buttons_group : Group The group of buttons for the menu.","title":"Attributes"},{"location":"#src.menu.Menu--methods","text":"init (self, game, image_path, x_y, scale_size) Initializes a Menu object. draw_text(self, text, size, x, y) Draw text on the screen. update(self) Update the state of the menu. verify(self) Verify the state of the menu. choice_preview(self, screen) Preview the selected choice. __preview_selected_button(self, button, screen) Preview the selected button. check_input(self) Check the input for the menu. Source code in src/menu.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 class Menu ( Entity ): \"\"\" Represents a menu. Attributes ---------- state_control : Game The game object that controls the menu. rect : Rect The rectangle that represents the menu's position and size. run_display : bool Indicates whether the menu is running or not. button_clicked : bool Indicates whether a button was clicked or not. selected_button : Button The button that was selected. buttons_group : Group The group of buttons for the menu. Methods ------- __init__(self, game, image_path, x_y, scale_size) Initializes a Menu object. draw_text(self, text, size, x, y) Draw text on the screen. update(self) Update the state of the menu. verify(self) Verify the state of the menu. choice_preview(self, screen) Preview the selected choice. __preview_selected_button(self, button, screen) Preview the selected button. check_input(self) Check the input for the menu. \"\"\" def __init__ ( self , game , image_path , x_y , scale_size ): \"\"\" Initializes a Menu object. Parameters ---------- game : Game The game object that controls the menu. image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu. Returns ------- None \"\"\" super () . __init__ ( image_path , x_y , scale_size ) self . state_control = game self . rect = self . image . get_rect ( center = x_y ) # Define vari\u00e1veis de controle self . run_display = True self . button_clicked = False self . selected_button = None # Cria um grupo para os sprites self . buttons_group = pygame . sprite . Group () def draw_text ( self , text , size , x , y ): \"\"\" Draw text on the screen. Parameters ---------- text : str The text to draw. size : int The size of the text. x : int The x coordinate of the text. y : int The y coordinate of the text. Returns ------- None \"\"\" self . font_name = pygame . font . get_default_font () font = pygame . font . Font ( self . font_name , size ) text_surface = font . render ( text , True , WHITE ) text_rect = text_surface . get_rect () text_rect . center = ( x , y ) self . state_control . screen . blit ( text_surface , text_rect ) def update ( self ): \"\"\" Update the state of the menu. Returns ------- None \"\"\" pygame . display . update () self . state_control . reset_keys () def verify ( self ): \"\"\" Verify the state of the menu. Returns ------- None \"\"\" self . state_control . check_events () self . choice_preview ( self . state_control . screen ) self . check_input () def choice_preview ( self , screen ): \"\"\" Preview the selected choice. Parameters ---------- screen : Surface The screen to preview the selected choice. Returns ------- None \"\"\" # Verifica se o mouse est\u00e1 em cima da carta for button in self . buttons_group : if button . update (): # Seleciona a tela equivalente ao bot\u00e3o self . next_state = button . label # Desenha o contorno self . __preview_selected_button ( button , screen ) # Verifica se o bot\u00e3o esquerdo do mouse \u00e9 pressionado mouse_clicked = pygame . mouse . get_pressed ()[ 0 ] if mouse_clicked or self . state_control . START_KEY : self . state_control . BUTTON_CLICKED = True # Delay para evitar cliques indesejados pygame . time . delay ( 170 ) return None @staticmethod def __preview_selected_button ( button , screen ): \"\"\" Preview the selected button. Parameters ---------- button : Button The button to preview. screen : Surface The screen to preview the button. Returns ------- None \"\"\" # Desenha o contorno do bot\u00e3o selecionado rect_pos = ( button . rect . left - BUTTON_SELECTED_WIDTH , button . rect . top - BUTTON_SELECTED_WIDTH ) rect_size = ( button . rect . width + 2 * BUTTON_SELECTED_WIDTH , button . rect . height + 2 * BUTTON_SELECTED_WIDTH ) rectangle = pygame . Rect ( rect_pos , rect_size ) pygame . draw . rect ( screen , RED , rectangle , width = 2 * BUTTON_SELECTED_WIDTH ) def check_input ( self ): \"\"\" Check the input for the menu. Returns ------- None \"\"\" pass","title":"Methods"},{"location":"#src.menu.Menu.__init__","text":"Initializes a Menu object.","title":"__init__()"},{"location":"#src.menu.Menu.__init__--parameters","text":"game : Game The game object that controls the menu. image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu.","title":"Parameters"},{"location":"#src.menu.Menu.__init__--returns","text":"None Source code in src/menu.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 def __init__ ( self , game , image_path , x_y , scale_size ): \"\"\" Initializes a Menu object. Parameters ---------- game : Game The game object that controls the menu. image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu. Returns ------- None \"\"\" super () . __init__ ( image_path , x_y , scale_size ) self . state_control = game self . rect = self . image . get_rect ( center = x_y ) # Define vari\u00e1veis de controle self . run_display = True self . button_clicked = False self . selected_button = None # Cria um grupo para os sprites self . buttons_group = pygame . sprite . Group ()","title":"Returns"},{"location":"#src.menu.Menu.__preview_selected_button","text":"Preview the selected button.","title":"__preview_selected_button()"},{"location":"#src.menu.Menu.__preview_selected_button--parameters","text":"button : Button The button to preview. screen : Surface The screen to preview the button.","title":"Parameters"},{"location":"#src.menu.Menu.__preview_selected_button--returns","text":"None Source code in src/menu.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 @staticmethod def __preview_selected_button ( button , screen ): \"\"\" Preview the selected button. Parameters ---------- button : Button The button to preview. screen : Surface The screen to preview the button. Returns ------- None \"\"\" # Desenha o contorno do bot\u00e3o selecionado rect_pos = ( button . rect . left - BUTTON_SELECTED_WIDTH , button . rect . top - BUTTON_SELECTED_WIDTH ) rect_size = ( button . rect . width + 2 * BUTTON_SELECTED_WIDTH , button . rect . height + 2 * BUTTON_SELECTED_WIDTH ) rectangle = pygame . Rect ( rect_pos , rect_size ) pygame . draw . rect ( screen , RED , rectangle , width = 2 * BUTTON_SELECTED_WIDTH )","title":"Returns"},{"location":"#src.menu.Menu.check_input","text":"Check the input for the menu.","title":"check_input()"},{"location":"#src.menu.Menu.check_input--returns","text":"None Source code in src/menu.py 242 243 244 245 246 247 248 249 250 def check_input ( self ): \"\"\" Check the input for the menu. Returns ------- None \"\"\" pass","title":"Returns"},{"location":"#src.menu.Menu.choice_preview","text":"Preview the selected choice.","title":"choice_preview()"},{"location":"#src.menu.Menu.choice_preview--parameters","text":"screen : Surface The screen to preview the selected choice.","title":"Parameters"},{"location":"#src.menu.Menu.choice_preview--returns","text":"None Source code in src/menu.py 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 def choice_preview ( self , screen ): \"\"\" Preview the selected choice. Parameters ---------- screen : Surface The screen to preview the selected choice. Returns ------- None \"\"\" # Verifica se o mouse est\u00e1 em cima da carta for button in self . buttons_group : if button . update (): # Seleciona a tela equivalente ao bot\u00e3o self . next_state = button . label # Desenha o contorno self . __preview_selected_button ( button , screen ) # Verifica se o bot\u00e3o esquerdo do mouse \u00e9 pressionado mouse_clicked = pygame . mouse . get_pressed ()[ 0 ] if mouse_clicked or self . state_control . START_KEY : self . state_control . BUTTON_CLICKED = True # Delay para evitar cliques indesejados pygame . time . delay ( 170 ) return None","title":"Returns"},{"location":"#src.menu.Menu.draw_text","text":"Draw text on the screen.","title":"draw_text()"},{"location":"#src.menu.Menu.draw_text--parameters","text":"text : str The text to draw. size : int The size of the text. x : int The x coordinate of the text. y : int The y coordinate of the text.","title":"Parameters"},{"location":"#src.menu.Menu.draw_text--returns","text":"None Source code in src/menu.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 def draw_text ( self , text , size , x , y ): \"\"\" Draw text on the screen. Parameters ---------- text : str The text to draw. size : int The size of the text. x : int The x coordinate of the text. y : int The y coordinate of the text. Returns ------- None \"\"\" self . font_name = pygame . font . get_default_font () font = pygame . font . Font ( self . font_name , size ) text_surface = font . render ( text , True , WHITE ) text_rect = text_surface . get_rect () text_rect . center = ( x , y ) self . state_control . screen . blit ( text_surface , text_rect )","title":"Returns"},{"location":"#src.menu.Menu.update","text":"Update the state of the menu.","title":"update()"},{"location":"#src.menu.Menu.update--returns","text":"None Source code in src/menu.py 164 165 166 167 168 169 170 171 172 173 def update ( self ): \"\"\" Update the state of the menu. Returns ------- None \"\"\" pygame . display . update () self . state_control . reset_keys ()","title":"Returns"},{"location":"#src.menu.Menu.verify","text":"Verify the state of the menu.","title":"verify()"},{"location":"#src.menu.Menu.verify--returns","text":"None Source code in src/menu.py 175 176 177 178 179 180 181 182 183 184 185 def verify ( self ): \"\"\" Verify the state of the menu. Returns ------- None \"\"\" self . state_control . check_events () self . choice_preview ( self . state_control . screen ) self . check_input ()","title":"Returns"},{"location":"#src.menu.OptionsMenu","text":"Bases: Menu Represents the options menu.","title":"OptionsMenu"},{"location":"#src.menu.OptionsMenu--attributes","text":"next_state : str The next state to transition to. btn_back : Button The button to transition to the main menu. buttons_group : Group The group of buttons for the menu.","title":"Attributes"},{"location":"#src.menu.OptionsMenu--methods","text":"init (self, game, image_path, x_y, scale_size) Initializes a OptionsMenu object. display_menu(self) Display the options menu. check_input(self) Check the input for the menu. Source code in src/menu.py 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 class OptionsMenu ( Menu ): \"\"\" Represents the options menu. Attributes ---------- next_state : str The next state to transition to. btn_back : Button The button to transition to the main menu. buttons_group : Group The group of buttons for the menu. Methods ------- __init__(self, game, image_path, x_y, scale_size) Initializes a OptionsMenu object. display_menu(self) Display the options menu. check_input(self) Check the input for the menu. \"\"\" def __init__ ( self , game , image_path , x_y , scale_size ): \"\"\" Initializes a OptionsMenu object. Parameters ---------- game : Game The game object that controls the menu. image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu. Returns ------- None \"\"\" super () . __init__ ( game , image_path , x_y , scale_size ) self . next_state = \"main_menu\" # Define os bot\u00f5es dessa tela self . btn_back = Button ( TEXTURE_PATH + \"back_button.png\" , ( WIDTH / 2 , ( HEIGHT - 100 )), ( BUTTON_X , BUTTON_Y ), \"main_menu\" ) # Adiciona os bot\u00f5es a um grupo self . buttons_group . add ( self . btn_back ) def display_menu ( self ): \"\"\" Display the options menu. Returns ------- None \"\"\" self . run_display = True while self . run_display : self . state_control . screen . fill ( BLACK ) # Verifica as entradas e intera\u00e7\u00e3o com os bot\u00f5es self . verify () # Exibe a imagem \"Options\" self . state_control . screen . blit ( self . image , self . rect ) # Insere os bot\u00f5es na tela: self . buttons_group . draw ( self . state_control . screen ) self . update () def check_input ( self ): \"\"\" Check the input for the menu. Returns ------- None \"\"\" if self . state_control . ESC_KEY : self . state_control . curr_menu = self . state_control . main_menu self . run_display = False if self . state_control . BACK_KEY : self . state_control . curr_menu = self . state_control . main_menu self . run_display = False if self . state_control . START_KEY or self . state_control . BUTTON_CLICKED : if self . next_state == \"main_menu\" : self . state_control . curr_menu = self . state_control . main_menu self . run_display = False","title":"Methods"},{"location":"#src.menu.OptionsMenu.__init__","text":"Initializes a OptionsMenu object.","title":"__init__()"},{"location":"#src.menu.OptionsMenu.__init__--parameters","text":"game : Game The game object that controls the menu. image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu.","title":"Parameters"},{"location":"#src.menu.OptionsMenu.__init__--returns","text":"None Source code in src/menu.py 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 def __init__ ( self , game , image_path , x_y , scale_size ): \"\"\" Initializes a OptionsMenu object. Parameters ---------- game : Game The game object that controls the menu. image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu. Returns ------- None \"\"\" super () . __init__ ( game , image_path , x_y , scale_size ) self . next_state = \"main_menu\" # Define os bot\u00f5es dessa tela self . btn_back = Button ( TEXTURE_PATH + \"back_button.png\" , ( WIDTH / 2 , ( HEIGHT - 100 )), ( BUTTON_X , BUTTON_Y ), \"main_menu\" ) # Adiciona os bot\u00f5es a um grupo self . buttons_group . add ( self . btn_back )","title":"Returns"},{"location":"#src.menu.OptionsMenu.check_input","text":"Check the input for the menu.","title":"check_input()"},{"location":"#src.menu.OptionsMenu.check_input--returns","text":"None Source code in src/menu.py 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 def check_input ( self ): \"\"\" Check the input for the menu. Returns ------- None \"\"\" if self . state_control . ESC_KEY : self . state_control . curr_menu = self . state_control . main_menu self . run_display = False if self . state_control . BACK_KEY : self . state_control . curr_menu = self . state_control . main_menu self . run_display = False if self . state_control . START_KEY or self . state_control . BUTTON_CLICKED : if self . next_state == \"main_menu\" : self . state_control . curr_menu = self . state_control . main_menu self . run_display = False","title":"Returns"},{"location":"#src.menu.OptionsMenu.display_menu","text":"Display the options menu.","title":"display_menu()"},{"location":"#src.menu.OptionsMenu.display_menu--returns","text":"None Source code in src/menu.py 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 def display_menu ( self ): \"\"\" Display the options menu. Returns ------- None \"\"\" self . run_display = True while self . run_display : self . state_control . screen . fill ( BLACK ) # Verifica as entradas e intera\u00e7\u00e3o com os bot\u00f5es self . verify () # Exibe a imagem \"Options\" self . state_control . screen . blit ( self . image , self . rect ) # Insere os bot\u00f5es na tela: self . buttons_group . draw ( self . state_control . screen ) self . update ()","title":"Returns"},{"location":"#src.menu.ResultScreen","text":"Bases: Menu Represents the result screen.","title":"ResultScreen"},{"location":"#src.menu.ResultScreen--attributes","text":"next_state : str The next state to transition to.","title":"Attributes"},{"location":"#src.menu.ResultScreen--methods","text":"init (self, game, image_path, x_y, scale_size) Initializes a ResultScreen object. display_menu(self) Display the result screen. check_input(self) Check the input for the menu. Source code in src/menu.py 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 class ResultScreen ( Menu ): \"\"\" Represents the result screen. Attributes ---------- next_state : str The next state to transition to. Methods ------- __init__(self, game, image_path, x_y, scale_size) Initializes a ResultScreen object. display_menu(self) Display the result screen. check_input(self) Check the input for the menu. \"\"\" def __init__ ( self , game , image_path , x_y , scale_size ): \"\"\" Initializes a ResultScreen object. Parameters ---------- game : Game The game object that controls the menu. image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu. Returns ------- None \"\"\" super () . __init__ ( game , image_path , x_y , scale_size ) self . next_state = \"main_menu\" def display_menu ( self ): \"\"\" Display the result screen. Returns ------- None \"\"\" self . run_display = True while self . run_display : self . state_control . screen . fill ( BLACK ) # Verifica as entradas e intera\u00e7\u00e3o com os bot\u00f5es self . verify () # CODE TO FINISH --> # Exibe a imagem \"You Died\" ou \"You Win\" self . state_control . screen . blit ( self . image , self . rect ) # <-- CODE TO FINISH # Insere os bot\u00f5es na tela: self . buttons_group . draw ( self . state_control . screen ) self . update () def check_input ( self ): \"\"\" Check the input for the menu. Returns ------- None \"\"\" if self . state_control . ESC_KEY : self . state_control . curr_menu = self . state_control . main_menu self . run_display = False if self . state_control . BACK_KEY : self . state_control . curr_menu = self . state_control . main_menu self . run_display = False if self . state_control . START_KEY or self . state_control . BUTTON_CLICKED : if self . next_state == \"main_menu\" : self . state_control . curr_menu = self . state_control . main_menu self . run_display = False","title":"Methods"},{"location":"#src.menu.ResultScreen.__init__","text":"Initializes a ResultScreen object.","title":"__init__()"},{"location":"#src.menu.ResultScreen.__init__--parameters","text":"game : Game The game object that controls the menu. image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu.","title":"Parameters"},{"location":"#src.menu.ResultScreen.__init__--returns","text":"None Source code in src/menu.py 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 def __init__ ( self , game , image_path , x_y , scale_size ): \"\"\" Initializes a ResultScreen object. Parameters ---------- game : Game The game object that controls the menu. image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu. Returns ------- None \"\"\" super () . __init__ ( game , image_path , x_y , scale_size ) self . next_state = \"main_menu\"","title":"Returns"},{"location":"#src.menu.ResultScreen.check_input","text":"Check the input for the menu.","title":"check_input()"},{"location":"#src.menu.ResultScreen.check_input--returns","text":"None Source code in src/menu.py 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 def check_input ( self ): \"\"\" Check the input for the menu. Returns ------- None \"\"\" if self . state_control . ESC_KEY : self . state_control . curr_menu = self . state_control . main_menu self . run_display = False if self . state_control . BACK_KEY : self . state_control . curr_menu = self . state_control . main_menu self . run_display = False if self . state_control . START_KEY or self . state_control . BUTTON_CLICKED : if self . next_state == \"main_menu\" : self . state_control . curr_menu = self . state_control . main_menu self . run_display = False","title":"Returns"},{"location":"#src.menu.ResultScreen.display_menu","text":"Display the result screen.","title":"display_menu()"},{"location":"#src.menu.ResultScreen.display_menu--returns","text":"None Source code in src/menu.py 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 def display_menu ( self ): \"\"\" Display the result screen. Returns ------- None \"\"\" self . run_display = True while self . run_display : self . state_control . screen . fill ( BLACK ) # Verifica as entradas e intera\u00e7\u00e3o com os bot\u00f5es self . verify () # CODE TO FINISH --> # Exibe a imagem \"You Died\" ou \"You Win\" self . state_control . screen . blit ( self . image , self . rect ) # <-- CODE TO FINISH # Insere os bot\u00f5es na tela: self . buttons_group . draw ( self . state_control . screen ) self . update ()","title":"Returns"},{"location":"#src.menu.TutorialScreen","text":"Bases: Menu Represents the tutorial screen.","title":"TutorialScreen"},{"location":"#src.menu.TutorialScreen--attributes","text":"next_state : str The next state to transition to.","title":"Attributes"},{"location":"#src.menu.TutorialScreen--methods","text":"init (self, game, image_path, x_y, scale_size) Initializes a TutorialScreen object. display_menu(self) Display the tutorial screen. check_input(self) Check the input for the menu. Source code in src/menu.py 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 class TutorialScreen ( Menu ): \"\"\" Represents the tutorial screen. Attributes ---------- next_state : str The next state to transition to. Methods ------- __init__(self, game, image_path, x_y, scale_size) Initializes a TutorialScreen object. display_menu(self) Display the tutorial screen. check_input(self) Check the input for the menu. \"\"\" def __init__ ( self , game , image_path , x_y , scale_size ): \"\"\" Initializes a TutorialScreen object. Parameters ---------- game : Game The game object that controls the menu. image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu. Returns ------- None \"\"\" super () . __init__ ( game , image_path , x_y , scale_size ) self . next_state = \"\" def display_menu ( self ): \"\"\" Display the tutorial screen. Returns ------- None \"\"\" self . run_display = True while self . run_display : self . state_control . screen . fill ( BLACK ) # Verifica as entradas e intera\u00e7\u00e3o com os bot\u00f5es self . verify () # CODE TO FINISH --> # <-- CODE TO FINISH self . update () def check_input ( self ): \"\"\" Check the input for the menu. Returns ------- None \"\"\" pass","title":"Methods"},{"location":"#src.menu.TutorialScreen.__init__","text":"Initializes a TutorialScreen object.","title":"__init__()"},{"location":"#src.menu.TutorialScreen.__init__--parameters","text":"game : Game The game object that controls the menu. image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu.","title":"Parameters"},{"location":"#src.menu.TutorialScreen.__init__--returns","text":"None Source code in src/menu.py 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 def __init__ ( self , game , image_path , x_y , scale_size ): \"\"\" Initializes a TutorialScreen object. Parameters ---------- game : Game The game object that controls the menu. image_path : str The path to the image file for the menu. x_y : tuple The x and y coordinates of the menu. scale_size : float The scale size of the menu. Returns ------- None \"\"\" super () . __init__ ( game , image_path , x_y , scale_size ) self . next_state = \"\"","title":"Returns"},{"location":"#src.menu.TutorialScreen.check_input","text":"Check the input for the menu.","title":"check_input()"},{"location":"#src.menu.TutorialScreen.check_input--returns","text":"None Source code in src/menu.py 739 740 741 742 743 744 745 746 747 def check_input ( self ): \"\"\" Check the input for the menu. Returns ------- None \"\"\" pass","title":"Returns"},{"location":"#src.menu.TutorialScreen.display_menu","text":"Display the tutorial screen.","title":"display_menu()"},{"location":"#src.menu.TutorialScreen.display_menu--returns","text":"None Source code in src/menu.py 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 def display_menu ( self ): \"\"\" Display the tutorial screen. Returns ------- None \"\"\" self . run_display = True while self . run_display : self . state_control . screen . fill ( BLACK ) # Verifica as entradas e intera\u00e7\u00e3o com os bot\u00f5es self . verify () # CODE TO FINISH --> # <-- CODE TO FINISH self . update ()","title":"Returns"},{"location":"#src.rider.Bot","text":"Bases: Rider Represents a bot object.","title":"Bot"},{"location":"#src.rider.Bot--attributes","text":"_number : int The number of the player. _path : list A list of the rider's positions. _velocity : float The velocity of the rider. _hand : pygame.sprite.Group The rider's hand. _color : str The color of the rider. __timer : int The timer of the rider. state_alive : bool The state of the rider. clicked_card : tuple The card that the rider clicked. _last_card : tuple The last card that the rider clicked. mask : pygame.rect.Rect The mask of the rider. line_mask : pygame.mask.Mask The line mask of the rider. _last_line_mask : pygame.mask.Mask The last line mask of the rider.","title":"Attributes"},{"location":"#src.rider.Bot--methods","text":"update(self, deck) Update the rider's state based on the given deck. move_rider(self, deck) Move the rider according to the card it clicked. __change_move(self, card, time) Move the rider's position based on the given card and time. __set_temp_variables(self) Set temporary variables that save code in movement. __reset_movement(self, deck) Resets the movement of the rider. _get_line_mask(color,start, end) Create a line mask based on the given color, start, and end points. select_card(self, card) Select a card for the rider. Source code in src/rider.py 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 class Bot ( Rider ): \"\"\" Represents a bot object. Attributes ---------- _number : int The number of the player. _path : list A list of the rider's positions. _velocity : float The velocity of the rider. _hand : pygame.sprite.Group The rider's hand. _color : str The color of the rider. __timer : int The timer of the rider. state_alive : bool The state of the rider. clicked_card : tuple The card that the rider clicked. _last_card : tuple The last card that the rider clicked. mask : pygame.rect.Rect The mask of the rider. line_mask : pygame.mask.Mask The line mask of the rider. _last_line_mask : pygame.mask.Mask The last line mask of the rider. Methods ------- update(self, deck) Update the rider's state based on the given deck. move_rider(self, deck) Move the rider according to the card it clicked. __change_move(self, card, time) Move the rider's position based on the given card and time. __set_temp_variables(self) Set temporary variables that save code in movement. __reset_movement(self, deck) Resets the movement of the rider. _get_line_mask(color,start, end) Create a line mask based on the given color, start, and end points. select_card(self, card) Select a card for the rider. \"\"\" def __init__ ( self , number , x_y , scale_size ): \"\"\" Initializes a Rider object. Parameters ---------- number : int The rider's number. x_y : tuple The initial position of the rider as a tuple of (x, y) coordinates. scale_size : float The scale size of the rider. Returns ------- None \"\"\" super () . __init__ ( number , x_y , scale_size ) def choose_card ( self , all_riders ): \"\"\" Choose a card from the rider's hand based on the preview movement. Parameters ---------- all_riders : list A list of all riders in the game. Returns ------- pygame.sprite.Sprite The chosen card from the rider's hand. Notes ----- This method iterates through each card in the rider's hand and checks if the preview movement is valid or not. If a card's movement is valid, it is added to the choices list. If there are valid choices, a random card is returned from the choices list. If there are no valid choices, a random card from the rider's hand is returned. \"\"\" choices = [] # Laceia cada carta e decide se o movimento \u00e9 v\u00e1lido ou n\u00e3o for card in self . _hand . sprites (): # Se for, adiciona \u00e0 lista choices if self . __preview_movement ( card , all_riders ): choices . append ( card ) # Se algum for v\u00e1lido, retorna um entre eles if choices : return random . choice ( choices ) # Se n\u00e3o houver nenhum, qualquer carta da m\u00e3o valer\u00e1 else : return random . choice ( self . _hand . sprites ()) def __preview_movement ( self , card , all_riders ): \"\"\" Calculate the preview movement of the rider based on the given card. Parameters ---------- card : tuple A tuple representing the movement card (x, y). all_riders : list A list of all riders in the game. Returns ------- bool True if the preview movement is valid, False otherwise. \"\"\" # Pega o ponto inicial e final do vetor start = self . _path [ - 1 ] end = ( start [ 0 ] + card [ 0 ] * DISTANCE , start [ 1 ] - card [ 1 ] * DISTANCE ) # Se for colidir com as fronteiras retorna if utilities . check_border_collision ( end ): return False # Cria uma m\u00e1scara para testar colis\u00f5es futuras desta linha line_mask = self . _get_line_mask ( self . _color , start , end ) # Se for colidir com as linhas de outrem retorna if utilities . check_line_cross ( all_riders , self , line_mask , card ): return False # Se n\u00e3o colidir com nada, a carta \u00e9 v\u00e1lida return True","title":"Methods"},{"location":"#src.rider.Bot.__init__","text":"Initializes a Rider object.","title":"__init__()"},{"location":"#src.rider.Bot.__init__--parameters","text":"number : int The rider's number. x_y : tuple The initial position of the rider as a tuple of (x, y) coordinates. scale_size : float The scale size of the rider.","title":"Parameters"},{"location":"#src.rider.Bot.__init__--returns","text":"None Source code in src/rider.py 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 def __init__ ( self , number , x_y , scale_size ): \"\"\" Initializes a Rider object. Parameters ---------- number : int The rider's number. x_y : tuple The initial position of the rider as a tuple of (x, y) coordinates. scale_size : float The scale size of the rider. Returns ------- None \"\"\" super () . __init__ ( number , x_y , scale_size )","title":"Returns"},{"location":"#src.rider.Bot.__preview_movement","text":"Calculate the preview movement of the rider based on the given card.","title":"__preview_movement()"},{"location":"#src.rider.Bot.__preview_movement--parameters","text":"card : tuple A tuple representing the movement card (x, y). all_riders : list A list of all riders in the game.","title":"Parameters"},{"location":"#src.rider.Bot.__preview_movement--returns","text":"bool True if the preview movement is valid, False otherwise. Source code in src/rider.py 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 def __preview_movement ( self , card , all_riders ): \"\"\" Calculate the preview movement of the rider based on the given card. Parameters ---------- card : tuple A tuple representing the movement card (x, y). all_riders : list A list of all riders in the game. Returns ------- bool True if the preview movement is valid, False otherwise. \"\"\" # Pega o ponto inicial e final do vetor start = self . _path [ - 1 ] end = ( start [ 0 ] + card [ 0 ] * DISTANCE , start [ 1 ] - card [ 1 ] * DISTANCE ) # Se for colidir com as fronteiras retorna if utilities . check_border_collision ( end ): return False # Cria uma m\u00e1scara para testar colis\u00f5es futuras desta linha line_mask = self . _get_line_mask ( self . _color , start , end ) # Se for colidir com as linhas de outrem retorna if utilities . check_line_cross ( all_riders , self , line_mask , card ): return False # Se n\u00e3o colidir com nada, a carta \u00e9 v\u00e1lida return True","title":"Returns"},{"location":"#src.rider.Bot.choose_card","text":"Choose a card from the rider's hand based on the preview movement.","title":"choose_card()"},{"location":"#src.rider.Bot.choose_card--parameters","text":"all_riders : list A list of all riders in the game.","title":"Parameters"},{"location":"#src.rider.Bot.choose_card--returns","text":"pygame.sprite.Sprite The chosen card from the rider's hand.","title":"Returns"},{"location":"#src.rider.Bot.choose_card--notes","text":"This method iterates through each card in the rider's hand and checks if the preview movement is valid or not. If a card's movement is valid, it is added to the choices list. If there are valid choices, a random card is returned from the choices list. If there are no valid choices, a random card from the rider's hand is returned. Source code in src/rider.py 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 def choose_card ( self , all_riders ): \"\"\" Choose a card from the rider's hand based on the preview movement. Parameters ---------- all_riders : list A list of all riders in the game. Returns ------- pygame.sprite.Sprite The chosen card from the rider's hand. Notes ----- This method iterates through each card in the rider's hand and checks if the preview movement is valid or not. If a card's movement is valid, it is added to the choices list. If there are valid choices, a random card is returned from the choices list. If there are no valid choices, a random card from the rider's hand is returned. \"\"\" choices = [] # Laceia cada carta e decide se o movimento \u00e9 v\u00e1lido ou n\u00e3o for card in self . _hand . sprites (): # Se for, adiciona \u00e0 lista choices if self . __preview_movement ( card , all_riders ): choices . append ( card ) # Se algum for v\u00e1lido, retorna um entre eles if choices : return random . choice ( choices ) # Se n\u00e3o houver nenhum, qualquer carta da m\u00e3o valer\u00e1 else : return random . choice ( self . _hand . sprites ())","title":"Notes"},{"location":"#src.rider.Player","text":"Class representing a player in the game.","title":"Player"},{"location":"#src.rider.Player--attributes","text":"__wrapper : pygame.sprite.GroupSingle The wrapper around the Rider sprite.","title":"Attributes"},{"location":"#src.rider.Player--methods","text":"sprite() Returns the sprite of the SingleGroup. update() Updates the SingleGroup. draw(screen) Draws the SingleGroup. Source code in src/rider.py 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 @utilities . Singleton class Player (): \"\"\" Class representing a player in the game. Attributes ---------- __wrapper : pygame.sprite.GroupSingle The wrapper around the Rider sprite. Methods ------- sprite() Returns the sprite of the SingleGroup. update() Updates the SingleGroup. draw(screen) Draws the SingleGroup. \"\"\" def __init__ ( self , number , x_y , scale_size , deck ): \"\"\" Initialize a Player object. Parameters ---------- number : int The player's number. x_y : tuple The initial position of the player. scale_size : int The scale size of the player. deck : Deck The player's deck. Returns ------- None \"\"\" # Cria um envolt\u00f3rio entorno de um Rider self . __wrapper = Rider ( number , x_y , scale_size , deck ) self . __wrapper = pygame . sprite . GroupSingle ( self . __wrapper ) def __getattr__ ( self , attrvalue ): \"\"\" Get the attribute from the sprite and not from the group. Parameters ---------- attrvalue : str The name of the attribute to retrieve. Returns ------- Any The value of the requested attribute. Notes ----- This method is called when an attribute is accessed on the `Rider` object that is not defined directly in the class. It delegates the attribute retrieval to the underlying sprite object. \"\"\" return getattr ( self . __wrapper . sprite , attrvalue ) def __getattr__ ( self , attrvalue ): \"\"\" Get the attribute from the sprite and not from the group. Parameters ---------- attrvalue : str The name of the attribute to get. Returns ------- Any The value of the requested attribute. Notes ----- This method is called when an attribute is not found in the current object. It allows accessing attributes of the sprite directly instead of the group. Examples -------- >>> rider = Rider() >>> rider.x 100 >>> rider.y 200 \"\"\" # Pega o atributo do sprite e n\u00e3o do grupo return getattr ( self . __wrapper . sprite , attrvalue ) def __bool__ ( self ): \"\"\" Return the boolean value of the SingleGroup. Returns ------- bool The boolean value of the SingleGroup. \"\"\" return bool ( self . __wrapper ) def sprite ( self ): \"\"\" Return the sprite of the SingleGroup. Returns ------- sprite : object The sprite object representing the SingleGroup. \"\"\" return self . __wrapper . sprite def update ( self ): \"\"\" Update the SingleGroup. Returns ------- updated : bool True if the update was successful, False otherwise. \"\"\" # Atualiza o SingleGroup return self . __wrapper . update () def draw ( self , screen ): \"\"\" Draw the SingleGroup on the screen. Parameters ---------- screen : pygame.Surface The surface to draw on. Returns ------- pygame.Rect The rectangle that represents the area of the drawn SingleGroup. \"\"\" # Desenha o SingleGroup return self . __wrapper . draw ( screen )","title":"Methods"},{"location":"#src.rider.Player.__bool__","text":"Return the boolean value of the SingleGroup.","title":"__bool__()"},{"location":"#src.rider.Player.__bool__--returns","text":"bool The boolean value of the SingleGroup. Source code in src/rider.py 414 415 416 417 418 419 420 421 422 423 424 def __bool__ ( self ): \"\"\" Return the boolean value of the SingleGroup. Returns ------- bool The boolean value of the SingleGroup. \"\"\" return bool ( self . __wrapper )","title":"Returns"},{"location":"#src.rider.Player.__getattr__","text":"Get the attribute from the sprite and not from the group.","title":"__getattr__()"},{"location":"#src.rider.Player.__getattr__--parameters","text":"attrvalue : str The name of the attribute to get.","title":"Parameters"},{"location":"#src.rider.Player.__getattr__--returns","text":"Any The value of the requested attribute.","title":"Returns"},{"location":"#src.rider.Player.__getattr__--notes","text":"This method is called when an attribute is not found in the current object. It allows accessing attributes of the sprite directly instead of the group.","title":"Notes"},{"location":"#src.rider.Player.__getattr__--examples","text":"rider = Rider() rider.x 100 rider.y 200 Source code in src/rider.py 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 def __getattr__ ( self , attrvalue ): \"\"\" Get the attribute from the sprite and not from the group. Parameters ---------- attrvalue : str The name of the attribute to get. Returns ------- Any The value of the requested attribute. Notes ----- This method is called when an attribute is not found in the current object. It allows accessing attributes of the sprite directly instead of the group. Examples -------- >>> rider = Rider() >>> rider.x 100 >>> rider.y 200 \"\"\" # Pega o atributo do sprite e n\u00e3o do grupo return getattr ( self . __wrapper . sprite , attrvalue )","title":"Examples"},{"location":"#src.rider.Player.__init__","text":"Initialize a Player object.","title":"__init__()"},{"location":"#src.rider.Player.__init__--parameters","text":"number : int The player's number. x_y : tuple The initial position of the player. scale_size : int The scale size of the player. deck : Deck The player's deck.","title":"Parameters"},{"location":"#src.rider.Player.__init__--returns","text":"None Source code in src/rider.py 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 def __init__ ( self , number , x_y , scale_size , deck ): \"\"\" Initialize a Player object. Parameters ---------- number : int The player's number. x_y : tuple The initial position of the player. scale_size : int The scale size of the player. deck : Deck The player's deck. Returns ------- None \"\"\" # Cria um envolt\u00f3rio entorno de um Rider self . __wrapper = Rider ( number , x_y , scale_size , deck ) self . __wrapper = pygame . sprite . GroupSingle ( self . __wrapper )","title":"Returns"},{"location":"#src.rider.Player.draw","text":"Draw the SingleGroup on the screen.","title":"draw()"},{"location":"#src.rider.Player.draw--parameters","text":"screen : pygame.Surface The surface to draw on.","title":"Parameters"},{"location":"#src.rider.Player.draw--returns","text":"pygame.Rect The rectangle that represents the area of the drawn SingleGroup. Source code in src/rider.py 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 def draw ( self , screen ): \"\"\" Draw the SingleGroup on the screen. Parameters ---------- screen : pygame.Surface The surface to draw on. Returns ------- pygame.Rect The rectangle that represents the area of the drawn SingleGroup. \"\"\" # Desenha o SingleGroup return self . __wrapper . draw ( screen )","title":"Returns"},{"location":"#src.rider.Player.sprite","text":"Return the sprite of the SingleGroup.","title":"sprite()"},{"location":"#src.rider.Player.sprite--returns","text":"sprite : object The sprite object representing the SingleGroup. Source code in src/rider.py 426 427 428 429 430 431 432 433 434 435 436 def sprite ( self ): \"\"\" Return the sprite of the SingleGroup. Returns ------- sprite : object The sprite object representing the SingleGroup. \"\"\" return self . __wrapper . sprite","title":"Returns"},{"location":"#src.rider.Player.update","text":"Update the SingleGroup.","title":"update()"},{"location":"#src.rider.Player.update--returns","text":"updated : bool True if the update was successful, False otherwise. Source code in src/rider.py 438 439 440 441 442 443 444 445 446 447 448 def update ( self ): \"\"\" Update the SingleGroup. Returns ------- updated : bool True if the update was successful, False otherwise. \"\"\" # Atualiza o SingleGroup return self . __wrapper . update ()","title":"Returns"},{"location":"#src.rider.Rider","text":"Bases: Entity Represents a rider object.","title":"Rider"},{"location":"#src.rider.Rider--attributes","text":"_number : int The number of the player. _path : list A list of the rider's positions. _velocity : float The velocity of the rider. _hand : pygame.sprite.Group The rider's hand. _color : str The color of the rider. __timer : int The timer of the rider. state_alive : bool The state of the rider. clicked_card : tuple The card that the rider clicked. _last_card : tuple The last card that the rider clicked. mask : pygame.rect.Rect The mask of the rider. line_mask : pygame.mask.Mask The line mask of the rider. _last_line_mask : pygame.mask.Mask The last line mask of the rider.","title":"Attributes"},{"location":"#src.rider.Rider--methods","text":"update(self, deck) Update the rider's state based on the given deck. move_rider(self, deck) Move the rider according to the card it clicked. __change_move(self, card, time) Move the rider's position based on the given card and time. __set_temp_variables(self) Set temporary variables that save code in movement. __reset_movement(self, deck) Resets the movement of the rider. _get_line_mask(color,start, end) Create a line mask based on the given color, start, and end points. select_card(self, card) Select a card for the rider. Source code in src/rider.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 class Rider ( Entity ): \"\"\" Represents a rider object. Attributes ---------- _number : int The number of the player. _path : list A list of the rider's positions. _velocity : float The velocity of the rider. _hand : pygame.sprite.Group The rider's hand. _color : str The color of the rider. __timer : int The timer of the rider. state_alive : bool The state of the rider. clicked_card : tuple The card that the rider clicked. _last_card : tuple The last card that the rider clicked. mask : pygame.rect.Rect The mask of the rider. line_mask : pygame.mask.Mask The line mask of the rider. _last_line_mask : pygame.mask.Mask The last line mask of the rider. Methods ------- update(self, deck) Update the rider's state based on the given deck. move_rider(self, deck) Move the rider according to the card it clicked. __change_move(self, card, time) Move the rider's position based on the given card and time. __set_temp_variables(self) Set temporary variables that save code in movement. __reset_movement(self, deck) Resets the movement of the rider. _get_line_mask(color,start, end) Create a line mask based on the given color, start, and end points. select_card(self, card) Select a card for the rider. \"\"\" def __init__ ( self , number , x_y , scale_size , deck ): \"\"\" Initialize a Rider object. Parameters ---------- number : int The number of the player. x_y : tuple The initial position of the rider. scale_size : float The scale size of the rider. deck : Deck The deck object that represents the game deck. Returns ------- None \"\"\" # Carrega texturas diferentes dependendo do n\u00ba do jogador archive = \"rider_\" + str ( number ) + \".png\" # Cria o rider e centraliza sua posi\u00e7\u00e3o super () . __init__ ( \"assets/textures/\" + archive , x_y , scale_size ) self . rect = self . image . get_rect ( center = x_y ) # Atributos adicionais self . _number = number self . _path = [ x_y , x_y ] self . _velocity = 1 / 2 # Salva a m\u00e3o de cartas do jogador self . _hand = pygame . sprite . Group () for foo in range ( 3 ): card = deck . draw_card () card . rect . topleft = ( GRID_X + 50 , GRID_Y / 2 - 55 + foo * 125 ) self . _hand . add ( card ) # Salva a cor da moto if number == 1 : self . _color = \"#258dc2\" elif number == 2 : self . _color = \"#ec6716\" elif number == 3 : self . _color = \"#cb101a\" elif number == 4 : self . _color = \"#ffb001\" # Atributos de estado self . __timer = 0 self . state_alive = True self . clicked_card = None self . _last_card = ( 0 , 0 ) # M\u00e1scaras para colis\u00f5es mais precisas self . mask = pygame . rect . Rect ( x_y , ( RIDER_X / 5 - 2 , RIDER_Y / 5 - 1 )) self . line_mask = self . _get_line_mask ( self . _color , ( - 10 , - 10 ), ( - 10 , - 10 )) self . _last_line_mask = self . line_mask def update ( self , deck ): \"\"\" Update the rider's state based on the given deck. Parameters ---------- deck : Deck The deck object that represents the game deck. Returns ------- None \"\"\" # Roda anima\u00e7\u00e3o de movimento se estiver vivo if self . state_alive : return self . move_rider ( deck ) # E anima\u00e7\u00e3o de morte caso contr\u00e1rio else : pass def move_rider ( self , deck ): \"\"\" Move the rider according to the card it clicked. Parameters ---------- deck : Deck The deck object. Returns ------- bool True if the rider is moved, False otherwise. \"\"\" self . __set_temp_variables () # Move o jogador de acordo com essa desigualdade (quase sempre satisfeita) if self . __temp_player_center [ 0 ] + 2 < self . __temp_player_target [ 0 ]: self . __change_move ( self . clicked_card , self . __timer ) self . __timer += 0.05 # No caso n\u00e3o-t\u00e3o-raro de vetores (0, y), move o jogador de acordo elif self . clicked_card [ 0 ] == 0 and self . __temp_player_center [ 1 ] + 2 < self . __temp_player_target [ 1 ]: self . __change_move ( self . clicked_card , self . __timer ) self . __timer += 0.05 # Se ficou parado, reseta o movimento else : self . __reset_movement ( deck ) return False return True def __change_move ( self , card , time ): \"\"\" Move the rider's position based on the given card and time. Parameters ---------- card : tuple The difference that the rider should move in the x and y directions. time : int The time duration of the movement. Returns ------- None Notes ----- This method updates the rider's position by calculating the temporary positions based on the card and time values. The rider's position is then rounded to the nearest integer and updated accordingly. \"\"\" # Diferen\u00e7a que a moto dever\u00e1 andar delta_x = card [ 0 ] delta_y = card [ 1 ] # Reinicia a posi\u00e7\u00e3o em cada nova anima\u00e7\u00e3o if time == 0 : self . __temp_x = self . rect . centerx self . __temp_y = self . rect . centery # Valores tempor\u00e1rios para n\u00e3o perder precis\u00e3o no movimento self . __temp_x = self . __temp_x + time * delta_x / self . _velocity self . __temp_y = self . __temp_y - time * delta_y / self . _velocity # Atualiza a posi\u00e7\u00e3o (e converte para inteiro) self . rect . centerx = round ( self . __temp_x ) self . rect . centery = round ( self . __temp_y ) self . mask . center = self . rect . center def __set_temp_variables ( self ): \"\"\" Set temporary variables that save code in movement. Parameters ---------- self : Rider The Rider object. Returns ------- None \"\"\" # Vari\u00e1veis tempor\u00e1rias que poupam c\u00f3digo no movimento self . __temp_player_center = self . rect . center self . __temp_player_target = self . __player_target # Dependendo do valor da carta, muda a coordenada relativa if self . clicked_card [ 0 ] < 0 : self . __temp_player_center = ( - self . __temp_player_center [ 0 ], self . __temp_player_center [ 1 ]) self . __temp_player_target = ( - self . __temp_player_target [ 0 ], self . __temp_player_target [ 1 ]) if self . clicked_card [ 1 ] > 0 : self . __temp_player_center = ( self . __temp_player_center [ 0 ], - self . __temp_player_center [ 1 ]) self . __temp_player_target = ( self . __temp_player_target [ 0 ], - self . __temp_player_target [ 1 ]) def __reset_movement ( self , deck ): \"\"\" Resets the movement of the rider. Parameters ---------- deck : Deck The deck of cards. Returns ------- None \"\"\" # Retorna _timer para 0 self . __timer = 0 # Pesca uma nova carta e adiciona \u00e0 m\u00e3o card = deck . draw_card () card . rect . topleft = self . clicked_card . rect . topleft self . _hand . add ( card ) # Remove a carta usada e limpa _clicked_card self . _hand . remove ( self . clicked_card ) self . _last_card = self . clicked_card self . clicked_card = ( 0 , 0 ) # Salva a posi\u00e7\u00e3o final do jogador no seu _path self . _path . append ( self . rect . center ) # Cria uma masc\u00e1ra para a linha e a adiciona em line_mask temp_mask = self . _get_line_mask ( self . _color , self . _path [ - 2 ], self . _path [ - 1 ]) self . _last_line_mask = self . line_mask . copy () self . line_mask . draw ( temp_mask , ( 0 , 0 )) @staticmethod def _get_line_mask ( color , start , end ): \"\"\" Create a line mask based on the given color, start, and end points. Parameters ---------- color : str The color of the line. start : tuple The starting point of the line. end : tuple The ending point of the line. Returns ------- pygame.mask.Mask The line mask. \"\"\" # Cria uma superf\u00edcie em preto temp_surf = pygame . Surface (( GRID_X , GRID_Y )) temp_surf . set_colorkey (( 0 , 0 , 0 )) # Desenha a linha e retorna a m\u00e1scara pygame . draw . line ( temp_surf , color , start , end , width = 6 ) return pygame . mask . from_surface ( temp_surf ) def select_card ( self , card ): \"\"\" Select a card for the rider. Parameters ---------- card : tuple The card that the rider clicked. Returns ------- None \"\"\" self . clicked_card = card self . __player_target = self . _path [ - 1 ] self . __player_target = ( card [ 0 ] * DISTANCE + self . __player_target [ 0 ], - card [ 1 ] * DISTANCE + self . __player_target [ 1 ])","title":"Methods"},{"location":"#src.rider.Rider.__change_move","text":"Move the rider's position based on the given card and time.","title":"__change_move()"},{"location":"#src.rider.Rider.__change_move--parameters","text":"card : tuple The difference that the rider should move in the x and y directions. time : int The time duration of the movement.","title":"Parameters"},{"location":"#src.rider.Rider.__change_move--returns","text":"None","title":"Returns"},{"location":"#src.rider.Rider.__change_move--notes","text":"This method updates the rider's position by calculating the temporary positions based on the card and time values. The rider's position is then rounded to the nearest integer and updated accordingly. Source code in src/rider.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 def __change_move ( self , card , time ): \"\"\" Move the rider's position based on the given card and time. Parameters ---------- card : tuple The difference that the rider should move in the x and y directions. time : int The time duration of the movement. Returns ------- None Notes ----- This method updates the rider's position by calculating the temporary positions based on the card and time values. The rider's position is then rounded to the nearest integer and updated accordingly. \"\"\" # Diferen\u00e7a que a moto dever\u00e1 andar delta_x = card [ 0 ] delta_y = card [ 1 ] # Reinicia a posi\u00e7\u00e3o em cada nova anima\u00e7\u00e3o if time == 0 : self . __temp_x = self . rect . centerx self . __temp_y = self . rect . centery # Valores tempor\u00e1rios para n\u00e3o perder precis\u00e3o no movimento self . __temp_x = self . __temp_x + time * delta_x / self . _velocity self . __temp_y = self . __temp_y - time * delta_y / self . _velocity # Atualiza a posi\u00e7\u00e3o (e converte para inteiro) self . rect . centerx = round ( self . __temp_x ) self . rect . centery = round ( self . __temp_y ) self . mask . center = self . rect . center","title":"Notes"},{"location":"#src.rider.Rider.__init__","text":"Initialize a Rider object.","title":"__init__()"},{"location":"#src.rider.Rider.__init__--parameters","text":"number : int The number of the player. x_y : tuple The initial position of the rider. scale_size : float The scale size of the rider. deck : Deck The deck object that represents the game deck.","title":"Parameters"},{"location":"#src.rider.Rider.__init__--returns","text":"None Source code in src/rider.py 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 def __init__ ( self , number , x_y , scale_size , deck ): \"\"\" Initialize a Rider object. Parameters ---------- number : int The number of the player. x_y : tuple The initial position of the rider. scale_size : float The scale size of the rider. deck : Deck The deck object that represents the game deck. Returns ------- None \"\"\" # Carrega texturas diferentes dependendo do n\u00ba do jogador archive = \"rider_\" + str ( number ) + \".png\" # Cria o rider e centraliza sua posi\u00e7\u00e3o super () . __init__ ( \"assets/textures/\" + archive , x_y , scale_size ) self . rect = self . image . get_rect ( center = x_y ) # Atributos adicionais self . _number = number self . _path = [ x_y , x_y ] self . _velocity = 1 / 2 # Salva a m\u00e3o de cartas do jogador self . _hand = pygame . sprite . Group () for foo in range ( 3 ): card = deck . draw_card () card . rect . topleft = ( GRID_X + 50 , GRID_Y / 2 - 55 + foo * 125 ) self . _hand . add ( card ) # Salva a cor da moto if number == 1 : self . _color = \"#258dc2\" elif number == 2 : self . _color = \"#ec6716\" elif number == 3 : self . _color = \"#cb101a\" elif number == 4 : self . _color = \"#ffb001\" # Atributos de estado self . __timer = 0 self . state_alive = True self . clicked_card = None self . _last_card = ( 0 , 0 ) # M\u00e1scaras para colis\u00f5es mais precisas self . mask = pygame . rect . Rect ( x_y , ( RIDER_X / 5 - 2 , RIDER_Y / 5 - 1 )) self . line_mask = self . _get_line_mask ( self . _color , ( - 10 , - 10 ), ( - 10 , - 10 )) self . _last_line_mask = self . line_mask","title":"Returns"},{"location":"#src.rider.Rider.__reset_movement","text":"Resets the movement of the rider.","title":"__reset_movement()"},{"location":"#src.rider.Rider.__reset_movement--parameters","text":"deck : Deck The deck of cards.","title":"Parameters"},{"location":"#src.rider.Rider.__reset_movement--returns","text":"None Source code in src/rider.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 def __reset_movement ( self , deck ): \"\"\" Resets the movement of the rider. Parameters ---------- deck : Deck The deck of cards. Returns ------- None \"\"\" # Retorna _timer para 0 self . __timer = 0 # Pesca uma nova carta e adiciona \u00e0 m\u00e3o card = deck . draw_card () card . rect . topleft = self . clicked_card . rect . topleft self . _hand . add ( card ) # Remove a carta usada e limpa _clicked_card self . _hand . remove ( self . clicked_card ) self . _last_card = self . clicked_card self . clicked_card = ( 0 , 0 ) # Salva a posi\u00e7\u00e3o final do jogador no seu _path self . _path . append ( self . rect . center ) # Cria uma masc\u00e1ra para a linha e a adiciona em line_mask temp_mask = self . _get_line_mask ( self . _color , self . _path [ - 2 ], self . _path [ - 1 ]) self . _last_line_mask = self . line_mask . copy () self . line_mask . draw ( temp_mask , ( 0 , 0 ))","title":"Returns"},{"location":"#src.rider.Rider.__set_temp_variables","text":"Set temporary variables that save code in movement.","title":"__set_temp_variables()"},{"location":"#src.rider.Rider.__set_temp_variables--parameters","text":"self : Rider The Rider object.","title":"Parameters"},{"location":"#src.rider.Rider.__set_temp_variables--returns","text":"None Source code in src/rider.py 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def __set_temp_variables ( self ): \"\"\" Set temporary variables that save code in movement. Parameters ---------- self : Rider The Rider object. Returns ------- None \"\"\" # Vari\u00e1veis tempor\u00e1rias que poupam c\u00f3digo no movimento self . __temp_player_center = self . rect . center self . __temp_player_target = self . __player_target # Dependendo do valor da carta, muda a coordenada relativa if self . clicked_card [ 0 ] < 0 : self . __temp_player_center = ( - self . __temp_player_center [ 0 ], self . __temp_player_center [ 1 ]) self . __temp_player_target = ( - self . __temp_player_target [ 0 ], self . __temp_player_target [ 1 ]) if self . clicked_card [ 1 ] > 0 : self . __temp_player_center = ( self . __temp_player_center [ 0 ], - self . __temp_player_center [ 1 ]) self . __temp_player_target = ( self . __temp_player_target [ 0 ], - self . __temp_player_target [ 1 ])","title":"Returns"},{"location":"#src.rider.Rider.move_rider","text":"Move the rider according to the card it clicked.","title":"move_rider()"},{"location":"#src.rider.Rider.move_rider--parameters","text":"deck : Deck The deck object.","title":"Parameters"},{"location":"#src.rider.Rider.move_rider--returns","text":"bool True if the rider is moved, False otherwise. Source code in src/rider.py 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 def move_rider ( self , deck ): \"\"\" Move the rider according to the card it clicked. Parameters ---------- deck : Deck The deck object. Returns ------- bool True if the rider is moved, False otherwise. \"\"\" self . __set_temp_variables () # Move o jogador de acordo com essa desigualdade (quase sempre satisfeita) if self . __temp_player_center [ 0 ] + 2 < self . __temp_player_target [ 0 ]: self . __change_move ( self . clicked_card , self . __timer ) self . __timer += 0.05 # No caso n\u00e3o-t\u00e3o-raro de vetores (0, y), move o jogador de acordo elif self . clicked_card [ 0 ] == 0 and self . __temp_player_center [ 1 ] + 2 < self . __temp_player_target [ 1 ]: self . __change_move ( self . clicked_card , self . __timer ) self . __timer += 0.05 # Se ficou parado, reseta o movimento else : self . __reset_movement ( deck ) return False return True","title":"Returns"},{"location":"#src.rider.Rider.select_card","text":"Select a card for the rider.","title":"select_card()"},{"location":"#src.rider.Rider.select_card--parameters","text":"card : tuple The card that the rider clicked.","title":"Parameters"},{"location":"#src.rider.Rider.select_card--returns","text":"None Source code in src/rider.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 def select_card ( self , card ): \"\"\" Select a card for the rider. Parameters ---------- card : tuple The card that the rider clicked. Returns ------- None \"\"\" self . clicked_card = card self . __player_target = self . _path [ - 1 ] self . __player_target = ( card [ 0 ] * DISTANCE + self . __player_target [ 0 ], - card [ 1 ] * DISTANCE + self . __player_target [ 1 ])","title":"Returns"},{"location":"#src.rider.Rider.update","text":"Update the rider's state based on the given deck.","title":"update()"},{"location":"#src.rider.Rider.update--parameters","text":"deck : Deck The deck object that represents the game deck.","title":"Parameters"},{"location":"#src.rider.Rider.update--returns","text":"None Source code in src/rider.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 def update ( self , deck ): \"\"\" Update the rider's state based on the given deck. Parameters ---------- deck : Deck The deck object that represents the game deck. Returns ------- None \"\"\" # Roda anima\u00e7\u00e3o de movimento se estiver vivo if self . state_alive : return self . move_rider ( deck ) # E anima\u00e7\u00e3o de morte caso contr\u00e1rio else : pass","title":"Returns"},{"location":"#src.state_control.StateControl","text":"Class that controls the state of the game and manages the game loop.","title":"StateControl"},{"location":"#src.state_control.StateControl--attributes","text":"running : bool Flag indicating if the game is running. playing : bool Flag indicating if the game is currently being played. UP_KEY : bool Flag indicating if the up key is pressed. DOWN_KEY : bool Flag indicating if the down key is pressed. START_KEY : bool Flag indicating if the start key is pressed. BACK_KEY : bool Flag indicating if the back key is pressed. ESC_KEY : bool Flag indicating if the escape key is pressed. BUTTON_CLICKED : bool Flag indicating if a button is clicked. screen : pygame.Surface The game screen. fps_clock : pygame.time.Clock The clock used to control the game's frame rate. main_menu : MainMenu The main menu of the game. options_menu : OptionsMenu The options menu of the game. credits_menu : CreditsMenu The credits menu of the game. result_screen : ResultScreen The result screen of the game. curr_menu : Menu The current menu being displayed. game_run : GridGame The game instance.","title":"Attributes"},{"location":"#src.state_control.StateControl--methods","text":"game_loop(self) Main game loop that updates and renders the game until the game is no longer being played. check_events(self) Check for user events such as key presses or window close events. reset_keys(self) Reset the key flags to their initial state. start(self) Start the game by displaying the main menu and entering the game loop. Source code in src/state_control.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 class StateControl (): \"\"\" Class that controls the state of the game and manages the game loop. Attributes ---------- running : bool Flag indicating if the game is running. playing : bool Flag indicating if the game is currently being played. UP_KEY : bool Flag indicating if the up key is pressed. DOWN_KEY : bool Flag indicating if the down key is pressed. START_KEY : bool Flag indicating if the start key is pressed. BACK_KEY : bool Flag indicating if the back key is pressed. ESC_KEY : bool Flag indicating if the escape key is pressed. BUTTON_CLICKED : bool Flag indicating if a button is clicked. screen : pygame.Surface The game screen. fps_clock : pygame.time.Clock The clock used to control the game's frame rate. main_menu : MainMenu The main menu of the game. options_menu : OptionsMenu The options menu of the game. credits_menu : CreditsMenu The credits menu of the game. result_screen : ResultScreen The result screen of the game. curr_menu : Menu The current menu being displayed. game_run : GridGame The game instance. Methods ------- game_loop(self) Main game loop that updates and renders the game until the game is no longer being played. check_events(self) Check for user events such as key presses or window close events. reset_keys(self) Reset the key flags to their initial state. start(self) Start the game by displaying the main menu and entering the game loop. \"\"\" def __init__ ( self ): \"\"\" Initialize the StateControl object. Parameters ---------- None Returns ------- None \"\"\" # Inicia\u00e7\u00e3o das vari\u00e1veis de controle self . running , self . playing = True , False self . UP_KEY , self . DOWN_KEY , self . START_KEY , self . BACK_KEY , self . ESC_KEY = False , False , False , False , False self . BUTTON_CLICKED = False # Cria a tela do jogo self . screen = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( \"Vectrun\" ) pygame . display . set_icon ( pygame . image . load ( TEXTURE_PATH + \"icon.png\" )) # Cria o rel\u00f3gio interno do FPS self . fps_clock = pygame . time . Clock () # Cria um objeto para cada uma das telas self . main_menu = MainMenu ( self , ( TEXTURE_PATH + \"vectrun_logo.png\" ), ( WIDTH / 2 , HEIGHT / 5 ), ( LOGO_X , LOGO_Y )) self . options_menu = OptionsMenu ( self , ( TEXTURE_PATH + \"options_button.png\" ), ( WIDTH / 2 , ( HEIGHT / 6 - 50 )), ( 2 * BUTTON_X , 2 * BUTTON_Y )) self . credits_menu = CreditsMenu ( self , ( TEXTURE_PATH + \"credits_button.png\" ), ( WIDTH / 2 , ( HEIGHT / 6 - 50 )), ( 2 * BUTTON_X , 2 * BUTTON_Y )) # EDI\u00c7\u00e3o FUtura para considerar ambos casos (derrrota e virtoria) self . result_screen = ResultScreen ( self , ( TEXTURE_PATH + \"you_win.png\" ), ( WIDTH / 2 , HEIGHT / 2 ), ( LOGO_X , LOGO_Y )) # Define a tela inicial self . curr_menu = self . main_menu # Cria um objeto para o jogo self . game_run = GridGame ( TEXTURE_PATH + \"grid.png\" , ( 0 , 0 ), ( GRID_X , GRID_Y ), 3 ) # Posteriormente, criar um a cada vez que o jogo for iniciado def game_loop ( self ): \"\"\" Main game loop that updates and renders the game until the game is no longer being played. Parameters ---------- None Returns ------- None \"\"\" while self . playing : # Preenche a tela self . screen . fill ( BLACK ) # Atualiza e exibe o jogo na tela self . game_run . update () self . game_run . draw ( self . screen ) # Enfim mostra o diplay pygame . display . update () self . fps_clock . tick ( 30 ) # INSERIR AQUI # (DETECTAR DERROTA OU VITORIA) if False : self . curr_menu = self . result_screen def check_events ( self ): \"\"\" Check for user events such as key presses or window close events. Parameters ---------- None Returns ------- None \"\"\" for event in pygame . event . get (): if event . type == pygame . QUIT : self . running , self . playing = False , False self . curr_menu . run_display = False if event . type == pygame . KEYDOWN : if event . key == pygame . K_ESCAPE : self . ESC_KEY = True self . playing = False if event . key == pygame . K_RETURN : self . START_KEY = True if event . key == pygame . K_BACKSPACE : self . BACK_KEY = True if event . key == pygame . K_DOWN : self . DOWN_KEY = True if event . key == pygame . K_UP : self . UP_KEY = True def reset_keys ( self ): \"\"\" Reset the key flags to their initial state. Parameters ---------- None Returns ------- None \"\"\" self . UP_KEY , self . DOWN_KEY , self . START_KEY , self . BACK_KEY , self . ESC_KEY = False , False , False , False , False self . BUTTON_CLICKED = False def start ( self ): \"\"\" Start the game by displaying the main menu and entering the game loop. Parameters ---------- None Returns ------- None \"\"\" while not self . playing : self . curr_menu . display_menu () if not self . running : return self . game_loop ()","title":"Methods"},{"location":"#src.state_control.StateControl.__init__","text":"Initialize the StateControl object.","title":"__init__()"},{"location":"#src.state_control.StateControl.__init__--parameters","text":"None","title":"Parameters"},{"location":"#src.state_control.StateControl.__init__--returns","text":"None Source code in src/state_control.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def __init__ ( self ): \"\"\" Initialize the StateControl object. Parameters ---------- None Returns ------- None \"\"\" # Inicia\u00e7\u00e3o das vari\u00e1veis de controle self . running , self . playing = True , False self . UP_KEY , self . DOWN_KEY , self . START_KEY , self . BACK_KEY , self . ESC_KEY = False , False , False , False , False self . BUTTON_CLICKED = False # Cria a tela do jogo self . screen = pygame . display . set_mode (( WIDTH , HEIGHT )) pygame . display . set_caption ( \"Vectrun\" ) pygame . display . set_icon ( pygame . image . load ( TEXTURE_PATH + \"icon.png\" )) # Cria o rel\u00f3gio interno do FPS self . fps_clock = pygame . time . Clock () # Cria um objeto para cada uma das telas self . main_menu = MainMenu ( self , ( TEXTURE_PATH + \"vectrun_logo.png\" ), ( WIDTH / 2 , HEIGHT / 5 ), ( LOGO_X , LOGO_Y )) self . options_menu = OptionsMenu ( self , ( TEXTURE_PATH + \"options_button.png\" ), ( WIDTH / 2 , ( HEIGHT / 6 - 50 )), ( 2 * BUTTON_X , 2 * BUTTON_Y )) self . credits_menu = CreditsMenu ( self , ( TEXTURE_PATH + \"credits_button.png\" ), ( WIDTH / 2 , ( HEIGHT / 6 - 50 )), ( 2 * BUTTON_X , 2 * BUTTON_Y )) # EDI\u00c7\u00e3o FUtura para considerar ambos casos (derrrota e virtoria) self . result_screen = ResultScreen ( self , ( TEXTURE_PATH + \"you_win.png\" ), ( WIDTH / 2 , HEIGHT / 2 ), ( LOGO_X , LOGO_Y )) # Define a tela inicial self . curr_menu = self . main_menu # Cria um objeto para o jogo self . game_run = GridGame ( TEXTURE_PATH + \"grid.png\" , ( 0 , 0 ), ( GRID_X , GRID_Y ), 3 )","title":"Returns"},{"location":"#src.state_control.StateControl.check_events","text":"Check for user events such as key presses or window close events.","title":"check_events()"},{"location":"#src.state_control.StateControl.check_events--parameters","text":"None","title":"Parameters"},{"location":"#src.state_control.StateControl.check_events--returns","text":"None Source code in src/state_control.py 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 def check_events ( self ): \"\"\" Check for user events such as key presses or window close events. Parameters ---------- None Returns ------- None \"\"\" for event in pygame . event . get (): if event . type == pygame . QUIT : self . running , self . playing = False , False self . curr_menu . run_display = False if event . type == pygame . KEYDOWN : if event . key == pygame . K_ESCAPE : self . ESC_KEY = True self . playing = False if event . key == pygame . K_RETURN : self . START_KEY = True if event . key == pygame . K_BACKSPACE : self . BACK_KEY = True if event . key == pygame . K_DOWN : self . DOWN_KEY = True if event . key == pygame . K_UP : self . UP_KEY = True","title":"Returns"},{"location":"#src.state_control.StateControl.game_loop","text":"Main game loop that updates and renders the game until the game is no longer being played.","title":"game_loop()"},{"location":"#src.state_control.StateControl.game_loop--parameters","text":"None","title":"Parameters"},{"location":"#src.state_control.StateControl.game_loop--returns","text":"None Source code in src/state_control.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def game_loop ( self ): \"\"\" Main game loop that updates and renders the game until the game is no longer being played. Parameters ---------- None Returns ------- None \"\"\" while self . playing : # Preenche a tela self . screen . fill ( BLACK ) # Atualiza e exibe o jogo na tela self . game_run . update () self . game_run . draw ( self . screen ) # Enfim mostra o diplay pygame . display . update () self . fps_clock . tick ( 30 ) # INSERIR AQUI # (DETECTAR DERROTA OU VITORIA) if False : self . curr_menu = self . result_screen","title":"Returns"},{"location":"#src.state_control.StateControl.reset_keys","text":"Reset the key flags to their initial state.","title":"reset_keys()"},{"location":"#src.state_control.StateControl.reset_keys--parameters","text":"None","title":"Parameters"},{"location":"#src.state_control.StateControl.reset_keys--returns","text":"None Source code in src/state_control.py 159 160 161 162 163 164 165 166 167 168 169 170 171 172 def reset_keys ( self ): \"\"\" Reset the key flags to their initial state. Parameters ---------- None Returns ------- None \"\"\" self . UP_KEY , self . DOWN_KEY , self . START_KEY , self . BACK_KEY , self . ESC_KEY = False , False , False , False , False self . BUTTON_CLICKED = False","title":"Returns"},{"location":"#src.state_control.StateControl.start","text":"Start the game by displaying the main menu and entering the game loop.","title":"start()"},{"location":"#src.state_control.StateControl.start--parameters","text":"None","title":"Parameters"},{"location":"#src.state_control.StateControl.start--returns","text":"None Source code in src/state_control.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 def start ( self ): \"\"\" Start the game by displaying the main menu and entering the game loop. Parameters ---------- None Returns ------- None \"\"\" while not self . playing : self . curr_menu . display_menu () if not self . running : return self . game_loop ()","title":"Returns"},{"location":"#src.utilities.Singleton","text":"This class is used to create a singleton object.","title":"Singleton"},{"location":"#src.utilities.Singleton--attributes","text":"aClass : object The object to be initialized. instance : object The instance of the object.","title":"Attributes"},{"location":"#src.utilities.Singleton--methods","text":"init (self, cls) Initialize the Utilities class. call (self, args, *kwargs) Execute the object call as a function. Source code in src/utilities.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 class Singleton (): \"\"\" This class is used to create a singleton object. Attributes ---------- aClass : object The object to be initialized. instance : object The instance of the object. Methods ------- __init__(self, cls) Initialize the Utilities class. __call__(self, *args, **kwargs) Execute the object call as a function. \"\"\" def __init__ ( self , cls ): \"\"\" Initialize the Utilities class. Parameters ---------- cls : object The object to be initialized. Returns ------- None \"\"\" # Salva a classe original self . aClass = cls self . instance = None def __call__ ( self , * args , ** kwargs ): \"\"\" Execute the object call as a function. Parameters ---------- *args : positional arguments Positional arguments passed to the function. **kwargs : keyword arguments Keyword arguments passed to the function. Returns ------- object The result of the function call. \"\"\" # Usa o mesmo objeto em todas chamadas if self . instance is None : self . instance = self . aClass ( * args , ** kwargs ) return self . instance","title":"Methods"},{"location":"#src.utilities.Singleton.__call__","text":"Execute the object call as a function.","title":"__call__()"},{"location":"#src.utilities.Singleton.__call__--parameters","text":"args : positional arguments Positional arguments passed to the function. *kwargs : keyword arguments Keyword arguments passed to the function.","title":"Parameters"},{"location":"#src.utilities.Singleton.__call__--returns","text":"object The result of the function call. Source code in src/utilities.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 def __call__ ( self , * args , ** kwargs ): \"\"\" Execute the object call as a function. Parameters ---------- *args : positional arguments Positional arguments passed to the function. **kwargs : keyword arguments Keyword arguments passed to the function. Returns ------- object The result of the function call. \"\"\" # Usa o mesmo objeto em todas chamadas if self . instance is None : self . instance = self . aClass ( * args , ** kwargs ) return self . instance","title":"Returns"},{"location":"#src.utilities.Singleton.__init__","text":"Initialize the Utilities class.","title":"__init__()"},{"location":"#src.utilities.Singleton.__init__--parameters","text":"cls : object The object to be initialized.","title":"Parameters"},{"location":"#src.utilities.Singleton.__init__--returns","text":"None Source code in src/utilities.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 def __init__ ( self , cls ): \"\"\" Initialize the Utilities class. Parameters ---------- cls : object The object to be initialized. Returns ------- None \"\"\" # Salva a classe original self . aClass = cls self . instance = None","title":"Returns"},{"location":"#src.utilities.__hide_mask_origin","text":"Hide the origin of the line mask.","title":"__hide_mask_origin()"},{"location":"#src.utilities.__hide_mask_origin--parameters","text":"line_mask : pygame.mask.Mask The original line mask.","title":"Parameters"},{"location":"#src.utilities.__hide_mask_origin--returns","text":"pygame.mask.Mask The new line mask with the origin hidden. Source code in src/utilities.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 def __hide_mask_origin ( line_mask ): \"\"\" Hide the origin of the line mask. Parameters ---------- line_mask : pygame.mask.Mask The original line mask. Returns ------- pygame.mask.Mask The new line mask with the origin hidden. \"\"\" new_mask = line_mask . copy () # Cria uma pequena m\u00e1scara entorno da origem origin_mask = pygame . mask . Mask (( RIDER_X , RIDER_Y ), fill = True ) size = origin_mask . get_size () # Apaga de fato a origem de temp_mask new_mask . erase ( origin_mask , ( GRID_X / 2 - size [ 0 ] / 2 , GRID_Y / 2 - size [ 1 ] / 2 )) return new_mask","title":"Returns"},{"location":"#src.utilities.__last_vector_collision","text":"Check if the last vector collision occurred between two vectors.","title":"__last_vector_collision()"},{"location":"#src.utilities.__last_vector_collision--parameters","text":"card : tuple The current vector represented as a tuple (x, y). last_card : tuple The previous vector represented as a tuple (x, y).","title":"Parameters"},{"location":"#src.utilities.__last_vector_collision--returns","text":"bool True if the last vector collision occurred, False otherwise.","title":"Returns"},{"location":"#src.utilities.__last_vector_collision--notes","text":"The function checks if the last vector collision occurred by comparing the x and y components of the current and previous vectors. If any component is zero, it only checks the other component. If both components are non-zero, it checks if the vectors are proportional. If the vectors are proportional and have opposite signs, it considers it as a collision.","title":"Notes"},{"location":"#src.utilities.__last_vector_collision--examples","text":"__last_vector_collision((1, 2), (-1, -2)) True __last_vector_collision((3, 4), (5, 6)) False Source code in src/utilities.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 def __last_vector_collision ( card , last_card ): \"\"\" Check if the last vector collision occurred between two vectors. Parameters ---------- card : tuple The current vector represented as a tuple (x, y). last_card : tuple The previous vector represented as a tuple (x, y). Returns ------- bool True if the last vector collision occurred, False otherwise. Notes ----- The function checks if the last vector collision occurred by comparing the x and y components of the current and previous vectors. If any component is zero, it only checks the other component. If both components are non-zero, it checks if the vectors are proportional. If the vectors are proportional and have opposite signs, it considers it as a collision. Examples -------- >>> __last_vector_collision((1, 2), (-1, -2)) True >>> __last_vector_collision((3, 4), (5, 6)) False \"\"\" # Se algum valor de (x, y) for 0 verifica apenas o outro valor if not card [ 0 ] and not last_card [ 0 ]: if card [ 1 ] * last_card [ 1 ] < 0 : return True elif not card [ 1 ] and not last_card [ 1 ]: if card [ 0 ] * last_card [ 0 ] < 0 : return True # Se nenhum for, verifica se s\u00e3o proporcionais elif card [ 0 ] != 0 and card [ 1 ] != 0 : if last_card [ 0 ] / card [ 0 ] == last_card [ 1 ] / card [ 1 ]: if last_card [ 0 ] / card [ 0 ] < 0 : return True else : return False","title":"Examples"},{"location":"#src.utilities.check_border_collision","text":"Checks if the rider's position collides with the grid borders.","title":"check_border_collision()"},{"location":"#src.utilities.check_border_collision--parameters","text":"rider_position : tuple The current position of the rider (x, y).","title":"Parameters"},{"location":"#src.utilities.check_border_collision--returns","text":"bool True if there is a collision with the borders, False otherwise. Source code in src/utilities.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 def check_border_collision ( rider_position : tuple ) -> bool : \"\"\" Checks if the rider's position collides with the grid borders. Parameters ---------- rider_position : tuple The current position of the rider (x, y). Returns ------- bool True if there is a collision with the borders, False otherwise. \"\"\" if rider_position [ 0 ] > GRID_X - BORDER or rider_position [ 0 ] < BORDER : return True if rider_position [ 1 ] > GRID_Y - BORDER or rider_position [ 1 ] < BORDER : return True return False","title":"Returns"},{"location":"#src.utilities.check_line_collision","text":"Check if there is a collision between the rider's line and the lines of other players.","title":"check_line_collision()"},{"location":"#src.utilities.check_line_collision--parameters","text":"players_group : Group Group containing all the players. rider : Player Current player. card : Card, optional Selected card. Defaults to None.","title":"Parameters"},{"location":"#src.utilities.check_line_collision--returns","text":"bool True if there is a collision, False otherwise. Source code in src/utilities.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def check_line_collision ( players_group , rider , card = None ): \"\"\" Check if there is a collision between the rider's line and the lines of other players. Parameters ---------- players_group : Group Group containing all the players. rider : Player Current player. card : Card, optional Selected card. Defaults to None. Returns ------- bool True if there is a collision, False otherwise. \"\"\" # Cria um grupo com todos jogadores menos o rider atual temp_group = players_group . copy () temp_group . remove ( rider ) # Testa se ele colide com a linha de cada um dos outros for enemy in temp_group : for index in range ( 2 , len ( enemy . _path )): temp_coord = rider . mask . clipline ( enemy . _path [ index - 1 ], enemy . _path [ index ]) # Se a linha colidir, desenpacota a tupla que clipline retorna if temp_coord : return True # No caso de colidir com as pr\u00f3prias linhas for index in range ( 2 , len ( rider . _path [: - 1 ])): temp_coord = rider . mask . clipline ( rider . _path [ index - 1 ], rider . _path [ index ]) # Desenpacota a tupla que clipline retorna if temp_coord : return True # Se n\u00e3o passou card usa a que estiver salva if not card : card = rider . clicked_card # E ent\u00e3o compara com o \u00faltimo vetor usado: se for m\u00faltiplo e contr\u00e1rio ao anterior deve haver colis\u00e3o if __last_vector_collision ( card , rider . _last_card ): return True return False","title":"Returns"},{"location":"#src.utilities.check_line_cross","text":"Check if a line crosses with other players' lines or with its own line.","title":"check_line_cross()"},{"location":"#src.utilities.check_line_cross--parameters","text":"players_group : pygame.sprite.Group A group containing all players except the current player. player : Player The current player. line : pygame.Surface The line to check for collisions. card : Card, optional The card used to draw the line. Defaults to None.","title":"Parameters"},{"location":"#src.utilities.check_line_cross--returns","text":"bool True if the line crosses with other players' lines or with its own line, False otherwise. Source code in src/utilities.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 def check_line_cross ( players_group , player , line , card = None ): \"\"\" Check if a line crosses with other players' lines or with its own line. Parameters ---------- players_group : pygame.sprite.Group A group containing all players except the current player. player : Player The current player. line : pygame.Surface The line to check for collisions. card : Card, optional The card used to draw the line. Defaults to None. Returns ------- bool True if the line crosses with other players' lines or with its own line, False otherwise. \"\"\" # Cria um grupo com todos jogadores menos o rider atual temp_group = players_group . copy () temp_group . remove ( player ) # Se a linha colidir com o caminho de outro rider retorna True for rider in temp_group . sprites (): temp_line = rider . line_mask # No caso de ser o primeiro movimento do player \u00e9 necess\u00e1rio esconder # A origem da linha do inimigo para que elas n\u00e3o colidam ali # Pois por ser o primeiro turno, todas sair\u00e3o dali if not player . line_mask . get_at (( GRID_X / 2 - 1 , GRID_Y / 2 - 2 )): temp_line = __hide_mask_origin ( temp_line ) # Verifica se houve overlap das linhas if line . overlap ( temp_line , ( 0 , 0 )): return True # Se a linha colidir com alguma das pr\u00f3prias retorna True if line . overlap ( player . _last_line_mask , ( 0 , 0 )): return True # Se n\u00e3o passou card usa a que estiver salva if not card : card = player . clicked_card # E verifica se elas n\u00e3o s\u00e3o contr\u00e1rias if __last_vector_collision ( card , player . _last_card ): return True return False","title":"Returns"},{"location":"#src.utilities.check_riders_collision","text":"Check collision between two sprite groups and remove collided sprites.","title":"check_riders_collision()"},{"location":"#src.utilities.check_riders_collision--parameters","text":"group_1 : pygame.sprite.Group The first sprite group to check collision with. group_2 : pygame.sprite.Group The second sprite group to check collision with.","title":"Parameters"},{"location":"#src.utilities.check_riders_collision--returns","text":"None This function does not return any value. It modifies the sprite groups in-place. Source code in src/utilities.py 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 def check_riders_collision ( group_1 , group_2 ): \"\"\" Check collision between two sprite groups and remove collided sprites. Parameters ---------- group_1 : pygame.sprite.Group The first sprite group to check collision with. group_2 : pygame.sprite.Group The second sprite group to check collision with. Returns ------- None This function does not return any value. It modifies the sprite groups in-place. \"\"\" pygame . sprite . groupcollide ( group_1 , group_2 , True , True )","title":"Returns"}]}